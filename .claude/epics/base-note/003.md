---
name: Flow节点开发：NoteNode组件和基础交互（TDD）
status: open
created: 2025-10-07T00:00:00Z
github: [待创建GitHub Issue]
depends_on: [008, 001, 002]
parallel: false
conflicts_with: []
---

# Task: Flow节点开发：NoteNode组件和基础交互（TDD）

## Description

**采用TDD（测试驱动开发）方法**基于现有FlowCanvas组件扩展，实现NoteNode自定义节点组件，支持笔记的创建、编辑、移动、删除等基础交互功能，集成Markdown渲染能力，建立React Flow与数据层的双向绑定机制。

**TDD开发流程**：严格遵循Red-Green-Refactor循环，先为每个Flow功能编写失败的测试，再实现功能，最后优化性能和用户体验。

## Acceptance Criteria

### 🔴 TDD阶段：测试先行（Red）
- [ ] **编写Flow组件测试套件**：先为所有Flow功能编写失败的测试
- [ ] **NoteNode组件测试**：节点渲染、交互、状态管理的完整测试
- [ ] **编辑器面板测试**：右边栏编辑器的打开、编辑、保存、关闭功能测试
- [ ] **数据绑定测试**：节点位置变化与数据库同步的测试
- [ ] **用户交互测试**：点击、拖拽、键盘快捷键等交互测试
- [ ] **性能基准测试**：大量节点操作的性能基准测试
- [ ] **集成测试**：FlowCanvas与MarkdownRenderer的集成测试

### 🟢 实现阶段：功能实现（Green）
- [ ] 扩展现有FlowCanvas，注册NoteNode自定义节点类型，让TDD测试通过
- [ ] 实现NoteNode组件，支持笔记内容显示和基础交互
- [ ] 集成Markdown渲染功能，支持笔记内容实时预览
- [ ] **实现右边栏编辑系统**：点击节点在右边半屏打开详细编辑器
- [ ] 实现节点拖拽移动，位置变化自动保存到数据库
- [ ] 实现分屏编辑：左边编辑器（50%），右边Markdown预览（50%）
- [ ] 实现自动保存功能和保存状态显示

### 🔄 重构阶段：代码优化（Refactor）
- [ ] **优化节点渲染性能**：在保持测试通过的前提下优化大量节点场景
- [ ] **重构编辑器组件**：提升编辑器的可复用性和用户体验
- [ ] **优化状态管理**：减少不必要的重渲染，提升响应速度
- [ ] **TDD质量验证**：确保测试覆盖率≥90%，所有测试稳定通过

## Technical Details

### TDD测试设计

#### NoteNode组件测试
```typescript
/ src/components/flow NoteNode.test.tsx
describe('NoteNode TDD', () => {
  describe('Node Rendering', () => {
    it('should render note with correct title and content', () => {
      const mockData = {
        title: 'Test Note',
        content: 'This is test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      const { getByText } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
        />
      );

      expect(getByText('Test Note')).toBeInTheDocument();
      expect(getByText('This is test content')).toBeInTheDocument();
    });

    it('should show selected state correctly', () => {
      const { container } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={true}
          dragging={false}
        />
      );

      expect(container.querySelector('.selected')).toBeInTheDocument();
    });

    it('should show tags correctly', () => {
      const dataWithTags = {
        ...mockData,
        tags: ['work', 'important']
      };

      const { getByText } = render(
        <NoteNode
          id="note-1"
          data={dataWithTags}
          selected={false}
          dragging={false}
        />
      );

      expect(getByText('work')).toBeInTheDocument();
      expect(getByText('important')).toBeInTheDocument();
    });
  });

  describe('Node Interactions', () => {
    it('should call onNodeClick when clicked', async () => {
      const mockOnNodeClick = jest.fn();
      const user = userEvent.setup();

      const { getByRole } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
          onNodeClick={mockOnNodeClick}
        />
      );

      await user.click(getByRole('button', { name: /note/i }));

      expect(mockOnNodeClick).toHaveBeenCalledWith('note-1');
    });

    it('should handle drag events correctly', async () => {
      const mockOnDragStart = jest.fn();
      const mockOnDragEnd = jest.fn();

      const { getByRole } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
          onDragStart={mockOnDragStart}
          onDragEnd={mockOnDragEnd}
        />
      );

      const node = getByRole('button', { name: /note/i });

      / 模拟拖拽开始
      fireEvent.dragStart(node);
      expect(mockOnDragStart).toHaveBeenCalled();

      / 模拟拖拽结束
      fireEvent.dragEnd(node);
      expect(mockOnDragEnd).toHaveBeenCalled();
    });
  });
});
```

#### 编辑器面板测试
```typescript
/ src/components/flow NoteEditorPanel.test.tsx
describe('NoteEditorPanel TDD', () => {
  describe('Panel Rendering', () => {
    it('should render editor panel with correct fields', () => {
      const mockProps = {
        noteId: 'note-1',
        isOpen: true,
        onClose: jest.fn(),
        onSave: jest.fn(),
        onDelete: jest.fn()
      };

      const { getByLabelText, getByRole } = render(
        <NoteEditorPanel {...mockProps} />
      );

      expect(getByLabelText(/title/i)).toBeInTheDocument();
      expect(getByLabelText(/content/i)).toBeInTheDocument();
      expect(getByRole('button', { name: /save/i })).toBeInTheDocument();
      expect(getByRole('button', { name: /delete/i })).toBeInTheDocument();
    });

    it('should show loading state while saving', async () => {
      const mockSave = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={mockSave}
          onDelete={jest.fn()}
        />
      );

      const saveButton = getByRole('button', { name: /save/i });
      await userEvent.click(saveButton);

      expect(getByRole('button', { name: /saving/i })).toBeInTheDocument();
    });
  });

  describe('Editing Functionality', () => {
    it('should update title when typed', async () => {
      const { getByLabelText } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={jest.fn()}
          onDelete={jest.fn()}
        />
      );

      const titleInput = getByLabelText(/title/i);
      await userEvent.type(titleInput, 'New Title');

      expect(titleInput).toHaveValue('New Title');
    });

    it('should auto-save content after typing stops', async () => {
      jest.useFakeTimers();
      const mockSave = jest.fn();

      const { getByLabelText } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={mockSave}
          onDelete={jest.fn()}
        />
      );

      const contentInput = getByLabelText(/content/i);
      await userEvent.type(contentInput, 'New content');

      / 快进2秒（自动保存延迟）
      jest.advanceTimersByTime(2000);

      expect(mockSave).toHaveBeenCalledWith(
        'note-1',
        expect.objectContaining({ content: 'New content' })
      );
    });
  });

  describe('Panel Actions', () => {
    it('should call onClose when close button clicked', async () => {
      const mockOnClose = jest.fn();

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={mockOnClose}
          onSave={jest.fn()}
          onDelete={jest.fn()}
        />
      );

      const closeButton = getByRole('button', { name: /close/i });
      await userEvent.click(closeButton);

      expect(mockOnClose).toHaveBeenCalled();
    });

    it('should show delete confirmation dialog', async () => {
      const mockOnDelete = jest.fn();

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={jest.fn()}
          onDelete={mockOnDelete}
        />
      );

      const deleteButton = getByRole('button', { name: /delete/i });
      await userEvent.click(deleteButton);

      expect(getByRole('dialog', { name: /confirm delete/i })).toBeInTheDocument();
    });
  });
});
```

#### FlowCanvas集成测试
```typescript
/ src/components/flow FlowCanvas.integration.test.tsx
describe('FlowCanvas Integration TDD', () => {
  describe('Node Creation', () => {
    it('should create new note on double click', async () => {
      const mockOnNoteCreate = jest.fn().mockResolvedValue('new-note-id');

      const { container } = render(
        <FlowCanvas
          onNoteCreate={mockOnNoteCreate}
          enableNoteCreation={true}
        />
      );

      const canvas = container.querySelector('.react-flow');
      await userEvent.dblClick(canvas);

      expect(mockOnNoteCreate).toHaveBeenCalledWith(
        expect.objectContaining({ x: expect.any(Number), y: expect.any(Number) })
      );
    });
  });

  describe('Node Selection', () => {
    it('should open editor panel when node clicked', async () => {
      const mockOpenEditor = jest.fn();

      const { getByRole } = render(
        <FlowCanvas
          nodes={[mockFlowNode]}
          onNodeSelect={mockOpenEditor}
        />
      );

      const node = getByRole('button', { name: /note/i });
      await userEvent.click(node);

      expect(mockOpenEditor).toHaveBeenCalledWith('note-1');
    });
  });

  describe('Position Synchronization', () => {
    it('should save position when node moved', async () => {
      const mockOnNoteUpdate = jest.fn();

      const { getByRole } = render(
        <FlowCanvas
          nodes={[mockFlowNode]}
          onNoteUpdate={mockOnNoteUpdate}
        />
      );

      const node = getByRole('button', { name: /note/i });

      / 模拟拖拽到新位置
      fireEvent.dragStart(node);
      fireEvent.drop(node, { clientX: 200, clientY: 300 });

      expect(mockOnNoteUpdate).toHaveBeenCalledWith(
        'note-1',
        expect.objectContaining({
          position_x: 200,
          position_y: 300
        })
      );
    });
  });
});
```

#### 性能基准测试
```typescript
/ src/test/performance/flow.test.tsx
describe('FlowNode Performance TDD', () => {
  it('should render 100 nodes within performance threshold', async () => {
    const nodes = Array.from({ length: 100 }, (_, i) =>
      createMockFlowNode({ id: `node-${i}` })
    );

    const startTime = performance.now();

    const { container } = render(
      <FlowCanvas nodes={nodes} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(1000); / 1秒内完成
    expect(container.querySelectorAll('[data-node-id]').length).toBe(100);
  });

  it('should handle node dragging smoothly with large dataset', async () => {
    const nodes = Array.from({ length: 500 }, (_, i) =>
      createMockFlowNode({ id: `node-${i}` })
    );

    const { getByRole } = render(
      <FlowCanvas nodes={nodes} />
    );

    const node = getByRole('button', { name: /note-1/i });

    const startTime = performance.now();

    / 模拟连续拖拽事件
    fireEvent.dragStart(node);
    for (let i = 0; i < 10; i++) {
      fireEvent.drag(node, { clientX: 100 + i * 10, clientY: 100 + i * 10 });
    }
    fireEvent.dragEnd(node);

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(100); / 拖拽响应时间<100ms
  });
});
```

### 组件架构设计

#### TDD组件接口
```typescript
/ src/components/flow/nodes/NoteNode.tsx
interface NoteNodeProps {
  id: string;
  data: {
    title: string;
    content: string;
    created_at: Date;
    updated_at: Date;
    tags?: string[];
  };
  selected: boolean;
  dragging: boolean;
  onNodeClick?: (nodeId: string) => void;
  onDragStart?: (nodeId: string) => void;
  onDragEnd?: (nodeId: string, position: { x: number; y: number }) => void;
}

/ src/components/flow/NoteEditorPanel.tsx
interface NoteEditorPanelProps {
  noteId: string | null;
  isOpen: boolean;
  onClose: () => void;
  onSave: (id: string, updates: Partial<Note>) => Promise<void>;
  onDelete: (id: string) => Promise<void>;
}

/ src/components/flow/FlowCanvas.tsx 扩展
interface FlowCanvasProps {
  nodes: FlowNode[];
  edges: FlowEdge[];
  onNoteCreate?: (position: { x: number; y: number }) => Promise<string>;
  onNoteUpdate?: (id: string, updates: Partial<Note>) => Promise<void>;
  onNoteDelete?: (id: string) => Promise<void>;
  onNodeSelect?: (nodeId: string | null) => void;
  enableNoteCreation?: boolean;
  selectedNodeId?: string | null;
}
```

### TDD实现要点

#### Red阶段：失败的测试
- **组件渲染测试**：节点正确显示标题、内容、标签
- **交互功能测试**：点击、拖拽、键盘操作
- **编辑器测试**：面板打开、内容编辑、自动保存
- **数据同步测试**：位置变化与数据库同步
- **性能基准测试**：大量节点场景的性能表现

#### Green阶段：最小实现
- **基础组件**：实现最简功能让测试通过
- **事件绑定**：建立React Flow与数据层的连接
- **状态管理**：实现编辑器状态和选中状态
- **样式集成**：与shadcn/ui设计系统保持一致

#### Refactor阶段：优化提升
- **性能优化**：虚拟化、防抖、缓存机制
- **用户体验**：动画过渡、加载状态、错误处理
- **代码质量**：组件拆分、复用性、可测试性

### 依赖包选择

```json
{
  "dependencies": {
    "react-flow": "^11.11.4",
    "zustand": "^4.4.6",
    "framer-motion": "^10.16.5",
    "monaco-editor": "^0.44.0",
    "@monaco-editor/react": "^4.6.0"
  }
}
```

### 代码文件影响

#### TDD测试文件（优先级最高）
- `src/components/flow NoteNode.test.tsx` - NoteNode组件完整测试
- `src/components/flow NoteEditorPanel.test.tsx` - 编辑器面板测试
- `src/components/flow FlowCanvas.integration.test.tsx` - 集成测试
- `src/test/performance/flow.test.tsx` - 性能基准测试
- `src/hooks useFlowNodes.test.ts` - Flow相关hooks测试

#### 核心实现文件
- `src/components/flow/nodes/NoteNode.tsx` - 主节点组件
- `src/components/flow/NoteEditorPanel.tsx` - 编辑器面板组件
- `src/components/flow/FlowCanvas.tsx` - 扩展画布组件
- `src/stores/useFlowStore.ts` - Flow状态管理
- `src/hooks/useFlowNodes.ts` - Flow相关hooks
- `src/services/flow/FlowService.ts` - Flow服务层

## Dependencies

- [ ] **任务008：TDD基础设施**完成，测试框架就位
- [ ] **任务001：数据层扩展**完成，schema就位
- [ ] **任务002：Markdown渲染**完成，渲染组件可用
- [ ] 现有FlowCanvas组件正常运行

## Effort Estimate

- Size: L（包含大量测试和UI组件工作）
- Days: 4天
- Parallel: false（依赖前置任务）

### 工作量分解
- **TDD测试编写**：1.5天（最重要，优先级最高）
- **功能实现**：1.5天（让测试通过）
- **重构优化**：0.5天（性能和用户体验）
- **集成验证**：0.5天（端到端测试）

## Definition of Done

- [ ] **TDD流程完整**：Red-Green-Refactor循环完整执行
- [ ] **NoteNode组件**：功能完整，测试覆盖率≥90%
- [ ] **编辑器面板**：分屏编辑、自动保存功能完整
- [ ] **交互体验**：点击、拖拽、键盘操作流畅
- [ ] **性能达标**：100个节点操作流畅，性能测试通过
- [ ] **数据绑定**：React Flow与数据库双向同步稳定
- [ ] **代码质量**：通过所有linting和类型检查
- [ ] **集成测试**：与MarkdownRenderer等组件集成无问题