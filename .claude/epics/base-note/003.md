---
name: FlowèŠ‚ç‚¹å¼€å‘ï¼šNoteNodeç»„ä»¶å’ŒåŸºç¡€äº¤äº’ï¼ˆTDDï¼‰
status: open
created: 2025-10-07T00:00:00Z
github: [å¾…åˆ›å»ºGitHub Issue]
depends_on: [008, 001, 002]
parallel: false
conflicts_with: []
---

# Task: FlowèŠ‚ç‚¹å¼€å‘ï¼šNoteNodeç»„ä»¶å’ŒåŸºç¡€äº¤äº’ï¼ˆTDDï¼‰

## Description

**é‡‡ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰æ–¹æ³•**åŸºäºç°æœ‰FlowCanvasç»„ä»¶æ‰©å±•ï¼Œå®ç°NoteNodeè‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶ï¼Œæ”¯æŒç¬”è®°çš„åˆ›å»ºã€ç¼–è¾‘ã€ç§»åŠ¨ã€åˆ é™¤ç­‰åŸºç¡€äº¤äº’åŠŸèƒ½ï¼Œé›†æˆMarkdownæ¸²æŸ“èƒ½åŠ›ï¼Œå»ºç«‹React Flowä¸æ•°æ®å±‚çš„åŒå‘ç»‘å®šæœºåˆ¶ã€‚

**TDDå¼€å‘æµç¨‹**ï¼šä¸¥æ ¼éµå¾ªRed-Green-Refactorå¾ªç¯ï¼Œå…ˆä¸ºæ¯ä¸ªFlowåŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½ï¼Œæœ€åä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

## Acceptance Criteria

### ğŸ”´ TDDé˜¶æ®µï¼šæµ‹è¯•å…ˆè¡Œï¼ˆRedï¼‰
- [ ] **ç¼–å†™Flowç»„ä»¶æµ‹è¯•å¥—ä»¶**ï¼šå…ˆä¸ºæ‰€æœ‰FlowåŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•
- [ ] **NoteNodeç»„ä»¶æµ‹è¯•**ï¼šèŠ‚ç‚¹æ¸²æŸ“ã€äº¤äº’ã€çŠ¶æ€ç®¡ç†çš„å®Œæ•´æµ‹è¯•
- [ ] **ç¼–è¾‘å™¨é¢æ¿æµ‹è¯•**ï¼šå³è¾¹æ ç¼–è¾‘å™¨çš„æ‰“å¼€ã€ç¼–è¾‘ã€ä¿å­˜ã€å…³é—­åŠŸèƒ½æµ‹è¯•
- [ ] **æ•°æ®ç»‘å®šæµ‹è¯•**ï¼šèŠ‚ç‚¹ä½ç½®å˜åŒ–ä¸æ•°æ®åº“åŒæ­¥çš„æµ‹è¯•
- [ ] **ç”¨æˆ·äº¤äº’æµ‹è¯•**ï¼šç‚¹å‡»ã€æ‹–æ‹½ã€é”®ç›˜å¿«æ·é”®ç­‰äº¤äº’æµ‹è¯•
- [ ] **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡èŠ‚ç‚¹æ“ä½œçš„æ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] **é›†æˆæµ‹è¯•**ï¼šFlowCanvasä¸MarkdownRendererçš„é›†æˆæµ‹è¯•

### ğŸŸ¢ å®ç°é˜¶æ®µï¼šåŠŸèƒ½å®ç°ï¼ˆGreenï¼‰
- [ ] æ‰©å±•ç°æœ‰FlowCanvasï¼Œæ³¨å†ŒNoteNodeè‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹ï¼Œè®©TDDæµ‹è¯•é€šè¿‡
- [ ] å®ç°NoteNodeç»„ä»¶ï¼Œæ”¯æŒç¬”è®°å†…å®¹æ˜¾ç¤ºå’ŒåŸºç¡€äº¤äº’
- [ ] é›†æˆMarkdownæ¸²æŸ“åŠŸèƒ½ï¼Œæ”¯æŒç¬”è®°å†…å®¹å®æ—¶é¢„è§ˆ
- [ ] **å®ç°å³è¾¹æ ç¼–è¾‘ç³»ç»Ÿ**ï¼šç‚¹å‡»èŠ‚ç‚¹åœ¨å³è¾¹åŠå±æ‰“å¼€è¯¦ç»†ç¼–è¾‘å™¨
- [ ] å®ç°èŠ‚ç‚¹æ‹–æ‹½ç§»åŠ¨ï¼Œä½ç½®å˜åŒ–è‡ªåŠ¨ä¿å­˜åˆ°æ•°æ®åº“
- [ ] å®ç°åˆ†å±ç¼–è¾‘ï¼šå·¦è¾¹ç¼–è¾‘å™¨ï¼ˆ50%ï¼‰ï¼Œå³è¾¹Markdowné¢„è§ˆï¼ˆ50%ï¼‰
- [ ] å®ç°è‡ªåŠ¨ä¿å­˜åŠŸèƒ½å’Œä¿å­˜çŠ¶æ€æ˜¾ç¤º

### ğŸ”„ é‡æ„é˜¶æ®µï¼šä»£ç ä¼˜åŒ–ï¼ˆRefactorï¼‰
- [ ] **ä¼˜åŒ–èŠ‚ç‚¹æ¸²æŸ“æ€§èƒ½**ï¼šåœ¨ä¿æŒæµ‹è¯•é€šè¿‡çš„å‰æä¸‹ä¼˜åŒ–å¤§é‡èŠ‚ç‚¹åœºæ™¯
- [ ] **é‡æ„ç¼–è¾‘å™¨ç»„ä»¶**ï¼šæå‡ç¼–è¾‘å™¨çš„å¯å¤ç”¨æ€§å’Œç”¨æˆ·ä½“éªŒ
- [ ] **ä¼˜åŒ–çŠ¶æ€ç®¡ç†**ï¼šå‡å°‘ä¸å¿…è¦çš„é‡æ¸²æŸ“ï¼Œæå‡å“åº”é€Ÿåº¦
- [ ] **TDDè´¨é‡éªŒè¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œæ‰€æœ‰æµ‹è¯•ç¨³å®šé€šè¿‡

## Technical Details

### TDDæµ‹è¯•è®¾è®¡

#### NoteNodeç»„ä»¶æµ‹è¯•
```typescript
/ src/components/flow NoteNode.test.tsx
describe('NoteNode TDD', () => {
  describe('Node Rendering', () => {
    it('should render note with correct title and content', () => {
      const mockData = {
        title: 'Test Note',
        content: 'This is test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      const { getByText } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
        />
      );

      expect(getByText('Test Note')).toBeInTheDocument();
      expect(getByText('This is test content')).toBeInTheDocument();
    });

    it('should show selected state correctly', () => {
      const { container } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={true}
          dragging={false}
        />
      );

      expect(container.querySelector('.selected')).toBeInTheDocument();
    });

    it('should show tags correctly', () => {
      const dataWithTags = {
        ...mockData,
        tags: ['work', 'important']
      };

      const { getByText } = render(
        <NoteNode
          id="note-1"
          data={dataWithTags}
          selected={false}
          dragging={false}
        />
      );

      expect(getByText('work')).toBeInTheDocument();
      expect(getByText('important')).toBeInTheDocument();
    });
  });

  describe('Node Interactions', () => {
    it('should call onNodeClick when clicked', async () => {
      const mockOnNodeClick = jest.fn();
      const user = userEvent.setup();

      const { getByRole } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
          onNodeClick={mockOnNodeClick}
        />
      );

      await user.click(getByRole('button', { name: /note/i }));

      expect(mockOnNodeClick).toHaveBeenCalledWith('note-1');
    });

    it('should handle drag events correctly', async () => {
      const mockOnDragStart = jest.fn();
      const mockOnDragEnd = jest.fn();

      const { getByRole } = render(
        <NoteNode
          id="note-1"
          data={mockData}
          selected={false}
          dragging={false}
          onDragStart={mockOnDragStart}
          onDragEnd={mockOnDragEnd}
        />
      );

      const node = getByRole('button', { name: /note/i });

      / æ¨¡æ‹Ÿæ‹–æ‹½å¼€å§‹
      fireEvent.dragStart(node);
      expect(mockOnDragStart).toHaveBeenCalled();

      / æ¨¡æ‹Ÿæ‹–æ‹½ç»“æŸ
      fireEvent.dragEnd(node);
      expect(mockOnDragEnd).toHaveBeenCalled();
    });
  });
});
```

#### ç¼–è¾‘å™¨é¢æ¿æµ‹è¯•
```typescript
/ src/components/flow NoteEditorPanel.test.tsx
describe('NoteEditorPanel TDD', () => {
  describe('Panel Rendering', () => {
    it('should render editor panel with correct fields', () => {
      const mockProps = {
        noteId: 'note-1',
        isOpen: true,
        onClose: jest.fn(),
        onSave: jest.fn(),
        onDelete: jest.fn()
      };

      const { getByLabelText, getByRole } = render(
        <NoteEditorPanel {...mockProps} />
      );

      expect(getByLabelText(/title/i)).toBeInTheDocument();
      expect(getByLabelText(/content/i)).toBeInTheDocument();
      expect(getByRole('button', { name: /save/i })).toBeInTheDocument();
      expect(getByRole('button', { name: /delete/i })).toBeInTheDocument();
    });

    it('should show loading state while saving', async () => {
      const mockSave = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={mockSave}
          onDelete={jest.fn()}
        />
      );

      const saveButton = getByRole('button', { name: /save/i });
      await userEvent.click(saveButton);

      expect(getByRole('button', { name: /saving/i })).toBeInTheDocument();
    });
  });

  describe('Editing Functionality', () => {
    it('should update title when typed', async () => {
      const { getByLabelText } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={jest.fn()}
          onDelete={jest.fn()}
        />
      );

      const titleInput = getByLabelText(/title/i);
      await userEvent.type(titleInput, 'New Title');

      expect(titleInput).toHaveValue('New Title');
    });

    it('should auto-save content after typing stops', async () => {
      jest.useFakeTimers();
      const mockSave = jest.fn();

      const { getByLabelText } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={mockSave}
          onDelete={jest.fn()}
        />
      );

      const contentInput = getByLabelText(/content/i);
      await userEvent.type(contentInput, 'New content');

      / å¿«è¿›2ç§’ï¼ˆè‡ªåŠ¨ä¿å­˜å»¶è¿Ÿï¼‰
      jest.advanceTimersByTime(2000);

      expect(mockSave).toHaveBeenCalledWith(
        'note-1',
        expect.objectContaining({ content: 'New content' })
      );
    });
  });

  describe('Panel Actions', () => {
    it('should call onClose when close button clicked', async () => {
      const mockOnClose = jest.fn();

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={mockOnClose}
          onSave={jest.fn()}
          onDelete={jest.fn()}
        />
      );

      const closeButton = getByRole('button', { name: /close/i });
      await userEvent.click(closeButton);

      expect(mockOnClose).toHaveBeenCalled();
    });

    it('should show delete confirmation dialog', async () => {
      const mockOnDelete = jest.fn();

      const { getByRole } = render(
        <NoteEditorPanel
          noteId="note-1"
          isOpen={true}
          onClose={jest.fn()}
          onSave={jest.fn()}
          onDelete={mockOnDelete}
        />
      );

      const deleteButton = getByRole('button', { name: /delete/i });
      await userEvent.click(deleteButton);

      expect(getByRole('dialog', { name: /confirm delete/i })).toBeInTheDocument();
    });
  });
});
```

#### FlowCanvasé›†æˆæµ‹è¯•
```typescript
/ src/components/flow FlowCanvas.integration.test.tsx
describe('FlowCanvas Integration TDD', () => {
  describe('Node Creation', () => {
    it('should create new note on double click', async () => {
      const mockOnNoteCreate = jest.fn().mockResolvedValue('new-note-id');

      const { container } = render(
        <FlowCanvas
          onNoteCreate={mockOnNoteCreate}
          enableNoteCreation={true}
        />
      );

      const canvas = container.querySelector('.react-flow');
      await userEvent.dblClick(canvas);

      expect(mockOnNoteCreate).toHaveBeenCalledWith(
        expect.objectContaining({ x: expect.any(Number), y: expect.any(Number) })
      );
    });
  });

  describe('Node Selection', () => {
    it('should open editor panel when node clicked', async () => {
      const mockOpenEditor = jest.fn();

      const { getByRole } = render(
        <FlowCanvas
          nodes={[mockFlowNode]}
          onNodeSelect={mockOpenEditor}
        />
      );

      const node = getByRole('button', { name: /note/i });
      await userEvent.click(node);

      expect(mockOpenEditor).toHaveBeenCalledWith('note-1');
    });
  });

  describe('Position Synchronization', () => {
    it('should save position when node moved', async () => {
      const mockOnNoteUpdate = jest.fn();

      const { getByRole } = render(
        <FlowCanvas
          nodes={[mockFlowNode]}
          onNoteUpdate={mockOnNoteUpdate}
        />
      );

      const node = getByRole('button', { name: /note/i });

      / æ¨¡æ‹Ÿæ‹–æ‹½åˆ°æ–°ä½ç½®
      fireEvent.dragStart(node);
      fireEvent.drop(node, { clientX: 200, clientY: 300 });

      expect(mockOnNoteUpdate).toHaveBeenCalledWith(
        'note-1',
        expect.objectContaining({
          position_x: 200,
          position_y: 300
        })
      );
    });
  });
});
```

#### æ€§èƒ½åŸºå‡†æµ‹è¯•
```typescript
/ src/test/performance/flow.test.tsx
describe('FlowNode Performance TDD', () => {
  it('should render 100 nodes within performance threshold', async () => {
    const nodes = Array.from({ length: 100 }, (_, i) =>
      createMockFlowNode({ id: `node-${i}` })
    );

    const startTime = performance.now();

    const { container } = render(
      <FlowCanvas nodes={nodes} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(1000); / 1ç§’å†…å®Œæˆ
    expect(container.querySelectorAll('[data-node-id]').length).toBe(100);
  });

  it('should handle node dragging smoothly with large dataset', async () => {
    const nodes = Array.from({ length: 500 }, (_, i) =>
      createMockFlowNode({ id: `node-${i}` })
    );

    const { getByRole } = render(
      <FlowCanvas nodes={nodes} />
    );

    const node = getByRole('button', { name: /note-1/i });

    const startTime = performance.now();

    / æ¨¡æ‹Ÿè¿ç»­æ‹–æ‹½äº‹ä»¶
    fireEvent.dragStart(node);
    for (let i = 0; i < 10; i++) {
      fireEvent.drag(node, { clientX: 100 + i * 10, clientY: 100 + i * 10 });
    }
    fireEvent.dragEnd(node);

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(100); / æ‹–æ‹½å“åº”æ—¶é—´<100ms
  });
});
```

### ç»„ä»¶æ¶æ„è®¾è®¡

#### TDDç»„ä»¶æ¥å£
```typescript
/ src/components/flow/nodes/NoteNode.tsx
interface NoteNodeProps {
  id: string;
  data: {
    title: string;
    content: string;
    created_at: Date;
    updated_at: Date;
    tags?: string[];
  };
  selected: boolean;
  dragging: boolean;
  onNodeClick?: (nodeId: string) => void;
  onDragStart?: (nodeId: string) => void;
  onDragEnd?: (nodeId: string, position: { x: number; y: number }) => void;
}

/ src/components/flow/NoteEditorPanel.tsx
interface NoteEditorPanelProps {
  noteId: string | null;
  isOpen: boolean;
  onClose: () => void;
  onSave: (id: string, updates: Partial<Note>) => Promise<void>;
  onDelete: (id: string) => Promise<void>;
}

/ src/components/flow/FlowCanvas.tsx æ‰©å±•
interface FlowCanvasProps {
  nodes: FlowNode[];
  edges: FlowEdge[];
  onNoteCreate?: (position: { x: number; y: number }) => Promise<string>;
  onNoteUpdate?: (id: string, updates: Partial<Note>) => Promise<void>;
  onNoteDelete?: (id: string) => Promise<void>;
  onNodeSelect?: (nodeId: string | null) => void;
  enableNoteCreation?: boolean;
  selectedNodeId?: string | null;
}
```

### TDDå®ç°è¦ç‚¹

#### Redé˜¶æ®µï¼šå¤±è´¥çš„æµ‹è¯•
- **ç»„ä»¶æ¸²æŸ“æµ‹è¯•**ï¼šèŠ‚ç‚¹æ­£ç¡®æ˜¾ç¤ºæ ‡é¢˜ã€å†…å®¹ã€æ ‡ç­¾
- **äº¤äº’åŠŸèƒ½æµ‹è¯•**ï¼šç‚¹å‡»ã€æ‹–æ‹½ã€é”®ç›˜æ“ä½œ
- **ç¼–è¾‘å™¨æµ‹è¯•**ï¼šé¢æ¿æ‰“å¼€ã€å†…å®¹ç¼–è¾‘ã€è‡ªåŠ¨ä¿å­˜
- **æ•°æ®åŒæ­¥æµ‹è¯•**ï¼šä½ç½®å˜åŒ–ä¸æ•°æ®åº“åŒæ­¥
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡èŠ‚ç‚¹åœºæ™¯çš„æ€§èƒ½è¡¨ç°

#### Greené˜¶æ®µï¼šæœ€å°å®ç°
- **åŸºç¡€ç»„ä»¶**ï¼šå®ç°æœ€ç®€åŠŸèƒ½è®©æµ‹è¯•é€šè¿‡
- **äº‹ä»¶ç»‘å®š**ï¼šå»ºç«‹React Flowä¸æ•°æ®å±‚çš„è¿æ¥
- **çŠ¶æ€ç®¡ç†**ï¼šå®ç°ç¼–è¾‘å™¨çŠ¶æ€å’Œé€‰ä¸­çŠ¶æ€
- **æ ·å¼é›†æˆ**ï¼šä¸shadcn/uiè®¾è®¡ç³»ç»Ÿä¿æŒä¸€è‡´

#### Refactoré˜¶æ®µï¼šä¼˜åŒ–æå‡
- **æ€§èƒ½ä¼˜åŒ–**ï¼šè™šæ‹ŸåŒ–ã€é˜²æŠ–ã€ç¼“å­˜æœºåˆ¶
- **ç”¨æˆ·ä½“éªŒ**ï¼šåŠ¨ç”»è¿‡æ¸¡ã€åŠ è½½çŠ¶æ€ã€é”™è¯¯å¤„ç†
- **ä»£ç è´¨é‡**ï¼šç»„ä»¶æ‹†åˆ†ã€å¤ç”¨æ€§ã€å¯æµ‹è¯•æ€§

### ä¾èµ–åŒ…é€‰æ‹©

```json
{
  "dependencies": {
    "react-flow": "^11.11.4",
    "zustand": "^4.4.6",
    "framer-motion": "^10.16.5",
    "monaco-editor": "^0.44.0",
    "@monaco-editor/react": "^4.6.0"
  }
}
```

### ä»£ç æ–‡ä»¶å½±å“

#### TDDæµ‹è¯•æ–‡ä»¶ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
- `src/components/flow NoteNode.test.tsx` - NoteNodeç»„ä»¶å®Œæ•´æµ‹è¯•
- `src/components/flow NoteEditorPanel.test.tsx` - ç¼–è¾‘å™¨é¢æ¿æµ‹è¯•
- `src/components/flow FlowCanvas.integration.test.tsx` - é›†æˆæµ‹è¯•
- `src/test/performance/flow.test.tsx` - æ€§èƒ½åŸºå‡†æµ‹è¯•
- `src/hooks useFlowNodes.test.ts` - Flowç›¸å…³hooksæµ‹è¯•

#### æ ¸å¿ƒå®ç°æ–‡ä»¶
- `src/components/flow/nodes/NoteNode.tsx` - ä¸»èŠ‚ç‚¹ç»„ä»¶
- `src/components/flow/NoteEditorPanel.tsx` - ç¼–è¾‘å™¨é¢æ¿ç»„ä»¶
- `src/components/flow/FlowCanvas.tsx` - æ‰©å±•ç”»å¸ƒç»„ä»¶
- `src/stores/useFlowStore.ts` - FlowçŠ¶æ€ç®¡ç†
- `src/hooks/useFlowNodes.ts` - Flowç›¸å…³hooks
- `src/services/flow/FlowService.ts` - FlowæœåŠ¡å±‚

## Dependencies

- [ ] **ä»»åŠ¡008ï¼šTDDåŸºç¡€è®¾æ–½**å®Œæˆï¼Œæµ‹è¯•æ¡†æ¶å°±ä½
- [ ] **ä»»åŠ¡001ï¼šæ•°æ®å±‚æ‰©å±•**å®Œæˆï¼Œschemaå°±ä½
- [ ] **ä»»åŠ¡002ï¼šMarkdownæ¸²æŸ“**å®Œæˆï¼Œæ¸²æŸ“ç»„ä»¶å¯ç”¨
- [ ] ç°æœ‰FlowCanvasç»„ä»¶æ­£å¸¸è¿è¡Œ

## Effort Estimate

- Size: Lï¼ˆåŒ…å«å¤§é‡æµ‹è¯•å’ŒUIç»„ä»¶å·¥ä½œï¼‰
- Days: 4å¤©
- Parallel: falseï¼ˆä¾èµ–å‰ç½®ä»»åŠ¡ï¼‰

### å·¥ä½œé‡åˆ†è§£
- **TDDæµ‹è¯•ç¼–å†™**ï¼š1.5å¤©ï¼ˆæœ€é‡è¦ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
- **åŠŸèƒ½å®ç°**ï¼š1.5å¤©ï¼ˆè®©æµ‹è¯•é€šè¿‡ï¼‰
- **é‡æ„ä¼˜åŒ–**ï¼š0.5å¤©ï¼ˆæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒï¼‰
- **é›†æˆéªŒè¯**ï¼š0.5å¤©ï¼ˆç«¯åˆ°ç«¯æµ‹è¯•ï¼‰

## Definition of Done

- [ ] **TDDæµç¨‹å®Œæ•´**ï¼šRed-Green-Refactorå¾ªç¯å®Œæ•´æ‰§è¡Œ
- [ ] **NoteNodeç»„ä»¶**ï¼šåŠŸèƒ½å®Œæ•´ï¼Œæµ‹è¯•è¦†ç›–ç‡â‰¥90%
- [ ] **ç¼–è¾‘å™¨é¢æ¿**ï¼šåˆ†å±ç¼–è¾‘ã€è‡ªåŠ¨ä¿å­˜åŠŸèƒ½å®Œæ•´
- [ ] **äº¤äº’ä½“éªŒ**ï¼šç‚¹å‡»ã€æ‹–æ‹½ã€é”®ç›˜æ“ä½œæµç•…
- [ ] **æ€§èƒ½è¾¾æ ‡**ï¼š100ä¸ªèŠ‚ç‚¹æ“ä½œæµç•…ï¼Œæ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] **æ•°æ®ç»‘å®š**ï¼šReact Flowä¸æ•°æ®åº“åŒå‘åŒæ­¥ç¨³å®š
- [ ] **ä»£ç è´¨é‡**ï¼šé€šè¿‡æ‰€æœ‰lintingå’Œç±»å‹æ£€æŸ¥
- [ ] **é›†æˆæµ‹è¯•**ï¼šä¸MarkdownRendererç­‰ç»„ä»¶é›†æˆæ— é—®é¢˜