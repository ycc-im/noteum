---
name: æ ‡ç­¾è§£æç³»ç»Ÿï¼š#tagè¯­æ³•è§£æå’Œéšå¼æ—¶é—´æ ‡ç­¾ï¼ˆTDDï¼‰
status: open
created: 2025-10-07T00:00:00Z
github: [å¾…åˆ›å»ºGitHub Issue]
depends_on: [008, 001, 002]
parallel: true
conflicts_with: []
---

# Task: æ ‡ç­¾è§£æç³»ç»Ÿï¼š#tagè¯­æ³•è§£æå’Œéšå¼æ—¶é—´æ ‡ç­¾ï¼ˆTDDï¼‰

## Description

**é‡‡ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰æ–¹æ³•**å®ç°#tagè¯­æ³•è§£æå™¨ï¼ŒåŒºåˆ«äºH1æ ‡é¢˜çš„#ï¼Œå¼€å‘éšå¼æ—¶é—´æ ‡ç­¾è‡ªåŠ¨ç”Ÿæˆæœºåˆ¶ï¼Œå®ç°æ ‡ç­¾çš„åˆ›å»ºã€å…³è”ã€æ˜¾ç¤ºåŠŸèƒ½ï¼Œæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰æ ‡ç­¾å’Œç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆçš„æ—¶é—´æ ‡ç­¾ã€‚

**TDDå¼€å‘æµç¨‹**ï¼šä¸¥æ ¼éµå¾ªRed-Green-Refactorå¾ªç¯ï¼Œå…ˆä¸ºæ¯ä¸ªæ ‡ç­¾åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½ï¼Œæœ€åä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

## Acceptance Criteria

### ğŸ”´ TDDé˜¶æ®µï¼šæµ‹è¯•å…ˆè¡Œï¼ˆRedï¼‰
- [ ] **ç¼–å†™æ ‡ç­¾è§£ææµ‹è¯•å¥—ä»¶**ï¼šå…ˆä¸ºæ‰€æœ‰æ ‡ç­¾åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•
- [ ] **#tagè¯­æ³•è§£ææµ‹è¯•**ï¼šä»å†…å®¹ä¸­å‡†ç¡®æå–æ ‡ç­¾ï¼ŒåŒºåˆ†H1æ ‡é¢˜çš„æµ‹è¯•
- [ ] **éšå¼æ—¶é—´æ ‡ç­¾æµ‹è¯•**ï¼šè‡ªåŠ¨ç”Ÿæˆæ—¶é—´æ ‡ç­¾çš„å„ç§åœºæ™¯æµ‹è¯•
- [ ] **æ ‡ç­¾å…³è”æµ‹è¯•**ï¼šæ ‡ç­¾ä¸ç¬”è®°å¤šå¯¹å¤šå…³ç³»çš„æµ‹è¯•
- [ ] **æ ‡ç­¾æ˜¾ç¤ºæµ‹è¯•**ï¼šæ ‡ç­¾ç»„ä»¶æ¸²æŸ“å’Œäº¤äº’çš„æµ‹è¯•
- [ ] **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡æ ‡ç­¾è§£æçš„æ€§èƒ½æµ‹è¯•
- [ ] **è¾¹ç•Œæ¡ä»¶æµ‹è¯•**ï¼šå¼‚å¸¸è¾“å…¥å’Œè¾¹ç•Œå€¼çš„æµ‹è¯•

### ğŸŸ¢ å®ç°é˜¶æ®µï¼šåŠŸèƒ½å®ç°ï¼ˆGreenï¼‰
- [ ] å®ç°#tagè¯­æ³•è§£æå™¨ï¼Œè®©TDDæµ‹è¯•é€šè¿‡
- [ ] åŒºåˆ†#tagå’ŒH1æ ‡é¢˜çš„#ï¼Œé¿å…è§£æå†²çª
- [ ] å¼€å‘éšå¼æ—¶é—´æ ‡ç­¾è‡ªåŠ¨ç”Ÿæˆæœºåˆ¶
- [ ] å®ç°æ ‡ç­¾çš„åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤åŠŸèƒ½
- [ ] å®ç°æ ‡ç­¾ä¸ç¬”è®°çš„å¤šå¯¹å¤šå…³è”å…³ç³»ç®¡ç†
- [ ] å¼€å‘æ ‡ç­¾æ˜¾ç¤ºç»„ä»¶ï¼Œæ”¯æŒé¢œè‰²ç¼–ç å’Œç±»å‹åŒºåˆ†
- [ ] å®ç°æ ‡ç­¾æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½

### ğŸ”„ é‡æ„é˜¶æ®µï¼šä»£ç ä¼˜åŒ–ï¼ˆRefactorï¼‰
- [ ] **ä¼˜åŒ–è§£ææ€§èƒ½**ï¼šåœ¨ä¿æŒæµ‹è¯•é€šè¿‡çš„å‰æä¸‹ä¼˜åŒ–å¤§é‡æ–‡æœ¬è§£æ
- [ ] **é‡æ„æ ‡ç­¾ç»„ä»¶**ï¼šæå‡æ ‡ç­¾ç»„ä»¶çš„å¯å¤ç”¨æ€§å’Œç”¨æˆ·ä½“éªŒ
- [ ] **ä¼˜åŒ–ç¼“å­˜æœºåˆ¶**ï¼šå‡å°‘é‡å¤è§£æå’Œæ•°æ®åº“æŸ¥è¯¢
- [ ] **TDDè´¨é‡éªŒè¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œæ‰€æœ‰æµ‹è¯•ç¨³å®šé€šè¿‡

## Technical Details

### TDDæµ‹è¯•è®¾è®¡

#### æ ‡ç­¾è§£æå™¨æµ‹è¯•
```typescript
/ src/services/tags TagParser.test.ts
describe('TagParser TDD', () => {
  describe('Explicit Tag Parsing', () => {
    it('should extract #work from content', () => {
      const content = 'This is about #work and productivity';
      const tags = TagParser.parseTags(content);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: 'work',
          type: 'user',
          source: 'explicit',
          position: { start: 15, end: 20 }
        })
      );
    });

    it('should not confuse #tag with H1 header', () => {
      const content = '# Header Title\nContent with #tag inside';
      const tags = TagParser.parseTags(content);

      expect(tags).not.toContainEqual(
        expect.objectContaining({
          name: 'Header Title',
          type: 'user'
        })
      );

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: 'tag',
          type: 'user'
        })
      );
    });

    it('should extract multiple tags correctly', () => {
      const content = '#work #urgent #meeting tomorrow';
      const tags = TagParser.parseTags(content);

      expect(tags).toHaveLength(3);
      expect(tags.map(t => t.name)).toEqual(['work', 'urgent', 'meeting']);
    });

    it('should handle Chinese characters in tags', () => {
      const content = 'è¿™æ˜¯ä¸€ä¸ªå…³äº#å·¥ä½œçš„ç¬”è®°';
      const tags = TagParser.parseTags(content);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: 'å·¥ä½œ',
          type: 'user'
        })
      );
    });

    it('should handle invalid tag patterns', () => {
      const content = 'This has #123numbers and #spec!al characters';
      const tags = TagParser.parseTags(content);

      / åªæœ‰æ•°å­—çš„æ ‡ç­¾åº”è¯¥è¢«è¿‡æ»¤
      expect(tags).not.toContainEqual(
        expect.objectContaining({
          name: '123numbers'
        })
      );
    });
  });

  describe('Tag Position Tracking', () => {
    it('should track tag positions correctly', () => {
      const content = 'Start #tag1 middle #tag2 end';
      const tags = TagParser.parseTags(content);

      const tag1 = tags.find(t => t.name === 'tag1');
      const tag2 = tags.find(t => t.name === 'tag2');

      expect(tag1.position).toEqual({ start: 6, end: 11 });
      expect(tag2.position).toEqual({ start: 18, end: 23 });
    });
  });
});
```

#### éšå¼æ—¶é—´æ ‡ç­¾æµ‹è¯•
```typescript
/ src/services/tags ImplicitTimeTagGenerator.test.ts
describe('ImplicitTimeTagGenerator TDD', () => {
  describe('Created Time Tags', () => {
    it('should generate date tags from creation date', () => {
      const createdAt = new Date('2025-01-15T10:30:00');
      const content = 'Some content without dates';

      const tags = ImplicitTimeTagGenerator.generateFromContent(content, createdAt);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '2025-01-15',
          type: 'implicit_time',
          source: 'implicit',
          metadata: expect.objectContaining({
            date: createdAt,
            confidence: 0.9
          })
        })
      );

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '2025-W3', / Week number
          type: 'implicit_time'
        })
      );

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '2025-01', / Month
          type: 'implicit_time'
        })
      );

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '2025-Q1', / Quarter
          type: 'implicit_time'
        })
      );
    });
  });

  describe('Content Date Extraction', () => {
    it('should extract dates from content', () => {
      const content = 'Meeting on 2025-02-20 at 14:30';
      const createdAt = new Date('2025-01-15');

      const tags = ImplicitTimeTagGenerator.generateFromContent(content, createdAt);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '2025-02-20',
          type: 'implicit_time',
          source: 'implicit',
          metadata: expect.objectContaining({
            date: new Date('2025-02-20'),
            confidence: 0.9
          })
        })
      );
    });

    it('should extract time information', () => {
      const content = 'Call at 15:30 about project';
      const createdAt = new Date('2025-01-15');

      const tags = ImplicitTimeTagGenerator.generateFromContent(content, createdAt);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: '15:30',
          type: 'implicit_time'
        })
      );
    });

    it('should extract weekday information', () => {
      const content = 'Meeting on Monday about the project';
      const createdAt = new Date('2025-01-15'); / Wednesday

      const tags = ImplicitTimeTagGenerator.generateFromContent(content, createdAt);

      expect(tags).toContainEqual(
        expect.objectContaining({
          name: 'Monday',
          type: 'implicit_time'
        })
      );
    });
  });

  describe('Date Validation', () => {
    it('should validate extracted dates correctly', () => {
      const invalidDates = [
        '2025-13-01', / Invalid month
        '2025-02-30', / Invalid day
        '9999-99-99'  / Completely invalid
      ];

      invalidDates.forEach(invalidDate => {
        const content = `Meeting on ${invalidDate}`;
        const tags = ImplicitTimeTagGenerator.generateFromContent(content, new Date());

        / ä¸åº”è¯¥åŒ…å«æ— æ•ˆæ—¥æœŸçš„æ ‡ç­¾
        const dateTag = tags.find(t => t.name === invalidDate);
        expect(dateTag).toBeUndefined();
      });
    });
  });
});
```

#### æ ‡ç­¾æœåŠ¡æµ‹è¯•
```typescript
/ src/services/tags TagService.test.ts
describe('TagService TDD', () => {
  let testDB: TestDatabase;
  let tagService: TagService;

  beforeEach(async () => {
    testDB = TestDatabase.getInstance();
    await testDB.reset();
    tagService = new TagService(testDB.getDB());
  });

  describe('Tag Creation and Association', () => {
    it('should create new tag if not exists', async () => {
      const tagData = {
        name: 'work',
        color: '#FF5722',
        type: 'user' as const
      };

      const tag = await tagService.createTag(tagData);

      expect(tag).toBeDefined();
      expect(tag.name).toBe('work');
      expect(tag.color).toBe('#FF5722');
    });

    it('should return existing tag if already exists', async () => {
      const tagData = {
        name: 'work',
        color: '#FF5722',
        type: 'user' as const
      };

      const tag1 = await tagService.createTag(tagData);
      const tag2 = await tagService.createTag(tagData);

      expect(tag1.id).toBe(tag2.id);
    });

    it('should associate note with tag correctly', async () => {
      const noteId = 'note-1';
      const tagId = 'tag-1';

      await tagService.associateNoteWithTag(noteId, tagId);

      const tags = await tagService.getTagsByNote(noteId);
      expect(tags).toHaveLength(1);
      expect(tags[0].id).toBe(tagId);
    });
  });

  describe('Tag Extraction and Processing', () => {
    it('should process tags from note content', async () => {
      const noteId = 'note-1';
      const content = 'Content about #work and #urgent tasks';
      const createdAt = new Date('2025-01-15');

      const processedTags = await tagService.processNoteTags(noteId, content, createdAt);

      expect(processedTags).toContainEqual(
        expect.objectContaining({ name: 'work' })
      );
      expect(processedTags).toContainEqual(
        expect.objectContaining({ name: 'urgent' })
      );
      expect(processedTags).toContainEqual(
        expect.objectContaining({ name: '2025-01-15' })
      );
    });
  });
});
```

#### æ ‡ç­¾ç»„ä»¶æµ‹è¯•
```typescript
/ src/components/tags Tag.test.tsx
describe('Tag Component TDD', () => {
  describe('Tag Rendering', () => {
    it('should render user tag with custom color', () => {
      const userTag = {
        id: 'tag-1',
        name: 'work',
        color: '#FF5722',
        type: 'user' as const,
        created_at: new Date()
      };

      const { getByText, container } = render(
        <Tag tag={userTag} />
      );

      expect(getByText('work')).toBeInTheDocument();
      expect(container.querySelector('.tag-user')).toBeInTheDocument();
      expect(container.querySelector('.tag')).toHaveStyle(
        `background-color: #FF5722`
      );
    });

    it('should render time tag with default styling', () => {
      const timeTag = {
        id: 'tag-2',
        name: '2025-01-15',
        color: '#2196F3',
        type: 'implicit_time' as const,
        created_at: new Date()
      };

      const { container } = render(
        <Tag tag={timeTag} />
      );

      expect(container.querySelector('.tag-time')).toBeInTheDocument();
      expect(container.querySelector('.tag-clock-icon')).toBeInTheDocument();
    });

    it('should show remove button when removable prop is true', () => {
      const tag = createMockTag();

      const { getByRole } = render(
        <Tag tag={tag} removable={true} onRemove={jest.fn()} />
      );

      const removeButton = getByRole('button', { name: /remove tag/i });
      expect(removeButton).toBeInTheDocument();
    });
  });

  describe('Tag Interactions', () => {
    it('should call onClick when tag is clicked', async () => {
      const mockOnClick = jest.fn();
      const tag = createMockTag();

      const { getByRole } = render(
        <Tag tag={tag} onClick={mockOnClick} />
      );

      const tagElement = getByRole('button', { name: /work/i });
      await userEvent.click(tagElement);

      expect(mockOnClick).toHaveBeenCalledWith(tag);
    });

    it('should call onRemove when remove button clicked', async () => {
      const mockOnRemove = jest.fn();
      const tag = createMockTag();

      const { getByRole } = render(
        <Tag tag={tag} removable={true} onRemove={mockOnRemove} />
      );

      const removeButton = getByRole('button', { name: /remove tag/i });
      await userEvent.click(removeButton);

      expect(mockOnRemove).toHaveBeenCalled();
    });
  });
});
```

#### æ€§èƒ½åŸºå‡†æµ‹è¯•
```typescript
/ src/test/performance/tagParsing.test.ts
describe('Tag Parsing Performance TDD', () => {
  it('should parse large content within performance threshold', async () => {
    const largeContent = generateLargeContentWithTags(50000); / 50kå­—ç¬¦

    const startTime = performance.now();

    const tags = TagParser.parseTags(largeContent);

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(100); / 100mså†…å®Œæˆ
    expect(tags.length).toBeGreaterThan(100); / è‡³å°‘è§£æå‡º100ä¸ªæ ‡ç­¾
  });

  it('should process multiple notes efficiently', async () => {
    const notes = Array.from({ length: 1000 }, (_, i) => ({
      id: `note-${i}`,
      content: `Note ${i} content with #tag${i % 10}`,
      created_at: new Date(2025, 0, (i % 30) + 1)
    }));

    const startTime = performance.now();

    const results = await Promise.all(
      notes.map(note => tagService.processNoteTags(
        note.id,
        note.content,
        note.created_at
      ))
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(2000); / 2ç§’å†…å®Œæˆ
    expect(results).toHaveLength(1000);
  });
});
```

### æ ‡ç­¾è§£æå™¨è®¾è®¡

#### TDDæ ¸å¿ƒæ¥å£
```typescript
/ src/services/tags/parser.ts
interface ParsedTag {
  name: string;
  type: 'user' | 'implicit_time' | 'system';
  source: 'explicit' | 'implicit';
  position: { start: number; end: number };
  metadata?: {
    date?: Date;
    confidence?: number;
  };
}

class TagParser {
  private static readonly TAG_REGEX = /(?<!^)#([a-zA-Z0-9_\u4e00-\u9fa5]+)/g;

  static parseTags(content: string): ParsedTag[] {
    / TDDå®ç°ï¼šè§£ææ˜¾å¼#tag
  }
}

/ src/services/tags/implicit.ts
class ImplicitTimeTagGenerator {
  static generateFromContent(content: string, createdAt: Date): ParsedTag[] {
    / TDDå®ç°ï¼šç”Ÿæˆéšå¼æ—¶é—´æ ‡ç­¾
  }
}

/ src/services/tags/service.ts
interface TagService {
  extractTags(content: string): Promise<ParsedTag[]>;
  createTag(tagData: CreateTagData): Promise<TagRecord>;
  associateNoteWithTag(noteId: string, tagId: string): Promise<void>;
  processNoteTags(noteId: string, content: string, createdAt: Date): Promise<ParsedTag[]>;
}
```

### TDDå®ç°è¦ç‚¹

#### Redé˜¶æ®µï¼šå¤±è´¥çš„æµ‹è¯•
- **è§£æå‡†ç¡®æ€§æµ‹è¯•**ï¼š#tagæå–ã€H1æ ‡é¢˜åŒºåˆ†ã€ä¸­æ–‡æ”¯æŒ
- **æ—¶é—´æ ‡ç­¾æµ‹è¯•**ï¼šåˆ›å»ºæ—¶é—´ã€å†…å®¹æ—¥æœŸã€æ—¶é—´æå–
- **å…³è”å…³ç³»æµ‹è¯•**ï¼šæ ‡ç­¾åˆ›å»ºã€å…³è”ã€æŸ¥è¯¢ã€åˆ é™¤
- **ç»„ä»¶æ¸²æŸ“æµ‹è¯•**ï¼šä¸åŒç±»å‹æ ‡ç­¾çš„æ ·å¼å’Œäº¤äº’
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡å†…å®¹è§£æã€æ‰¹é‡å¤„ç†æ€§èƒ½

#### Greené˜¶æ®µï¼šæœ€å°å®ç°
- **åŸºç¡€è§£æå™¨**ï¼šå®ç°æœ€ç®€æ­£åˆ™è¡¨è¾¾å¼è§£æ
- **æ—¶é—´æ ‡ç­¾ç”Ÿæˆ**ï¼šåŸºç¡€æ—¥æœŸå’Œæ—¶é—´æå–
- **æ•°æ®ç»‘å®š**ï¼šæ ‡ç­¾ä¸ç¬”è®°çš„å…³è”æ“ä½œ
- **ç»„ä»¶æ¸²æŸ“**ï¼šåŸºç¡€æ ‡ç­¾æ˜¾ç¤ºå’Œç‚¹å‡»åŠŸèƒ½

#### Refactoré˜¶æ®µï¼šä¼˜åŒ–æå‡
- **è§£ææ€§èƒ½**ï¼šä¼˜åŒ–æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¢åŠ ç¼“å­˜
- **ç”¨æˆ·ä½“éªŒ**ï¼šæ ‡ç­¾é¢œè‰²ã€å›¾æ ‡ã€åŠ¨ç”»æ•ˆæœ
- **ä»£ç è´¨é‡**ï¼šç»„ä»¶æ‹†åˆ†ã€ç±»å‹å®‰å…¨ã€é”™è¯¯å¤„ç†

### ä»£ç æ–‡ä»¶å½±å“

#### TDDæµ‹è¯•æ–‡ä»¶ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
- `src/services/tags TagParser.test.ts` - æ ‡ç­¾è§£æå™¨æµ‹è¯•
- `src/services/tags ImplicitTimeTagGenerator.test.ts` - éšå¼æ—¶é—´æ ‡ç­¾æµ‹è¯•
- `src/services/tags TagService.test.ts` - æ ‡ç­¾æœåŠ¡æµ‹è¯•
- `src/components/tags Tag.test.tsx` - æ ‡ç­¾ç»„ä»¶æµ‹è¯•
- `src/test/performance/tagParsing.test.ts` - æ€§èƒ½åŸºå‡†æµ‹è¯•

#### æ ¸å¿ƒå®ç°æ–‡ä»¶
- `src/services/tags/parser.ts` - æ ‡ç­¾è§£æå™¨å®ç°
- `src/services/tags/implicit.ts` - éšå¼æ—¶é—´æ ‡ç­¾ç”Ÿæˆ
- `src/services/tags/service.ts` - æ ‡ç­¾æœåŠ¡å±‚
- `src/components/tags/Tag.tsx` - æ ‡ç­¾æ˜¾ç¤ºç»„ä»¶
- `src/components/tags/TagManager.tsx` - æ ‡ç­¾ç®¡ç†ç»„ä»¶
- `src/hooks/useTags.ts` - æ ‡ç­¾ç›¸å…³hooks

## Dependencies

- [ ] **ä»»åŠ¡008ï¼šTDDåŸºç¡€è®¾æ–½**å®Œæˆï¼Œæµ‹è¯•æ¡†æ¶å°±ä½
- [ ] **ä»»åŠ¡001ï¼šæ•°æ®å±‚æ‰©å±•**å®Œæˆï¼Œschemaå°±ä½
- [ ] **ä»»åŠ¡002ï¼šMarkdownæ¸²æŸ“**å®Œæˆï¼Œå†…å®¹è§£æå¯ç”¨
- [ ] TypeScriptç±»å‹ç³»ç»Ÿå®Œæ•´
- [ ] æ­£åˆ™è¡¨è¾¾å¼å’Œæ–‡æœ¬å¤„ç†åº“

## Effort Estimate

- Size: Mï¼ˆåŒ…å«è¾ƒå¤šæµ‹è¯•å·¥ä½œï¼‰
- Days: 2-3å¤©
- Parallel: true

### å·¥ä½œé‡åˆ†è§£
- **TDDæµ‹è¯•ç¼–å†™**ï¼š1å¤©ï¼ˆæœ€é‡è¦ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
- **åŠŸèƒ½å®ç°**ï¼š1å¤©ï¼ˆè®©æµ‹è¯•é€šè¿‡ï¼‰
- **é‡æ„ä¼˜åŒ–**ï¼š0.5å¤©ï¼ˆæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒï¼‰
- **é›†æˆéªŒè¯**ï¼š0.5å¤©ï¼ˆç«¯åˆ°ç«¯æµ‹è¯•ï¼‰

## Definition of Done

- [ ] **TDDæµç¨‹å®Œæ•´**ï¼šRed-Green-Refactorå¾ªç¯å®Œæ•´æ‰§è¡Œ
- [ ] **æ ‡ç­¾è§£æå™¨**ï¼š#tagè¯­æ³•è§£æå‡†ç¡®ç‡â‰¥95%
- [ ] **éšå¼æ—¶é—´æ ‡ç­¾**ï¼šè‡ªåŠ¨ç”Ÿæˆæœºåˆ¶å®Œæ•´å¯é 
- [ ] **æ ‡ç­¾å…³è”**ï¼šå¤šå¯¹å¤šå…³ç³»ç®¡ç†ç¨³å®š
- [ ] **æ ‡ç­¾ç»„ä»¶**ï¼šæ ·å¼ç¾è§‚ï¼Œäº¤äº’æµç•…
- [ ] **æ€§èƒ½è¾¾æ ‡**ï¼šå¤§é‡å†…å®¹è§£ææ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] **ä»£ç è´¨é‡**ï¼šæµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œé€šè¿‡æ‰€æœ‰æ£€æŸ¥
- [ ] **é›†æˆæµ‹è¯•**ï¼šä¸å…¶ä»–æ¨¡å—é›†æˆæ— é—®é¢˜