---
name: 视图引擎：Daily视图和Tag聚合视图
status: open
created: 2025-10-07T00:00:00Z
github: [待创建GitHub Issue]
depends_on: [003, 004]
parallel: false
conflicts_with: []
---

# Task: 视图引擎：Daily视图和Tag聚合视图

## Description

实现Daily视图（按日期时间线布局笔记），实现Tag聚合视图（按标签分组布局笔记），添加视图切换功能和流畅的动画效果，支持用户在不同视图间无缝切换并保持笔记位置状态。

## Acceptance Criteria

- [ ] 实现Daily视图，按日期时间线垂直或水平布局笔记
- [ ] 实现Tag聚合视图，按标签分组显示相关笔记
- [ ] 开发视图切换器组件，支持视图间平滑切换
- [ ] 实现视图状态持久化，记住用户的视图偏好
- [ ] 添加视图切换动画效果（淡入淡出、滑动等）
- [ ] 实现笔记在视图间的位置映射和转换
- [ ] 支持视图的缩放和滚动功能
- [ ] 实现视图特定的交互功能（拖拽、排序等）
- [ ] 添加视图快捷键支持
- [ ] 编写视图引擎的完整测试套件

## Technical Details

### 视图架构设计

#### 视图引擎核心
```typescript
interface ViewEngine {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;

  switchView(viewType: ViewType): Promise<void>;
  getViewConfig(viewType: ViewType): ViewConfig;
  updateViewConfig(viewType: ViewType, config: Partial<ViewConfig>): void;
  renderView(viewType: ViewType, notes: NoteRecord[]): React.ReactElement;
}

enum ViewType {
  DAILY = 'daily',
  TAGS = 'tags',
  TIMELINE = 'timeline'
}

interface ViewConfig {
  id: string;
  name: string;
  description: string;
  layout: 'vertical' | 'horizontal' | 'grid' | 'timeline';
  grouping?: 'date' | 'tag' | 'category';
  sorting: 'date' | 'title' | 'tag' | 'custom';
  animation: ViewAnimation;
  interactions: ViewInteractions;
}
```

#### Daily视图实现
```typescript
class DailyViewEngine {
  // 按日期分组笔记
  groupNotesByDate(notes: NoteRecord[]): DateGroupedNotes {
    return notes.reduce((groups, note) => {
      const date = this.normalizeDate(note.created_at);
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(note);
      return groups;
    }, {} as DateGroupedNotes);
  }

  // 计算笔记在时间线中的位置
  calculateTimelinePosition(note: NoteRecord, containerSize: Dimensions): Position {
    const dayStart = new Date(note.created_at);
    dayStart.setHours(0, 0, 0, 0);
    const dayEnd = new Date(dayStart);
    dayEnd.setDate(dayEnd.getDate() + 1);

    const dayProgress = (note.created_at.getTime() - dayStart.getTime()) /
                       (dayEnd.getTime() - dayStart.getTime());

    return {
      x: containerSize.width * 0.1,
      y: containerSize.height * dayProgress
    };
  }

  // 渲染Daily视图
  renderDailyView(notes: NoteRecord[], config: DailyViewConfig): React.ReactElement {
    const groupedNotes = this.groupNotesByDate(notes);

    return (
      <DailyViewContainer>
        {Object.entries(groupedNotes).map(([date, dayNotes]) => (
          <DaySection key={date} date={date}>
            <DayHeader>{formatDate(date)}</DayHeader>
            <TimelineContainer>
              {dayNotes.map(note => (
                <NoteNode
                  key={note.id}
                  note={note}
                  position={this.calculateTimelinePosition(note, containerSize)}
                  view="daily"
                />
              ))}
            </TimelineContainer>
          </DaySection>
        ))}
      </DailyViewContainer>
    );
  }
}
```

#### Tag聚合视图实现
```typescript
class TagsViewEngine {
  // 按标签分组笔记
  groupNotesByTags(notes: NoteRecord[], tags: TagRecord[]): TagGroupedNotes {
    const tagMap = new Map(tags.map(tag => [tag.id, tag]));
    const grouped: TagGroupedNotes = {};

    notes.forEach(note => {
      note.tags.forEach(tagId => {
        const tag = tagMap.get(tagId);
        if (tag) {
          if (!grouped[tagId]) {
            grouped[tagId] = {
              tag,
              notes: []
            };
          }
          grouped[tagId].notes.push(note);
        }
      });
    });

    return grouped;
  }

  // 计算标签组在视图中的布局
  calculateTagGroupLayout(groups: TagGroupedNotes[], containerSize: Dimensions): TagGroupLayout[] {
    const columns = Math.ceil(Math.sqrt(groups.length));
    const columnWidth = containerSize.width / columns;

    return groups.map((group, index) => {
      const row = Math.floor(index / columns);
      const col = index % columns;

      return {
        tagId: group.tag.id,
        bounds: {
          x: col * columnWidth,
          y: row * 200, // 固定高度
          width: columnWidth - 20,
          height: 180
        },
        notesLayout: this.calculateNotesInGroupLayout(group.notes, {
          width: columnWidth - 40,
          height: 140
        })
      };
    });
  }

  // 渲染Tag聚合视图
  renderTagsView(notes: NoteRecord[], tags: TagRecord[]): React.ReactElement {
    const groupedNotes = this.groupNotesByTags(notes, tags);
    const groups = Object.values(groupedNotes);
    const layout = this.calculateTagGroupLayout(groups, containerSize);

    return (
      <TagsViewContainer>
        {layout.map(groupLayout => (
          <TagGroup
            key={groupLayout.tagId}
            tag={groupedNotes[groupLayout.tagId].tag}
            bounds={groupLayout.bounds}
          >
            {groupLayout.notesLayout.map(noteLayout => (
              <NoteNode
                key={noteLayout.noteId}
                note={noteLayout.note}
                position={noteLayout.position}
                view="tags"
              />
            ))}
          </TagGroup>
        ))}
      </TagsViewContainer>
    );
  }
}
```

### 视图切换系统

#### 视图切换器
```typescript
interface ViewSwitcherProps {
  currentView: ViewType;
  availableViews: ViewType[];
  onViewChange: (viewType: ViewType) => void;
  animated?: boolean;
}

const ViewSwitcher: React.FC<ViewSwitcherProps> = ({
  currentView,
  availableViews,
  onViewChange,
  animated = true
}) => {
  const [isTransitioning, setIsTransitioning] = useState(false);

  const handleViewChange = async (newView: ViewType) => {
    if (newView === currentView || isTransitioning) return;

    setIsTransitioning(true);

    // 保存当前视图状态
    await saveViewState(currentView);

    // 切换视图
    onViewChange(newView);

    // 恢复目标视图状态
    await restoreViewState(newView);

    setTimeout(() => setIsTransitioning(false), 300);
  };

  return (
    <ViewSwitcherContainer>
      {availableViews.map(viewType => (
        <ViewButton
          key={viewType}
          active={currentView === viewType}
          disabled={isTransitioning}
          onClick={() => handleViewChange(viewType)}
        >
          <ViewIcon type={viewType} />
          <ViewLabel>{getViewDisplayName(viewType)}</ViewLabel>
        </ViewButton>
      ))}
    </ViewSwitcherContainer>
  );
};
```

#### 动画系统
```typescript
interface ViewAnimation {
  duration: number;
  easing: string;
  type: 'fade' | 'slide' | 'scale' | 'flip';
}

class ViewAnimator {
  static animateTransition(
    fromElement: HTMLElement,
    toElement: HTMLElement,
    animation: ViewAnimation
  ): Promise<void> {
    return new Promise(resolve => {
      // 设置初始状态
      fromElement.style.transition = `all ${animation.duration}ms ${animation.easing}`;
      toElement.style.transition = `all ${animation.duration}ms ${animation.easing}`;

      switch (animation.type) {
        case 'fade':
          this.fadeTransition(fromElement, toElement, resolve);
          break;
        case 'slide':
          this.slideTransition(fromElement, toElement, resolve);
          break;
        case 'scale':
          this.scaleTransition(fromElement, toElement, resolve);
          break;
        default:
          this.fadeTransition(fromElement, toElement, resolve);
      }
    });
  }

  private static fadeTransition(
    from: HTMLElement,
    to: HTMLElement,
    resolve: () => void
  ): void {
    from.style.opacity = '1';
    to.style.opacity = '0';
    to.style.display = 'block';

    requestAnimationFrame(() => {
      from.style.opacity = '0';
      to.style.opacity = '1';

      setTimeout(() => {
        from.style.display = 'none';
        resolve();
      }, 300);
    });
  }
}
```

### 状态持久化

#### 视图状态管理
```typescript
interface ViewState {
  viewType: ViewType;
  scrollPosition: { x: number; y: number };
  zoomLevel: number;
  filters: Record<string, any>;
  sortOrder: string;
  customSettings: Record<string, any>;
}

class ViewStateManager {
  private static readonly STORAGE_KEY = 'noteum_view_states';

  static async saveViewState(viewType: ViewType, state: Partial<ViewState>): Promise<void> {
    const allStates = await this.getAllViewStates();
    allStates[viewType] = { ...allStates[viewType], ...state };

    await localStorage.setItem(this.STORAGE_KEY, JSON.stringify(allStates));
  }

  static async getViewState(viewType: ViewType): Promise<ViewState | null> {
    const allStates = await this.getAllViewStates();
    return allStates[viewType] || null;
  }

  static async restoreViewState(viewType: ViewType): Promise<void> {
    const state = await this.getViewState(viewType);
    if (state) {
      // 恢复滚动位置
      window.scrollTo(state.scrollPosition.x, state.scrollPosition.y);

      // 恢复缩放级别
      // 恢复过滤器和排序
      // 恢复其他自定义设置
    }
  }
}
```

### 代码文件影响

- `src/views/engine/ViewEngine.ts` - 视图引擎核心
- `src/views/daily/DailyView.tsx` - Daily视图组件
- `src/views/tags/TagsView.tsx` - Tag聚合视图组件
- `src/components/view/ViewSwitcher.tsx` - 视图切换器
- `src/components/view/ViewAnimator.ts` - 视图动画系统
- `src/services/view/ViewStateManager.ts` - 视图状态管理
- `src/hooks/useView.ts` - 视图相关React hooks
- `src/types/views.ts` - 视图类型定义

## Dependencies

- [ ] 任务003：拖拽定位和视图管理完成
- [ ] 任务004：标签解析系统完成
- [ ] React动画库（framer-motion或react-spring）
- [ ] 现有的状态管理系统

## Effort Estimate

- Size: L
- Days: 3天
- Parallel: false

## Definition of Done

- [ ] Daily视图完整实现，支持时间线布局
- [ ] Tag聚合视图完整实现，支持标签分组
- [ ] 视图切换功能正常，动画流畅
- [ ] 视图状态持久化机制工作正常
- [ ] 所有视图交互功能（缩放、滚动、拖拽）正常
- [ ] 单元测试覆盖率达到85%以上
- [ ] 集成测试验证视图切换和状态管理
- [ ] 代码审查通过
- [ ] 用户文档更新完成