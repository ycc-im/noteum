---
name: è§†å›¾å¼•æ“ï¼šDailyè§†å›¾å’ŒTagèšåˆè§†å›¾ï¼ˆTDDï¼‰
status: open
created: 2025-10-07T00:00:00Z
github: https://github.com/ycc-im/noteum/issues/132
depends_on: [008, 003, 004]
parallel: false
conflicts_with: []
---

# Task: è§†å›¾å¼•æ“ï¼šDailyè§†å›¾å’ŒTagèšåˆè§†å›¾ï¼ˆTDDï¼‰

## Description

**é‡‡ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰æ–¹æ³•**å®ç°Dailyè§†å›¾ï¼ˆæŒ‰æ—¥æœŸæ—¶é—´çº¿å¸ƒå±€ç¬”è®°ï¼‰ï¼Œå®ç°Tagèšåˆè§†å›¾ï¼ˆæŒ‰æ ‡ç­¾åˆ†ç»„å¸ƒå±€ç¬”è®°ï¼‰ï¼Œæ·»åŠ è§†å›¾åˆ‡æ¢åŠŸèƒ½å’Œæµç•…çš„åŠ¨ç”»æ•ˆæœï¼Œæ”¯æŒç”¨æˆ·åœ¨ä¸åŒè§†å›¾é—´æ— ç¼åˆ‡æ¢å¹¶ä¿æŒç¬”è®°ä½ç½®çŠ¶æ€ã€‚

**TDDå¼€å‘æµç¨‹**ï¼šä¸¥æ ¼éµå¾ªRed-Green-Refactorå¾ªç¯ï¼Œå…ˆä¸ºæ¯ä¸ªè§†å›¾åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½ï¼Œæœ€åä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

## Acceptance Criteria

### ğŸ”´ TDDé˜¶æ®µï¼šæµ‹è¯•å…ˆè¡Œï¼ˆRedï¼‰
- [ ] **ç¼–å†™è§†å›¾å¼•æ“æµ‹è¯•å¥—ä»¶**ï¼šå…ˆä¸ºæ‰€æœ‰è§†å›¾åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•
- [ ] **Dailyè§†å›¾æµ‹è¯•**ï¼šæ—¶é—´çº¿å¸ƒå±€ã€æ—¥æœŸåˆ†ç»„ã€ä½ç½®è®¡ç®—çš„æµ‹è¯•
- [ ] **Tagèšåˆè§†å›¾æµ‹è¯•**ï¼šæ ‡ç­¾åˆ†ç»„ã€å¸ƒå±€ç®—æ³•ã€ç¬”è®°èšåˆçš„æµ‹è¯•
- [ ] **è§†å›¾åˆ‡æ¢æµ‹è¯•**ï¼šè§†å›¾åˆ‡æ¢åŠ¨ç”»ã€çŠ¶æ€æŒä¹…åŒ–çš„æµ‹è¯•
- [ ] **ä½ç½®æ˜ å°„æµ‹è¯•**ï¼šç¬”è®°åœ¨ä¸åŒè§†å›¾é—´ä½ç½®è½¬æ¢çš„æµ‹è¯•
- [ ] **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡ç¬”è®°åœ¨ä¸åŒè§†å›¾ä¸­çš„æ¸²æŸ“æ€§èƒ½
- [ ] **è¾¹ç•Œæ¡ä»¶æµ‹è¯•**ï¼šç©ºè§†å›¾ã€æ— æ•ˆæ•°æ®ã€å¼‚å¸¸æƒ…å†µçš„å¤„ç†

### ğŸŸ¢ å®ç°é˜¶æ®µï¼šåŠŸèƒ½å®ç°ï¼ˆGreenï¼‰
- [ ] å®ç°Dailyè§†å›¾ï¼ŒæŒ‰æ—¥æœŸæ—¶é—´çº¿å‚ç›´æˆ–æ°´å¹³å¸ƒå±€ç¬”è®°ï¼Œè®©TDDæµ‹è¯•é€šè¿‡
- [ ] å®ç°Tagèšåˆè§†å›¾ï¼ŒæŒ‰æ ‡ç­¾åˆ†ç»„æ˜¾ç¤ºç›¸å…³ç¬”è®°
- [ ] å¼€å‘è§†å›¾åˆ‡æ¢å™¨ç»„ä»¶ï¼Œæ”¯æŒè§†å›¾é—´å¹³æ»‘åˆ‡æ¢
- [ ] å®ç°è§†å›¾çŠ¶æ€æŒä¹…åŒ–ï¼Œè®°ä½ç”¨æˆ·çš„è§†å›¾åå¥½
- [ ] æ·»åŠ è§†å›¾åˆ‡æ¢åŠ¨ç”»æ•ˆæœï¼ˆæ·¡å…¥æ·¡å‡ºã€æ»‘åŠ¨ç­‰ï¼‰
- [ ] å®ç°ç¬”è®°åœ¨è§†å›¾é—´çš„ä½ç½®æ˜ å°„å’Œè½¬æ¢
- [ ] æ”¯æŒè§†å›¾çš„ç¼©æ”¾å’Œæ»šåŠ¨åŠŸèƒ½

### ğŸ”„ é‡æ„é˜¶æ®µï¼šä»£ç ä¼˜åŒ–ï¼ˆRefactorï¼‰
- [ ] **ä¼˜åŒ–è§†å›¾æ¸²æŸ“æ€§èƒ½**ï¼šåœ¨ä¿æŒæµ‹è¯•é€šè¿‡çš„å‰æä¸‹ä¼˜åŒ–å¤§é‡ç¬”è®°æ¸²æŸ“
- [ ] **é‡æ„å¸ƒå±€ç®—æ³•**ï¼šæå‡è§†å›¾å¸ƒå±€ç®—æ³•çš„æ•ˆç‡å’Œå‡†ç¡®æ€§
- [ ] **ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½**ï¼šå‡å°‘åŠ¨ç”»å¡é¡¿ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
- [ ] **TDDè´¨é‡éªŒè¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œæ‰€æœ‰æµ‹è¯•ç¨³å®šé€šè¿‡

## Technical Details

### TDDæµ‹è¯•è®¾è®¡

#### è§†å›¾å¼•æ“æ ¸å¿ƒæµ‹è¯•
```typescript
/ src/views/engine ViewEngine.test.ts
describe('ViewEngine TDD', () => {
  let viewEngine: ViewEngine;
  let mockNotes: NoteRecord[];

  beforeEach(() => {
    viewEngine = new ViewEngine();
    mockNotes = createMockNotesWithDates();
  });

  describe('View Registration', () => {
    it('should register and retrieve view configs', () => {
      const dailyConfig: ViewConfig = {
        id: 'daily',
        name: 'Daily View',
        layout: 'timeline',
        grouping: 'date',
        sorting: 'date',
        animation: { duration: 300, easing: 'ease', type: 'fade' },
        interactions: { dragEnabled: true, zoomEnabled: true }
      };

      viewEngine.registerView('daily', dailyConfig);
      const retrievedConfig = viewEngine.getViewConfig('daily');

      expect(retrievedConfig).toEqual(dailyConfig);
    });

    it('should throw error for unregistered view', () => {
      expect(() => {
        viewEngine.getViewConfig('nonexistent');
      }).toThrow('View config not found: nonexistent');
    });
  });

  describe('View Switching', () => {
    it('should switch views and trigger callbacks', async () => {
      const mockCallback = jest.fn();
      viewEngine.onViewChange(mockCallback);

      await viewEngine.switchView('daily');

      expect(viewEngine.currentView).toBe('daily');
      expect(mockCallback).toHaveBeenCalledWith('daily', 'previous');
    });

    it('should not switch if view already active', async () => {
      viewEngine.currentView = 'daily';

      await viewEngine.switchView('daily');

      expect(viewEngine.currentView).toBe('daily');
    });
  });
});
```

#### Dailyè§†å›¾æµ‹è¯•
```typescript
/ src/views/daily DailyView.test.tsx
describe('DailyView TDD', () => {
  describe('Date Grouping', () => {
    it('should group notes by creation date correctly', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T10:00:00'), id: 'note-1' }),
        createMockNote({ created_at: new Date('2025-01-15T15:00:00'), id: 'note-2' }),
        createMockNote({ created_at: new Date('2025-01-16T09:00:00'), id: 'note-3' })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(Object.keys(grouped)).toHaveLength(2);
      expect(grouped['2025-01-15']).toHaveLength(2);
      expect(grouped['2025-01-16']).toHaveLength(1);
      expect(grouped['2025-01-15'].map(n => n.id)).toEqual(['note-1', 'note-2']);
    });

    it('should handle notes from same day but different times', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T00:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T23:59:59') })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(grouped['2025-01-15']).toHaveLength(2);
    });

    it('should sort notes within each day by time', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T15:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T10:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T20:00:00') })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(grouped['2025-01-15'][0].created_at.getHours()).toBe(10);
      expect(grouped['2025-01-15'][1].created_at.getHours()).toBe(15);
      expect(grouped['2025-01-15'][2].created_at.getHours()).toBe(20);
    });
  });

  describe('Timeline Position Calculation', () => {
    it('should calculate correct timeline positions', () => {
      const containerSize = { width: 800, height: 600 };
      const note = createMockNote({
        created_at: new Date('2025-01-15T12:00:00') / noon
      });

      const position = DailyViewEngine.calculateTimelinePosition(note, containerSize);

      expect(position.x).toBe(80); / 10% from left
      expect(position.y).toBe(300); / 50% from top (noon/midday)
    });

    it('should handle edge times correctly', () => {
      const containerSize = { width: 800, height: 600 };
      const morningNote = createMockNote({
        created_at: new Date('2025-01-15T00:00:00')
      });
      const nightNote = createMockNote({
        created_at: new Date('2025-01-15T23:59:59')
      });

      const morningPos = DailyViewEngine.calculateTimelinePosition(morningNote, containerSize);
      const nightPos = DailyViewEngine.calculateTimelinePosition(nightNote, containerSize);

      expect(morningPos.y).toBeCloseTo(0, 0);
      expect(nightPos.y).toBeCloseTo(600, 0);
    });
  });

  describe('Daily View Rendering', () => {
    it('should render daily view with correct structure', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T10:00:00') }),
        createMockNote({ created_at: new Date('2025-01-16T14:00:00') })
      ];

      const { getByText, getAllByTestId } = render(
        <DailyView notes={notes} />
      );

      expect(getByText('January 15, 2025')).toBeInTheDocument();
      expect(getByText('January 16, 2025')).toBeInTheDocument();
      expect(getAllByTestId('timeline-note')).toHaveLength(2);
    });

    it('should handle empty notes gracefully', () => {
      const { getByText } = render(
        <DailyView notes={[]} />
      );

      expect(getByText(/no notes for this period/i)).toBeInTheDocument();
    });
  });
});
```

#### Tagèšåˆè§†å›¾æµ‹è¯•
```typescript
/ src/views/tags TagsView.test.tsx
describe('TagsView TDD', () => {
  let mockNotes: NoteRecord[];
  let mockTags: TagRecord[];

  beforeEach(() => {
    mockNotes = [
      createMockNote({ id: 'note-1', tags: ['tag-1', 'tag-2'] }),
      createMockNote({ id: 'note-2', tags: ['tag-1'] }),
      createMockNote({ id: 'note-3', tags: ['tag-2', 'tag-3'] })
    ];

    mockTags = [
      createMockTag({ id: 'tag-1', name: 'work' }),
      createMockTag({ id: 'tag-2', name: 'urgent' }),
      createMockTag({ id: 'tag-3', name: 'personal' })
    ];
  });

  describe('Tag Grouping', () => {
    it('should group notes by tags correctly', () => {
      const grouped = TagsViewEngine.groupNotesByTags(mockNotes, mockTags);

      expect(Object.keys(grouped)).toHaveLength(3);
      expect(grouped['tag-1'].notes).toHaveLength(2);
      expect(grouped['tag-2'].notes).toHaveLength(2);
      expect(grouped['tag-3'].notes).toHaveLength(1);
    });

    it('should handle notes without tags', () => {
      const notesWithoutTags = [
        createMockNote({ id: 'note-4', tags: [] }),
        ...mockNotes
      ];

      const grouped = TagsViewEngine.groupNotesByTags(notesWithoutTags, mockTags);

      / Notes without tags should be in "untagged" group
      expect(grouped['untagged']).toBeDefined();
      expect(grouped['untagged'].notes).toHaveLength(1);
    });

    it('should handle duplicate tags correctly', () => {
      const noteWithDuplicateTags = createMockNote({
        id: 'note-4',
        tags: ['tag-1', 'tag-1'] / duplicate tag
      });

      const grouped = TagsViewEngine.groupNotesByTags(
        [...mockNotes, noteWithDuplicateTags],
        mockTags
      );

      / Should not duplicate the note in the group
      expect(grouped['tag-1'].notes).toHaveLength(2);
    });
  });

  describe('Tag Group Layout', () => {
    it('should calculate grid layout for tag groups', () => {
      const groups = Object.values(
        TagsViewEngine.groupNotesByTags(mockNotes, mockTags)
      );
      const containerSize = { width: 1200, height: 800 };

      const layout = TagsViewEngine.calculateTagGroupLayout(groups, containerSize);

      expect(layout).toHaveLength(3);
      / 3 groups should be arranged in 2x2 grid
      expect(layout[0].bounds.x).toBe(0);
      expect(layout[0].bounds.y).toBe(0);
      expect(layout[1].bounds.x).toBe(600); / second column
      expect(layout[1].bounds.y).toBe(0); / first row
      expect(layout[2].bounds.x).toBe(0); / first column
      expect(layout[2].bounds.y).toBe(200); / second row
    });

    it('should handle single group layout', () => {
      const singleGroup = [Object.values(
        TagsViewEngine.groupNotesByTags([mockNotes[0]], [mockTags[0]])
      )[0]];
      const containerSize = { width: 800, height: 600 };

      const layout = TagsViewEngine.calculateTagGroupLayout(singleGroup, containerSize);

      expect(layout).toHaveLength(1);
      expect(layout[0].bounds.width).toBe(780); / full width minus padding
      expect(layout[0].bounds.height).toBe(180); / fixed height
    });
  });

  describe('Tags View Rendering', () => {
    it('should render tags view with correct groups', () => {
      const { getByText, getAllByTestId } = render(
        <TagsView notes={mockNotes} tags={mockTags} />
      );

      expect(getByText('work')).toBeInTheDocument();
      expect(getByText('urgent')).toBeInTheDocument();
      expect(getByText('personal')).toBeInTheDocument();
      expect(getAllByTestId('tag-group')).toHaveLength(3);
      expect(getAllByTestId('tag-group-note')).toHaveLength(4); / total notes in all groups
    });

    it('should show note count in tag groups', () => {
      const { getByText } = render(
        <TagsView notes={mockNotes} tags={mockTags} />
      );

      expect(getByText('work (2)')).toBeInTheDocument();
      expect(getByText('urgent (2)')).toBeInTheDocument();
      expect(getByText('personal (1)')).toBeInTheDocument();
    });
  });
});
```

#### è§†å›¾åˆ‡æ¢æµ‹è¯•
```typescript
/ src/components/view ViewSwitcher.test.tsx
describe('ViewSwitcher TDD', () => {
  describe('View Switching Logic', () => {
    it('should switch views when button clicked', async () => {
      const mockOnViewChange = jest.fn();

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags', 'timeline']}
          onViewChange={mockOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      await userEvent.click(tagsButton);

      expect(mockOnViewChange).toHaveBeenCalledWith('tags');
    });

    it('should not trigger change when clicking active view', async () => {
      const mockOnViewChange = jest.fn();

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={mockOnViewChange}
        />
      );

      const dailyButton = getByRole('button', { name: /daily/i });
      await userEvent.click(dailyButton);

      expect(mockOnViewChange).not.toHaveBeenCalled();
    });

    it('should disable all buttons during transition', async () => {
      const mockOnViewChange = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={mockOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      const dailyButton = getByRole('button', { name: /daily/i });

      await userEvent.click(tagsButton);

      expect(tagsButton).toBeDisabled();
      expect(dailyButton).toBeDisabled();
    });
  });

  describe('Animation and Transition', () => {
    it('should apply transition class during view change', async () => {
      const { container, getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={jest.fn()}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });

      await userEvent.click(tagsButton);

      expect(container.querySelector('.transitioning')).toBeInTheDocument();
    });

    it('should show loading state during view switch', async () => {
      const slowOnViewChange = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={slowOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      await userEvent.click(tagsButton);

      expect(getByRole('button', { name: /loading/i })).toBeInTheDocument();
    });
  });
});
```

#### çŠ¶æ€æŒä¹…åŒ–æµ‹è¯•
```typescript
/ src/services/view ViewStateManager.test.ts
describe('ViewStateManager TDD', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('State Saving and Loading', () => {
    it('should save and load view state correctly', async () => {
      const viewState: Partial<ViewState> = {
        viewType: 'daily',
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5,
        filters: { tag: 'work' }
      };

      await ViewStateManager.saveViewState('daily', viewState);

      const loadedState = await ViewStateManager.getViewState('daily');

      expect(loadedState).toEqual(
        expect.objectContaining({
          viewType: 'daily',
          scrollPosition: { x: 100, y: 200 },
          zoomLevel: 1.5,
          filters: { tag: 'work' }
        })
      );
    });

    it('should return null for non-existent view state', async () => {
      const state = await ViewStateManager.getViewState('nonexistent');

      expect(state).toBeNull();
    });

    it('should merge partial updates correctly', async () => {
      / Save initial state
      await ViewStateManager.saveViewState('daily', {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.0
      });

      / Update partial state
      await ViewStateManager.saveViewState('daily', {
        zoomLevel: 1.5,
        filters: { tag: 'work' }
      });

      const finalState = await ViewStateManager.getViewState('daily');

      expect(finalState).toEqual(
        expect.objectContaining({
          scrollPosition: { x: 100, y: 200 }, / preserved
          zoomLevel: 1.5, / updated
          filters: { tag: 'work' } / added
        })
      );
    });
  });

  describe('State Restoration', () => {
    it('should restore scroll position on view activation', async () => {
      const mockScrollTo = jest.fn();
      Object.defineProperty(window, 'scrollTo', { value: mockScrollTo });

      const viewState: Partial<ViewState> = {
        scrollPosition: { x: 150, y: 250 }
      };

      await ViewStateManager.saveViewState('daily', viewState);
      await ViewStateManager.restoreViewState('daily');

      expect(mockScrollTo).toHaveBeenCalledWith(150, 250);
    });

    it('should handle missing state gracefully', async () => {
      const mockScrollTo = jest.fn();
      Object.defineProperty(window, 'scrollTo', { value: mockScrollTo });

      await ViewStateManager.restoreViewState('nonexistent');

      expect(mockScrollTo).not.toHaveBeenCalled();
    });
  });
});
```

#### æ€§èƒ½åŸºå‡†æµ‹è¯•
```typescript
/ src/test/performance/viewRendering.test.tsx
describe('View Rendering Performance TDD', () => {
  it('should render daily view with 1000 notes within threshold', async () => {
    const largeNotes = Array.from({ length: 1000 }, (_, i) =>
      createMockNote({
        id: `note-${i}`,
        created_at: new Date(2025, 0, (i % 30) + 1, (i % 24), (i % 60))
      })
    );

    const startTime = performance.now();

    const { container } = render(
      <DailyView notes={largeNotes} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(1000); / 1ç§’å†…å®Œæˆ
    expect(container.querySelectorAll('[data-testid="timeline-note"]').length).toBe(1000);
  });

  it('should render tags view with 500 notes and 50 tags efficiently', async () => {
    const notes = Array.from({ length: 500 }, (_, i) =>
      createMockNote({
        id: `note-${i}`,
        tags: [`tag-${i % 50}`] / 50ä¸ªä¸åŒçš„æ ‡ç­¾
      })
    );

    const tags = Array.from({ length: 50 }, (_, i) =>
      createMockTag({ id: `tag-${i}`, name: `Tag ${i}` })
    );

    const startTime = performance.now();

    const { container } = render(
      <TagsView notes={notes} tags={tags} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(800); / 800mså†…å®Œæˆ
    expect(container.querySelectorAll('[data-testid="tag-group"]').length).toBe(50);
  });

  it('should handle view switching within performance threshold', async () => {
    const notes = Array.from({ length: 200 }, (_, i) => createMockNote());
    const tags = Array.from({ length: 20 }, (_, i) => createMockTag());

    const startTime = performance.now();

    const { rerender } = render(
      <DailyView notes={notes} />
    );

    / Switch to tags view
    rerender(
      <TagsView notes={notes} tags={tags} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(500); / è§†å›¾åˆ‡æ¢<500ms
  });
});
```

### è§†å›¾å¼•æ“æ¶æ„è®¾è®¡

#### TDDæ ¸å¿ƒæ¥å£
```typescript
/ src/types/views.ts
interface ViewConfig {
  id: string;
  name: string;
  layout: 'vertical' | 'horizontal' | 'grid' | 'timeline';
  grouping?: 'date' | 'tag' | 'category';
  sorting: 'date' | 'title' | 'tag' | 'custom';
  animation: ViewAnimation;
  interactions: ViewInteractions;
}

interface ViewState {
  viewType: ViewType;
  scrollPosition: { x: number; y: number };
  zoomLevel: number;
  filters: Record<string, any>;
  sortOrder: string;
}

/ src/views/engine/ViewEngine.ts
class ViewEngine {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;

  registerView(viewType: ViewType, config: ViewConfig): void;
  switchView(viewType: ViewType): Promise<void>;
  getViewConfig(viewType: ViewType): ViewConfig;
  renderView(viewType: ViewType, notes: NoteRecord[]): React.ReactElement;
}

/ src/views/daily/DailyViewEngine.ts
class DailyViewEngine {
  static groupNotesByDate(notes: NoteRecord[]): DateGroupedNotes;
  static calculateTimelinePosition(note: NoteRecord, containerSize: Dimensions): Position;
  static renderDailyView(notes: NoteRecord[], config: DailyViewConfig): React.ReactElement;
}

/ src/views/tags/TagsViewEngine.ts
class TagsViewEngine {
  static groupNotesByTags(notes: NoteRecord[], tags: TagRecord[]): TagGroupedNotes;
  static calculateTagGroupLayout(groups: TagGroupedNotes[], containerSize: Dimensions): TagGroupLayout[];
  static renderTagsView(notes: NoteRecord[], tags: TagRecord[]): React.ReactElement;
}
```

### TDDå®ç°è¦ç‚¹

#### Redé˜¶æ®µï¼šå¤±è´¥çš„æµ‹è¯•
- **è§†å›¾åŠŸèƒ½æµ‹è¯•**ï¼šæ—¥æœŸåˆ†ç»„ã€æ ‡ç­¾åˆ†ç»„ã€å¸ƒå±€ç®—æ³•
- **è§†å›¾åˆ‡æ¢æµ‹è¯•**ï¼šåˆ‡æ¢é€»è¾‘ã€åŠ¨ç”»æ•ˆæœã€çŠ¶æ€æŒä¹…åŒ–
- **ä½ç½®è®¡ç®—æµ‹è¯•**ï¼šæ—¶é—´çº¿ä½ç½®ã€ç½‘æ ¼å¸ƒå±€ã€å“åº”å¼é€‚é…
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡ç¬”è®°æ¸²æŸ“ã€è§†å›¾åˆ‡æ¢æ€§èƒ½
- **è¾¹ç•Œæ¡ä»¶æµ‹è¯•**ï¼šç©ºæ•°æ®ã€å¼‚å¸¸è¾“å…¥ã€é”™è¯¯å¤„ç†

#### Greené˜¶æ®µï¼šæœ€å°å®ç°
- **åŸºç¡€è§†å›¾å¼•æ“**ï¼šè§†å›¾æ³¨å†Œã€åˆ‡æ¢ã€é…ç½®ç®¡ç†
- **Dailyè§†å›¾å®ç°**ï¼šæ—¶é—´çº¿å¸ƒå±€ã€æ—¥æœŸåˆ†ç»„ã€ä½ç½®è®¡ç®—
- **Tagè§†å›¾å®ç°**ï¼šæ ‡ç­¾åˆ†ç»„ã€ç½‘æ ¼å¸ƒå±€ã€ç¬”è®°èšåˆ
- **çŠ¶æ€ç®¡ç†**ï¼šè§†å›¾çŠ¶æ€ä¿å­˜ã€æ¢å¤ã€æŒä¹…åŒ–

#### Refactoré˜¶æ®µï¼šä¼˜åŒ–æå‡
- **æ¸²æŸ“æ€§èƒ½**ï¼šè™šæ‹ŸåŒ–ã€æ‡’åŠ è½½ã€å¢é‡æ›´æ–°
- **å¸ƒå±€ç®—æ³•**ï¼šä¼˜åŒ–ç©ºé—´åˆ©ç”¨ã€å‡å°‘é‡å 
- **åŠ¨ç”»ä¼˜åŒ–**ï¼šå‡å°‘é‡ç»˜ã€æå‡æµç•…åº¦
- **ä»£ç è´¨é‡**ï¼šç»„ä»¶æ‹†åˆ†ã€å¤ç”¨æ€§ã€å¯æµ‹è¯•æ€§

### ä»£ç æ–‡ä»¶å½±å“

#### TDDæµ‹è¯•æ–‡ä»¶ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
- `src/views/engine ViewEngine.test.ts` - è§†å›¾å¼•æ“æ ¸å¿ƒæµ‹è¯•
- `src/views/daily DailyView.test.tsx` - Dailyè§†å›¾æµ‹è¯•
- `src/views/tags TagsView.test.tsx` - Tagèšåˆè§†å›¾æµ‹è¯•
- `src/components/view ViewSwitcher.test.tsx` - è§†å›¾åˆ‡æ¢å™¨æµ‹è¯•
- `src/services/view ViewStateManager.test.ts` - è§†å›¾çŠ¶æ€ç®¡ç†æµ‹è¯•
- `src/test/performance/viewRendering.test.tsx` - æ€§èƒ½åŸºå‡†æµ‹è¯•

#### æ ¸å¿ƒå®ç°æ–‡ä»¶
- `src/views/engine/ViewEngine.ts` - è§†å›¾å¼•æ“æ ¸å¿ƒ
- `src/views/daily/DailyViewEngine.ts` - Dailyè§†å›¾å¼•æ“
- `src/views/daily/DailyView.tsx` - Dailyè§†å›¾ç»„ä»¶
- `src/views/tags/TagsViewEngine.ts` - Tagè§†å›¾å¼•æ“
- `src/views/tags/TagsView.tsx` - Tagèšåˆè§†å›¾ç»„ä»¶
- `src/components/view/ViewSwitcher.tsx` - è§†å›¾åˆ‡æ¢å™¨
- `src/services/view/ViewStateManager.ts` - è§†å›¾çŠ¶æ€ç®¡ç†

## Dependencies

- [ ] **ä»»åŠ¡008ï¼šTDDåŸºç¡€è®¾æ–½**å®Œæˆï¼Œæµ‹è¯•æ¡†æ¶å°±ä½
- [ ] **ä»»åŠ¡003ï¼šFlowèŠ‚ç‚¹å¼€å‘**å®Œæˆï¼ŒèŠ‚ç‚¹ç»„ä»¶å¯ç”¨
- [ ] **ä»»åŠ¡004ï¼šæ ‡ç­¾ç³»ç»Ÿ**å®Œæˆï¼Œæ ‡ç­¾è§£æå¯ç”¨
- [ ] ReactåŠ¨ç”»åº“ï¼ˆframer-motionï¼‰
- [ ] ç°æœ‰çŠ¶æ€ç®¡ç†ç³»ç»Ÿï¼ˆZustandï¼‰

## Effort Estimate

- Size: Lï¼ˆåŒ…å«å¤§é‡è§†å›¾ç®—æ³•å’Œæµ‹è¯•å·¥ä½œï¼‰
- Days: 3å¤©
- Parallel: falseï¼ˆä¾èµ–å‰ç½®ä»»åŠ¡ï¼‰

### å·¥ä½œé‡åˆ†è§£
- **TDDæµ‹è¯•ç¼–å†™**ï¼š1.2å¤©ï¼ˆæœ€é‡è¦ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
- **åŠŸèƒ½å®ç°**ï¼š1å¤©ï¼ˆè®©æµ‹è¯•é€šè¿‡ï¼‰
- **é‡æ„ä¼˜åŒ–**ï¼š0.5å¤©ï¼ˆæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒï¼‰
- **é›†æˆéªŒè¯**ï¼š0.3å¤©ï¼ˆç«¯åˆ°ç«¯æµ‹è¯•ï¼‰

## Definition of Done

- [ ] **TDDæµç¨‹å®Œæ•´**ï¼šRed-Green-Refactorå¾ªç¯å®Œæ•´æ‰§è¡Œ
- [ ] **Dailyè§†å›¾**ï¼šæ—¶é—´çº¿å¸ƒå±€ã€æ—¥æœŸåˆ†ç»„åŠŸèƒ½å®Œæ•´
- [ ] **Tagèšåˆè§†å›¾**ï¼šæ ‡ç­¾åˆ†ç»„ã€ç½‘æ ¼å¸ƒå±€åŠŸèƒ½å®Œæ•´
- [ ] **è§†å›¾åˆ‡æ¢**ï¼šåŠ¨ç”»æµç•…ï¼ŒçŠ¶æ€æŒä¹…åŒ–ç¨³å®š
- [ ] **æ€§èƒ½è¾¾æ ‡**ï¼šå¤§é‡ç¬”è®°æ¸²æŸ“æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] **ä»£ç è´¨é‡**ï¼šæµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œé€šè¿‡æ‰€æœ‰æ£€æŸ¥
- [ ] **é›†æˆæµ‹è¯•**ï¼šä¸FlowèŠ‚ç‚¹ã€æ ‡ç­¾ç³»ç»Ÿé›†æˆæ— é—®é¢˜