---
name: 视图引擎：Daily视图和Tag聚合视图（TDD）
status: open
created: 2025-10-07T00:00:00Z
github: https://github.com/ycc-im/noteum/issues/132
depends_on: [008, 003, 004]
parallel: false
conflicts_with: []
---

# Task: 视图引擎：Daily视图和Tag聚合视图（TDD）

## Description

**采用TDD（测试驱动开发）方法**实现Daily视图（按日期时间线布局笔记），实现Tag聚合视图（按标签分组布局笔记），添加视图切换功能和流畅的动画效果，支持用户在不同视图间无缝切换并保持笔记位置状态。

**TDD开发流程**：严格遵循Red-Green-Refactor循环，先为每个视图功能编写失败的测试，再实现功能，最后优化性能和用户体验。

## Acceptance Criteria

### 🔴 TDD阶段：测试先行（Red）
- [ ] **编写视图引擎测试套件**：先为所有视图功能编写失败的测试
- [ ] **Daily视图测试**：时间线布局、日期分组、位置计算的测试
- [ ] **Tag聚合视图测试**：标签分组、布局算法、笔记聚合的测试
- [ ] **视图切换测试**：视图切换动画、状态持久化的测试
- [ ] **位置映射测试**：笔记在不同视图间位置转换的测试
- [ ] **性能基准测试**：大量笔记在不同视图中的渲染性能
- [ ] **边界条件测试**：空视图、无效数据、异常情况的处理

### 🟢 实现阶段：功能实现（Green）
- [ ] 实现Daily视图，按日期时间线垂直或水平布局笔记，让TDD测试通过
- [ ] 实现Tag聚合视图，按标签分组显示相关笔记
- [ ] 开发视图切换器组件，支持视图间平滑切换
- [ ] 实现视图状态持久化，记住用户的视图偏好
- [ ] 添加视图切换动画效果（淡入淡出、滑动等）
- [ ] 实现笔记在视图间的位置映射和转换
- [ ] 支持视图的缩放和滚动功能

### 🔄 重构阶段：代码优化（Refactor）
- [ ] **优化视图渲染性能**：在保持测试通过的前提下优化大量笔记渲染
- [ ] **重构布局算法**：提升视图布局算法的效率和准确性
- [ ] **优化动画性能**：减少动画卡顿，提升用户体验
- [ ] **TDD质量验证**：确保测试覆盖率≥90%，所有测试稳定通过

## Technical Details

### TDD测试设计

#### 视图引擎核心测试
```typescript
/ src/views/engine ViewEngine.test.ts
describe('ViewEngine TDD', () => {
  let viewEngine: ViewEngine;
  let mockNotes: NoteRecord[];

  beforeEach(() => {
    viewEngine = new ViewEngine();
    mockNotes = createMockNotesWithDates();
  });

  describe('View Registration', () => {
    it('should register and retrieve view configs', () => {
      const dailyConfig: ViewConfig = {
        id: 'daily',
        name: 'Daily View',
        layout: 'timeline',
        grouping: 'date',
        sorting: 'date',
        animation: { duration: 300, easing: 'ease', type: 'fade' },
        interactions: { dragEnabled: true, zoomEnabled: true }
      };

      viewEngine.registerView('daily', dailyConfig);
      const retrievedConfig = viewEngine.getViewConfig('daily');

      expect(retrievedConfig).toEqual(dailyConfig);
    });

    it('should throw error for unregistered view', () => {
      expect(() => {
        viewEngine.getViewConfig('nonexistent');
      }).toThrow('View config not found: nonexistent');
    });
  });

  describe('View Switching', () => {
    it('should switch views and trigger callbacks', async () => {
      const mockCallback = jest.fn();
      viewEngine.onViewChange(mockCallback);

      await viewEngine.switchView('daily');

      expect(viewEngine.currentView).toBe('daily');
      expect(mockCallback).toHaveBeenCalledWith('daily', 'previous');
    });

    it('should not switch if view already active', async () => {
      viewEngine.currentView = 'daily';

      await viewEngine.switchView('daily');

      expect(viewEngine.currentView).toBe('daily');
    });
  });
});
```

#### Daily视图测试
```typescript
/ src/views/daily DailyView.test.tsx
describe('DailyView TDD', () => {
  describe('Date Grouping', () => {
    it('should group notes by creation date correctly', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T10:00:00'), id: 'note-1' }),
        createMockNote({ created_at: new Date('2025-01-15T15:00:00'), id: 'note-2' }),
        createMockNote({ created_at: new Date('2025-01-16T09:00:00'), id: 'note-3' })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(Object.keys(grouped)).toHaveLength(2);
      expect(grouped['2025-01-15']).toHaveLength(2);
      expect(grouped['2025-01-16']).toHaveLength(1);
      expect(grouped['2025-01-15'].map(n => n.id)).toEqual(['note-1', 'note-2']);
    });

    it('should handle notes from same day but different times', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T00:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T23:59:59') })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(grouped['2025-01-15']).toHaveLength(2);
    });

    it('should sort notes within each day by time', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T15:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T10:00:00') }),
        createMockNote({ created_at: new Date('2025-01-15T20:00:00') })
      ];

      const grouped = DailyViewEngine.groupNotesByDate(notes);

      expect(grouped['2025-01-15'][0].created_at.getHours()).toBe(10);
      expect(grouped['2025-01-15'][1].created_at.getHours()).toBe(15);
      expect(grouped['2025-01-15'][2].created_at.getHours()).toBe(20);
    });
  });

  describe('Timeline Position Calculation', () => {
    it('should calculate correct timeline positions', () => {
      const containerSize = { width: 800, height: 600 };
      const note = createMockNote({
        created_at: new Date('2025-01-15T12:00:00') / noon
      });

      const position = DailyViewEngine.calculateTimelinePosition(note, containerSize);

      expect(position.x).toBe(80); / 10% from left
      expect(position.y).toBe(300); / 50% from top (noon/midday)
    });

    it('should handle edge times correctly', () => {
      const containerSize = { width: 800, height: 600 };
      const morningNote = createMockNote({
        created_at: new Date('2025-01-15T00:00:00')
      });
      const nightNote = createMockNote({
        created_at: new Date('2025-01-15T23:59:59')
      });

      const morningPos = DailyViewEngine.calculateTimelinePosition(morningNote, containerSize);
      const nightPos = DailyViewEngine.calculateTimelinePosition(nightNote, containerSize);

      expect(morningPos.y).toBeCloseTo(0, 0);
      expect(nightPos.y).toBeCloseTo(600, 0);
    });
  });

  describe('Daily View Rendering', () => {
    it('should render daily view with correct structure', () => {
      const notes = [
        createMockNote({ created_at: new Date('2025-01-15T10:00:00') }),
        createMockNote({ created_at: new Date('2025-01-16T14:00:00') })
      ];

      const { getByText, getAllByTestId } = render(
        <DailyView notes={notes} />
      );

      expect(getByText('January 15, 2025')).toBeInTheDocument();
      expect(getByText('January 16, 2025')).toBeInTheDocument();
      expect(getAllByTestId('timeline-note')).toHaveLength(2);
    });

    it('should handle empty notes gracefully', () => {
      const { getByText } = render(
        <DailyView notes={[]} />
      );

      expect(getByText(/no notes for this period/i)).toBeInTheDocument();
    });
  });
});
```

#### Tag聚合视图测试
```typescript
/ src/views/tags TagsView.test.tsx
describe('TagsView TDD', () => {
  let mockNotes: NoteRecord[];
  let mockTags: TagRecord[];

  beforeEach(() => {
    mockNotes = [
      createMockNote({ id: 'note-1', tags: ['tag-1', 'tag-2'] }),
      createMockNote({ id: 'note-2', tags: ['tag-1'] }),
      createMockNote({ id: 'note-3', tags: ['tag-2', 'tag-3'] })
    ];

    mockTags = [
      createMockTag({ id: 'tag-1', name: 'work' }),
      createMockTag({ id: 'tag-2', name: 'urgent' }),
      createMockTag({ id: 'tag-3', name: 'personal' })
    ];
  });

  describe('Tag Grouping', () => {
    it('should group notes by tags correctly', () => {
      const grouped = TagsViewEngine.groupNotesByTags(mockNotes, mockTags);

      expect(Object.keys(grouped)).toHaveLength(3);
      expect(grouped['tag-1'].notes).toHaveLength(2);
      expect(grouped['tag-2'].notes).toHaveLength(2);
      expect(grouped['tag-3'].notes).toHaveLength(1);
    });

    it('should handle notes without tags', () => {
      const notesWithoutTags = [
        createMockNote({ id: 'note-4', tags: [] }),
        ...mockNotes
      ];

      const grouped = TagsViewEngine.groupNotesByTags(notesWithoutTags, mockTags);

      / Notes without tags should be in "untagged" group
      expect(grouped['untagged']).toBeDefined();
      expect(grouped['untagged'].notes).toHaveLength(1);
    });

    it('should handle duplicate tags correctly', () => {
      const noteWithDuplicateTags = createMockNote({
        id: 'note-4',
        tags: ['tag-1', 'tag-1'] / duplicate tag
      });

      const grouped = TagsViewEngine.groupNotesByTags(
        [...mockNotes, noteWithDuplicateTags],
        mockTags
      );

      / Should not duplicate the note in the group
      expect(grouped['tag-1'].notes).toHaveLength(2);
    });
  });

  describe('Tag Group Layout', () => {
    it('should calculate grid layout for tag groups', () => {
      const groups = Object.values(
        TagsViewEngine.groupNotesByTags(mockNotes, mockTags)
      );
      const containerSize = { width: 1200, height: 800 };

      const layout = TagsViewEngine.calculateTagGroupLayout(groups, containerSize);

      expect(layout).toHaveLength(3);
      / 3 groups should be arranged in 2x2 grid
      expect(layout[0].bounds.x).toBe(0);
      expect(layout[0].bounds.y).toBe(0);
      expect(layout[1].bounds.x).toBe(600); / second column
      expect(layout[1].bounds.y).toBe(0); / first row
      expect(layout[2].bounds.x).toBe(0); / first column
      expect(layout[2].bounds.y).toBe(200); / second row
    });

    it('should handle single group layout', () => {
      const singleGroup = [Object.values(
        TagsViewEngine.groupNotesByTags([mockNotes[0]], [mockTags[0]])
      )[0]];
      const containerSize = { width: 800, height: 600 };

      const layout = TagsViewEngine.calculateTagGroupLayout(singleGroup, containerSize);

      expect(layout).toHaveLength(1);
      expect(layout[0].bounds.width).toBe(780); / full width minus padding
      expect(layout[0].bounds.height).toBe(180); / fixed height
    });
  });

  describe('Tags View Rendering', () => {
    it('should render tags view with correct groups', () => {
      const { getByText, getAllByTestId } = render(
        <TagsView notes={mockNotes} tags={mockTags} />
      );

      expect(getByText('work')).toBeInTheDocument();
      expect(getByText('urgent')).toBeInTheDocument();
      expect(getByText('personal')).toBeInTheDocument();
      expect(getAllByTestId('tag-group')).toHaveLength(3);
      expect(getAllByTestId('tag-group-note')).toHaveLength(4); / total notes in all groups
    });

    it('should show note count in tag groups', () => {
      const { getByText } = render(
        <TagsView notes={mockNotes} tags={mockTags} />
      );

      expect(getByText('work (2)')).toBeInTheDocument();
      expect(getByText('urgent (2)')).toBeInTheDocument();
      expect(getByText('personal (1)')).toBeInTheDocument();
    });
  });
});
```

#### 视图切换测试
```typescript
/ src/components/view ViewSwitcher.test.tsx
describe('ViewSwitcher TDD', () => {
  describe('View Switching Logic', () => {
    it('should switch views when button clicked', async () => {
      const mockOnViewChange = jest.fn();

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags', 'timeline']}
          onViewChange={mockOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      await userEvent.click(tagsButton);

      expect(mockOnViewChange).toHaveBeenCalledWith('tags');
    });

    it('should not trigger change when clicking active view', async () => {
      const mockOnViewChange = jest.fn();

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={mockOnViewChange}
        />
      );

      const dailyButton = getByRole('button', { name: /daily/i });
      await userEvent.click(dailyButton);

      expect(mockOnViewChange).not.toHaveBeenCalled();
    });

    it('should disable all buttons during transition', async () => {
      const mockOnViewChange = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={mockOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      const dailyButton = getByRole('button', { name: /daily/i });

      await userEvent.click(tagsButton);

      expect(tagsButton).toBeDisabled();
      expect(dailyButton).toBeDisabled();
    });
  });

  describe('Animation and Transition', () => {
    it('should apply transition class during view change', async () => {
      const { container, getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={jest.fn()}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });

      await userEvent.click(tagsButton);

      expect(container.querySelector('.transitioning')).toBeInTheDocument();
    });

    it('should show loading state during view switch', async () => {
      const slowOnViewChange = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

      const { getByRole } = render(
        <ViewSwitcher
          currentView="daily"
          availableViews={['daily', 'tags']}
          onViewChange={slowOnViewChange}
        />
      );

      const tagsButton = getByRole('button', { name: /tags/i });
      await userEvent.click(tagsButton);

      expect(getByRole('button', { name: /loading/i })).toBeInTheDocument();
    });
  });
});
```

#### 状态持久化测试
```typescript
/ src/services/view ViewStateManager.test.ts
describe('ViewStateManager TDD', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('State Saving and Loading', () => {
    it('should save and load view state correctly', async () => {
      const viewState: Partial<ViewState> = {
        viewType: 'daily',
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5,
        filters: { tag: 'work' }
      };

      await ViewStateManager.saveViewState('daily', viewState);

      const loadedState = await ViewStateManager.getViewState('daily');

      expect(loadedState).toEqual(
        expect.objectContaining({
          viewType: 'daily',
          scrollPosition: { x: 100, y: 200 },
          zoomLevel: 1.5,
          filters: { tag: 'work' }
        })
      );
    });

    it('should return null for non-existent view state', async () => {
      const state = await ViewStateManager.getViewState('nonexistent');

      expect(state).toBeNull();
    });

    it('should merge partial updates correctly', async () => {
      / Save initial state
      await ViewStateManager.saveViewState('daily', {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.0
      });

      / Update partial state
      await ViewStateManager.saveViewState('daily', {
        zoomLevel: 1.5,
        filters: { tag: 'work' }
      });

      const finalState = await ViewStateManager.getViewState('daily');

      expect(finalState).toEqual(
        expect.objectContaining({
          scrollPosition: { x: 100, y: 200 }, / preserved
          zoomLevel: 1.5, / updated
          filters: { tag: 'work' } / added
        })
      );
    });
  });

  describe('State Restoration', () => {
    it('should restore scroll position on view activation', async () => {
      const mockScrollTo = jest.fn();
      Object.defineProperty(window, 'scrollTo', { value: mockScrollTo });

      const viewState: Partial<ViewState> = {
        scrollPosition: { x: 150, y: 250 }
      };

      await ViewStateManager.saveViewState('daily', viewState);
      await ViewStateManager.restoreViewState('daily');

      expect(mockScrollTo).toHaveBeenCalledWith(150, 250);
    });

    it('should handle missing state gracefully', async () => {
      const mockScrollTo = jest.fn();
      Object.defineProperty(window, 'scrollTo', { value: mockScrollTo });

      await ViewStateManager.restoreViewState('nonexistent');

      expect(mockScrollTo).not.toHaveBeenCalled();
    });
  });
});
```

#### 性能基准测试
```typescript
/ src/test/performance/viewRendering.test.tsx
describe('View Rendering Performance TDD', () => {
  it('should render daily view with 1000 notes within threshold', async () => {
    const largeNotes = Array.from({ length: 1000 }, (_, i) =>
      createMockNote({
        id: `note-${i}`,
        created_at: new Date(2025, 0, (i % 30) + 1, (i % 24), (i % 60))
      })
    );

    const startTime = performance.now();

    const { container } = render(
      <DailyView notes={largeNotes} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(1000); / 1秒内完成
    expect(container.querySelectorAll('[data-testid="timeline-note"]').length).toBe(1000);
  });

  it('should render tags view with 500 notes and 50 tags efficiently', async () => {
    const notes = Array.from({ length: 500 }, (_, i) =>
      createMockNote({
        id: `note-${i}`,
        tags: [`tag-${i % 50}`] / 50个不同的标签
      })
    );

    const tags = Array.from({ length: 50 }, (_, i) =>
      createMockTag({ id: `tag-${i}`, name: `Tag ${i}` })
    );

    const startTime = performance.now();

    const { container } = render(
      <TagsView notes={notes} tags={tags} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(800); / 800ms内完成
    expect(container.querySelectorAll('[data-testid="tag-group"]').length).toBe(50);
  });

  it('should handle view switching within performance threshold', async () => {
    const notes = Array.from({ length: 200 }, (_, i) => createMockNote());
    const tags = Array.from({ length: 20 }, (_, i) => createMockTag());

    const startTime = performance.now();

    const { rerender } = render(
      <DailyView notes={notes} />
    );

    / Switch to tags view
    rerender(
      <TagsView notes={notes} tags={tags} />
    );

    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(500); / 视图切换<500ms
  });
});
```

### 视图引擎架构设计

#### TDD核心接口
```typescript
/ src/types/views.ts
interface ViewConfig {
  id: string;
  name: string;
  layout: 'vertical' | 'horizontal' | 'grid' | 'timeline';
  grouping?: 'date' | 'tag' | 'category';
  sorting: 'date' | 'title' | 'tag' | 'custom';
  animation: ViewAnimation;
  interactions: ViewInteractions;
}

interface ViewState {
  viewType: ViewType;
  scrollPosition: { x: number; y: number };
  zoomLevel: number;
  filters: Record<string, any>;
  sortOrder: string;
}

/ src/views/engine/ViewEngine.ts
class ViewEngine {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;

  registerView(viewType: ViewType, config: ViewConfig): void;
  switchView(viewType: ViewType): Promise<void>;
  getViewConfig(viewType: ViewType): ViewConfig;
  renderView(viewType: ViewType, notes: NoteRecord[]): React.ReactElement;
}

/ src/views/daily/DailyViewEngine.ts
class DailyViewEngine {
  static groupNotesByDate(notes: NoteRecord[]): DateGroupedNotes;
  static calculateTimelinePosition(note: NoteRecord, containerSize: Dimensions): Position;
  static renderDailyView(notes: NoteRecord[], config: DailyViewConfig): React.ReactElement;
}

/ src/views/tags/TagsViewEngine.ts
class TagsViewEngine {
  static groupNotesByTags(notes: NoteRecord[], tags: TagRecord[]): TagGroupedNotes;
  static calculateTagGroupLayout(groups: TagGroupedNotes[], containerSize: Dimensions): TagGroupLayout[];
  static renderTagsView(notes: NoteRecord[], tags: TagRecord[]): React.ReactElement;
}
```

### TDD实现要点

#### Red阶段：失败的测试
- **视图功能测试**：日期分组、标签分组、布局算法
- **视图切换测试**：切换逻辑、动画效果、状态持久化
- **位置计算测试**：时间线位置、网格布局、响应式适配
- **性能基准测试**：大量笔记渲染、视图切换性能
- **边界条件测试**：空数据、异常输入、错误处理

#### Green阶段：最小实现
- **基础视图引擎**：视图注册、切换、配置管理
- **Daily视图实现**：时间线布局、日期分组、位置计算
- **Tag视图实现**：标签分组、网格布局、笔记聚合
- **状态管理**：视图状态保存、恢复、持久化

#### Refactor阶段：优化提升
- **渲染性能**：虚拟化、懒加载、增量更新
- **布局算法**：优化空间利用、减少重叠
- **动画优化**：减少重绘、提升流畅度
- **代码质量**：组件拆分、复用性、可测试性

### 代码文件影响

#### TDD测试文件（优先级最高）
- `src/views/engine ViewEngine.test.ts` - 视图引擎核心测试
- `src/views/daily DailyView.test.tsx` - Daily视图测试
- `src/views/tags TagsView.test.tsx` - Tag聚合视图测试
- `src/components/view ViewSwitcher.test.tsx` - 视图切换器测试
- `src/services/view ViewStateManager.test.ts` - 视图状态管理测试
- `src/test/performance/viewRendering.test.tsx` - 性能基准测试

#### 核心实现文件
- `src/views/engine/ViewEngine.ts` - 视图引擎核心
- `src/views/daily/DailyViewEngine.ts` - Daily视图引擎
- `src/views/daily/DailyView.tsx` - Daily视图组件
- `src/views/tags/TagsViewEngine.ts` - Tag视图引擎
- `src/views/tags/TagsView.tsx` - Tag聚合视图组件
- `src/components/view/ViewSwitcher.tsx` - 视图切换器
- `src/services/view/ViewStateManager.ts` - 视图状态管理

## Dependencies

- [ ] **任务008：TDD基础设施**完成，测试框架就位
- [ ] **任务003：Flow节点开发**完成，节点组件可用
- [ ] **任务004：标签系统**完成，标签解析可用
- [ ] React动画库（framer-motion）
- [ ] 现有状态管理系统（Zustand）

## Effort Estimate

- Size: L（包含大量视图算法和测试工作）
- Days: 3天
- Parallel: false（依赖前置任务）

### 工作量分解
- **TDD测试编写**：1.2天（最重要，优先级最高）
- **功能实现**：1天（让测试通过）
- **重构优化**：0.5天（性能和用户体验）
- **集成验证**：0.3天（端到端测试）

## Definition of Done

- [ ] **TDD流程完整**：Red-Green-Refactor循环完整执行
- [ ] **Daily视图**：时间线布局、日期分组功能完整
- [ ] **Tag聚合视图**：标签分组、网格布局功能完整
- [ ] **视图切换**：动画流畅，状态持久化稳定
- [ ] **性能达标**：大量笔记渲染性能测试通过
- [ ] **代码质量**：测试覆盖率≥90%，通过所有检查
- [ ] **集成测试**：与Flow节点、标签系统集成无问题