---
name: çŠ¶æ€ç®¡ç†ï¼šZustandç»Ÿä¸€çŠ¶æ€ç®¡ç†
status: open
created: 2025-10-07T00:00:00Z
github: [å¾…åˆ›å»ºGitHub Issue]
depends_on: [003]
parallel: true
conflicts_with: []
---

# Task: çŠ¶æ€ç®¡ç†ï¼šZustandç»Ÿä¸€çŠ¶æ€ç®¡ç†

## Description

é…ç½®ZustandçŠ¶æ€ç®¡ç†åº“ï¼Œå®ç°FlowçŠ¶æ€ã€ç¬”è®°çŠ¶æ€ã€è§†å›¾çŠ¶æ€çš„ç»Ÿä¸€ç®¡ç†ï¼Œå»ºç«‹é«˜æ•ˆçš„çŠ¶æ€åŒæ­¥æœºåˆ¶ï¼Œæ”¯æŒç»„ä»¶é—´çš„çŠ¶æ€å…±äº«å’Œå®æ—¶æ›´æ–°ï¼Œç¡®ä¿åº”ç”¨çŠ¶æ€çš„ä¸€è‡´æ€§å’Œå¯é¢„æµ‹æ€§ã€‚

## Acceptance Criteria

- [ ] é…ç½®ZustandçŠ¶æ€ç®¡ç†åº“ï¼Œé›†æˆåˆ°ç°æœ‰Reactåº”ç”¨ä¸­
- [ ] å®ç°FlowçŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬å·¥ä½œæµçŠ¶æ€ã€èŠ‚ç‚¹ä½ç½®ã€è¿æ¥å…³ç³»
- [ ] å®ç°ç¬”è®°çŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬CRUDæ“ä½œã€é€‰ä¸­çŠ¶æ€ã€ç¼–è¾‘çŠ¶æ€
- [ ] å®ç°è§†å›¾çŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬å½“å‰è§†å›¾ã€è§†å›¾é…ç½®ã€UIçŠ¶æ€
- [ ] å»ºç«‹çŠ¶æ€é—´çš„ä¾èµ–å…³ç³»å’ŒåŒæ­¥æœºåˆ¶
- [ ] å®ç°çŠ¶æ€æŒä¹…åŒ–ï¼Œæ”¯æŒæœ¬åœ°å­˜å‚¨å’Œäº‘ç«¯åŒæ­¥
- [ ] æ·»åŠ çŠ¶æ€è°ƒè¯•å·¥å…·å’Œå¼€å‘æ—¶çŠ¶æ€æ£€æŸ¥
- [ ] å®ç°çŠ¶æ€å˜æ›´çš„æ€§èƒ½ä¼˜åŒ–ï¼ˆé˜²æŠ–ã€æ‰¹é‡æ›´æ–°ï¼‰
- [ ] ç¼–å†™çŠ¶æ€ç®¡ç†çš„å®Œæ•´æµ‹è¯•å¥—ä»¶
- [ ] å»ºç«‹çŠ¶æ€ç®¡ç†çš„æœ€ä½³å®è·µæ–‡æ¡£

## Technical Details

### Zustandæ¶æ„è®¾è®¡

#### çŠ¶æ€ç»“æ„è®¾è®¡
```typescript
// ä¸»çŠ¶æ€æ¥å£
interface AppState {
  // Flowç›¸å…³çŠ¶æ€
  flow: FlowState;

  // ç¬”è®°ç›¸å…³çŠ¶æ€
  notes: NotesState;

  // è§†å›¾ç›¸å…³çŠ¶æ€
  view: ViewState;

  // UIç›¸å…³çŠ¶æ€
  ui: UIState;

  // ç”¨æˆ·ç›¸å…³çŠ¶æ€
  user: UserState;
}

// FlowçŠ¶æ€
interface FlowState {
  nodes: FlowNode[];
  edges: FlowEdge[];
  selectedNodes: string[];
  selectedEdges: string[];
  viewport: ViewportState;
  isDragging: boolean;
  isConnecting: boolean;
  connectionSource: string | null;

  // Actions
  addNode: (node: FlowNode) => void;
  removeNode: (nodeId: string) => void;
  updateNode: (nodeId: string, updates: Partial<FlowNode>) => void;
  addEdge: (edge: FlowEdge) => void;
  removeEdge: (edgeId: string) => void;
  selectNodes: (nodeIds: string[]) => void;
  clearSelection: () => void;
  setViewport: (viewport: Partial<ViewportState>) => void;
}

// ç¬”è®°çŠ¶æ€
interface NotesState {
  notes: Record<string, NoteRecord>;
  activeNoteId: string | null;
  editingNoteId: string | null;
  selectedNoteIds: string[];
  searchQuery: string;
  filterTags: string[];
  sortBy: 'date' | 'title' | 'tag' | 'custom';
  sortOrder: 'asc' | 'desc';

  // Actions
  createNote: (noteData: CreateNoteData) => Promise<string>;
  updateNote: (noteId: string, updates: Partial<NoteRecord>) => Promise<void>;
  deleteNote: (noteId: string) => Promise<void>;
  setActiveNote: (noteId: string | null) => void;
  setEditingNote: (noteId: string | null) => void;
  searchNotes: (query: string) => void;
  filterByTags: (tagIds: string[]) => void;
  setSortOrder: (sortBy: string, order: 'asc' | 'desc') => void;
}

// è§†å›¾çŠ¶æ€
interface ViewState {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;
  viewStates: Record<ViewType, ViewStateData>;
  isTransitioning: boolean;

  // Actions
  switchView: (viewType: ViewType) => Promise<void>;
  updateViewConfig: (viewType: ViewType, config: Partial<ViewConfig>) => void;
  saveViewState: (viewType: ViewType, state: Partial<ViewStateData>) => void;
  restoreViewState: (viewType: ViewType) => void;
}
```

#### Zustand Storeå®ç°
```typescript
import { create } from 'zustand';
import { persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// åˆ›å»ºä¸»Store
const useAppStore = create<AppState>()(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // åˆå§‹çŠ¶æ€
        flow: createInitialFlowState(),
        notes: createInitialNotesState(),
        view: createInitialViewState(),
        ui: createInitialUIState(),
        user: createInitialUserState(),

        // Flow Actions
        addNode: (node: FlowNode) =>
          set((state) => {
            state.flow.nodes.push(node);
          }),

        removeNode: (nodeId: string) =>
          set((state) => {
            state.flow.nodes = state.flow.nodes.filter(n => n.id !== nodeId);
            state.flow.edges = state.flow.edges.filter(e =>
              e.source !== nodeId && e.target !== nodeId
            );
            state.flow.selectedNodes = state.flow.selectedNodes.filter(id => id !== nodeId);
          }),

        updateNode: (nodeId: string, updates: Partial<FlowNode>) =>
          set((state) => {
            const nodeIndex = state.flow.nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex !== -1) {
              Object.assign(state.flow.nodes[nodeIndex], updates);
            }
          }),

        // Notes Actions
        createNote: async (noteData: CreateNoteData) => {
          const noteId = await noteService.create(noteData);
          set((state) => {
            state.notes.notes[noteId] = {
              id: noteId,
              ...noteData,
              created_at: new Date(),
              updated_at: new Date()
            };
          });
          return noteId;
        },

        updateNote: async (noteId: string, updates: Partial<NoteRecord>) => {
          await noteService.update(noteId, updates);
          set((state) => {
            if (state.notes.notes[noteId]) {
              Object.assign(state.notes.notes[noteId], {
                ...updates,
                updated_at: new Date()
              });
            }
          });
        },

        // View Actions
        switchView: async (viewType: ViewType) => {
          const { currentView, saveViewState } = get();

          // ä¿å­˜å½“å‰è§†å›¾çŠ¶æ€
          await saveViewState(currentView);

          set((state) => {
            state.view.isTransitioning = true;
            state.view.currentView = viewType;
          });

          // æ¢å¤ç›®æ ‡è§†å›¾çŠ¶æ€
          setTimeout(() => {
            set((state) => {
              state.view.isTransitioning = false;
            });
          }, 300);
        },

        // ... å…¶ä»–actions
      }))
    ),
    {
      name: 'noteum-app-state',
      partialize: (state) => ({
        // åªæŒä¹…åŒ–éœ€è¦ä¿å­˜çš„çŠ¶æ€
        flow: {
          nodes: state.flow.nodes,
          edges: state.flow.edges
        },
        view: {
          currentView: state.view.currentView,
          viewConfigs: state.view.viewConfigs
        },
        notes: {
          sortBy: state.notes.sortBy,
          sortOrder: state.notes.sortOrder
        }
      })
    }
  )
);
```

### çŠ¶æ€ä¸­é—´ä»¶

#### æ€§èƒ½ä¼˜åŒ–ä¸­é—´ä»¶
```typescript
// é˜²æŠ–ä¸­é—´ä»¶
const debounceMiddleware = (config) => (set, get) => {
  const debouncedSet = debounce(set, 100);

  return {
    ...config(
      (args) => {
        // å¯¹é¢‘ç¹æ›´æ–°çš„çŠ¶æ€ä½¿ç”¨é˜²æŠ–
        if (args.type === 'flow/updateNodePosition') {
          return debouncedSet(args);
        }
        return set(args);
      },
      get
    )
  };
};

// æ‰¹é‡æ›´æ–°ä¸­é—´ä»¶
const batchMiddleware = (config) => (set, get) => {
  let batch = [];
  let timeoutId = null;

  const flushBatch = () => {
    if (batch.length > 0) {
      set(batch);
      batch = [];
    }
  };

  return {
    ...config(
      (args) => {
        batch.push(args);

        clearTimeout(timeoutId);
        timeoutId = setTimeout(flushBatch, 16); // ä¸€å¸§çš„æ—¶é—´
      },
      get
    ),
    flushBatch // æš´éœ²æ‰‹åŠ¨åˆ·æ–°æ–¹æ³•
  };
};
```

#### çŠ¶æ€åŒæ­¥ä¸­é—´ä»¶
```typescript
// ä¸æ•°æ®åº“åŒæ­¥ä¸­é—´ä»¶
const syncMiddleware = (config) => (set, get) => {
  return {
    ...config(set, get),

    // é‡å†™å…³é”®æ“ä½œä»¥åŒ…å«æ•°æ®åº“åŒæ­¥
    createNote: async (noteData) => {
      const localId = `local_${Date.now()}`;

      // ä¹è§‚æ›´æ–°
      set((state) => {
        state.notes.notes[localId] = {
          id: localId,
          ...noteData,
          created_at: new Date(),
          updated_at: new Date(),
          _syncStatus: 'pending'
        };
      });

      try {
        // æ•°æ®åº“æ“ä½œ
        const realId = await noteService.create(noteData);

        // æ›´æ–°ä¸ºçœŸå®ID
        set((state) => {
          state.notes.notes[realId] = { ...state.notes.notes[localId], id: realId, _syncStatus: 'synced' };
          delete state.notes.notes[localId];
        });

        return realId;
      } catch (error) {
        // å›æ»šæ“ä½œ
        set((state) => {
          delete state.notes.notes[localId];
        });
        throw error;
      }
    }
  };
};
```

### çŠ¶æ€é€‰æ‹©å™¨å’ŒHooks

#### çŠ¶æ€é€‰æ‹©å™¨
```typescript
// FlowçŠ¶æ€é€‰æ‹©å™¨
export const useFlowNodes = () => useAppStore((state) => state.flow.nodes);
export const useFlowEdges = () => useAppStore((state) => state.flow.edges);
export const useSelectedNodes = () => useAppStore((state) => state.flow.selectedNodes);
export const useFlowViewport = () => useAppStore((state) => state.flow.viewport);

// ç¬”è®°çŠ¶æ€é€‰æ‹©å™¨
export const useNotes = () => useAppStore((state) => Object.values(state.notes.notes));
export const useActiveNote = () => useAppStore((state) =>
  state.notes.activeNoteId ? state.notes.notes[state.notes.activeNoteId] : null
);
export const useEditingNote = () => useAppStore((state) =>
  state.notes.editingNoteId ? state.notes.notes[state.notes.editingNoteId] : null
);
export const useFilteredNotes = () => useAppStore((state) => {
  let notes = Object.values(state.notes.notes);

  // åº”ç”¨æœç´¢è¿‡æ»¤
  if (state.notes.searchQuery) {
    notes = notes.filter(note =>
      note.title.includes(state.notes.searchQuery) ||
      note.content.includes(state.notes.searchQuery)
    );
  }

  // åº”ç”¨æ ‡ç­¾è¿‡æ»¤
  if (state.notes.filterTags.length > 0) {
    notes = notes.filter(note =>
      state.notes.filterTags.some(tagId => note.tags.includes(tagId))
    );
  }

  // åº”ç”¨æ’åº
  notes.sort((a, b) => {
    const aValue = a[state.notes.sortBy];
    const bValue = b[state.notes.sortBy];
    const order = state.notes.sortOrder === 'asc' ? 1 : -1;

    if (aValue < bValue) return -order;
    if (aValue > bValue) return order;
    return 0;
  });

  return notes;
});

// è§†å›¾çŠ¶æ€é€‰æ‹©å™¨
export const useCurrentView = () => useAppStore((state) => state.view.currentView);
export const useViewConfig = (viewType: ViewType) => useAppStore((state) =>
  state.view.viewConfigs[viewType]
);
```

#### å¤åˆHooks
```typescript
// ç¬”è®°ç¼–è¾‘Hook
export const useNoteEditor = (noteId: string | null) => {
  const notes = useNotes();
  const activeNote = useActiveNote();
  const { updateNote, setEditingNote } = useAppStore();

  const startEditing = useCallback(() => {
    if (noteId) {
      setEditingNote(noteId);
    }
  }, [noteId, setEditingNote]);

  const saveNote = useCallback(async (updates: Partial<NoteRecord>) => {
    if (noteId) {
      await updateNote(noteId, updates);
      setEditingNote(null);
    }
  }, [noteId, updateNote, setEditingNote]);

  const cancelEditing = useCallback(() => {
    setEditingNote(null);
  }, [setEditingNote]);

  return {
    note: noteId ? notes.find(n => n.id === noteId) : activeNote,
    isEditing: activeNote?.id === noteId,
    startEditing,
    saveNote,
    cancelEditing
  };
};

// è§†å›¾åˆ‡æ¢Hook
export const useViewSwitcher = () => {
  const { currentView, switchView, isTransitioning } = useAppStore();

  const switchToView = useCallback(async (viewType: ViewType) => {
    if (viewType !== currentView && !isTransitioning) {
      await switchView(viewType);
    }
  }, [currentView, isTransitioning, switchView]);

  return {
    currentView,
    isTransitioning,
    switchToView
  };
};
```

### çŠ¶æ€è°ƒè¯•å·¥å…·

#### å¼€å‘å·¥å…·é›†æˆ
```typescript
// Zustand DevToolsé›†æˆ
const useAppStore = create<AppState>()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // ... store implementation
        }))
      ),
      { name: 'noteum-app-state' }
    ),
    { name: 'Noteum Store' }
  )
);

// çŠ¶æ€æ£€æŸ¥å·¥å…·
export const useAppStateInspector = () => {
  const state = useAppStore();

  return {
    inspectState: () => {
      console.group('ğŸ” App State Inspector');
      console.log('Flow Nodes:', state.flow.nodes.length);
      console.log('Flow Edges:', state.flow.edges.length);
      console.log('Total Notes:', Object.keys(state.notes.notes).length);
      console.log('Active Note:', state.notes.activeNoteId);
      console.log('Current View:', state.view.currentView);
      console.log('Is Transitioning:', state.view.isTransitioning);
      console.groupEnd();
    },

    validateState: () => {
      const errors = [];

      // æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
      state.flow.edges.forEach(edge => {
        const sourceExists = state.flow.nodes.some(n => n.id === edge.source);
        const targetExists = state.flow.nodes.some(n => n.id === edge.target);

        if (!sourceExists) {
          errors.push(`Edge ${edge.id} references non-existent source node ${edge.source}`);
        }
        if (!targetExists) {
          errors.push(`Edge ${edge.id} references non-existent target node ${edge.target}`);
        }
      });

      return errors;
    }
  };
};
```

### ä»£ç æ–‡ä»¶å½±å“

- `src/stores/AppStore.ts` - ä¸»çŠ¶æ€store
- `src/stores/slices/flowSlice.ts` - FlowçŠ¶æ€åˆ‡ç‰‡
- `src/stores/slices/notesSlice.ts` - ç¬”è®°çŠ¶æ€åˆ‡ç‰‡
- `src/stores/slices/viewSlice.ts` - è§†å›¾çŠ¶æ€åˆ‡ç‰‡
- `src/stores/slices/uiSlice.ts` - UIçŠ¶æ€åˆ‡ç‰‡
- `src/stores/middleware/` - è‡ªå®šä¹‰ä¸­é—´ä»¶
- `src/hooks/store/` - çŠ¶æ€ç›¸å…³hooks
- `src/utils/stateValidation.ts` - çŠ¶æ€éªŒè¯å·¥å…·

## Dependencies

- [ ] ä»»åŠ¡003ï¼šæ‹–æ‹½å®šä½å’Œè§†å›¾ç®¡ç†å®Œæˆ
- [ ] ZustandçŠ¶æ€ç®¡ç†åº“
- [ ] Immeråº“ï¼ˆç”¨äºä¸å¯å˜æ›´æ–°ï¼‰
- [ ] React DevToolsé›†æˆ

## Effort Estimate

- Size: M
- Days: 2å¤©
- Parallel: true

## Definition of Done

- [ ] ZustandçŠ¶æ€ç®¡ç†é…ç½®å®Œæˆ
- [ ] æ‰€æœ‰çŠ¶æ€åˆ‡ç‰‡å®ç°å®Œæˆ
- [ ] çŠ¶æ€æŒä¹…åŒ–æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] çŠ¶æ€é€‰æ‹©å™¨å’Œhookså®Œæ•´å¯ç”¨
- [ ] æ€§èƒ½ä¼˜åŒ–ä¸­é—´ä»¶æ­£å¸¸å·¥ä½œ
- [ ] è°ƒè¯•å·¥å…·é›†æˆå®Œæˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- [ ] é›†æˆæµ‹è¯•éªŒè¯çŠ¶æ€åŒæ­¥
- [ ] ä»£ç å®¡æŸ¥é€šè¿‡
- [ ] çŠ¶æ€ç®¡ç†æ–‡æ¡£å®Œæˆ