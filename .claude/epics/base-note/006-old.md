---
name: 状态管理：Zustand统一状态管理
status: open
created: 2025-10-07T00:00:00Z
github: [待创建GitHub Issue]
depends_on: [003]
parallel: true
conflicts_with: []
---

# Task: 状态管理：Zustand统一状态管理

## Description

配置Zustand状态管理库，实现Flow状态、笔记状态、视图状态的统一管理，建立高效的状态同步机制，支持组件间的状态共享和实时更新，确保应用状态的一致性和可预测性。

## Acceptance Criteria

- [ ] 配置Zustand状态管理库，集成到现有React应用中
- [ ] 实现Flow状态管理，包括工作流状态、节点位置、连接关系
- [ ] 实现笔记状态管理，包括CRUD操作、选中状态、编辑状态
- [ ] 实现视图状态管理，包括当前视图、视图配置、UI状态
- [ ] 建立状态间的依赖关系和同步机制
- [ ] 实现状态持久化，支持本地存储和云端同步
- [ ] 添加状态调试工具和开发时状态检查
- [ ] 实现状态变更的性能优化（防抖、批量更新）
- [ ] 编写状态管理的完整测试套件
- [ ] 建立状态管理的最佳实践文档

## Technical Details

### Zustand架构设计

#### 状态结构设计
```typescript
// 主状态接口
interface AppState {
  // Flow相关状态
  flow: FlowState;

  // 笔记相关状态
  notes: NotesState;

  // 视图相关状态
  view: ViewState;

  // UI相关状态
  ui: UIState;

  // 用户相关状态
  user: UserState;
}

// Flow状态
interface FlowState {
  nodes: FlowNode[];
  edges: FlowEdge[];
  selectedNodes: string[];
  selectedEdges: string[];
  viewport: ViewportState;
  isDragging: boolean;
  isConnecting: boolean;
  connectionSource: string | null;

  // Actions
  addNode: (node: FlowNode) => void;
  removeNode: (nodeId: string) => void;
  updateNode: (nodeId: string, updates: Partial<FlowNode>) => void;
  addEdge: (edge: FlowEdge) => void;
  removeEdge: (edgeId: string) => void;
  selectNodes: (nodeIds: string[]) => void;
  clearSelection: () => void;
  setViewport: (viewport: Partial<ViewportState>) => void;
}

// 笔记状态
interface NotesState {
  notes: Record<string, NoteRecord>;
  activeNoteId: string | null;
  editingNoteId: string | null;
  selectedNoteIds: string[];
  searchQuery: string;
  filterTags: string[];
  sortBy: 'date' | 'title' | 'tag' | 'custom';
  sortOrder: 'asc' | 'desc';

  // Actions
  createNote: (noteData: CreateNoteData) => Promise<string>;
  updateNote: (noteId: string, updates: Partial<NoteRecord>) => Promise<void>;
  deleteNote: (noteId: string) => Promise<void>;
  setActiveNote: (noteId: string | null) => void;
  setEditingNote: (noteId: string | null) => void;
  searchNotes: (query: string) => void;
  filterByTags: (tagIds: string[]) => void;
  setSortOrder: (sortBy: string, order: 'asc' | 'desc') => void;
}

// 视图状态
interface ViewState {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;
  viewStates: Record<ViewType, ViewStateData>;
  isTransitioning: boolean;

  // Actions
  switchView: (viewType: ViewType) => Promise<void>;
  updateViewConfig: (viewType: ViewType, config: Partial<ViewConfig>) => void;
  saveViewState: (viewType: ViewType, state: Partial<ViewStateData>) => void;
  restoreViewState: (viewType: ViewType) => void;
}
```

#### Zustand Store实现
```typescript
import { create } from 'zustand';
import { persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// 创建主Store
const useAppStore = create<AppState>()(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // 初始状态
        flow: createInitialFlowState(),
        notes: createInitialNotesState(),
        view: createInitialViewState(),
        ui: createInitialUIState(),
        user: createInitialUserState(),

        // Flow Actions
        addNode: (node: FlowNode) =>
          set((state) => {
            state.flow.nodes.push(node);
          }),

        removeNode: (nodeId: string) =>
          set((state) => {
            state.flow.nodes = state.flow.nodes.filter(n => n.id !== nodeId);
            state.flow.edges = state.flow.edges.filter(e =>
              e.source !== nodeId && e.target !== nodeId
            );
            state.flow.selectedNodes = state.flow.selectedNodes.filter(id => id !== nodeId);
          }),

        updateNode: (nodeId: string, updates: Partial<FlowNode>) =>
          set((state) => {
            const nodeIndex = state.flow.nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex !== -1) {
              Object.assign(state.flow.nodes[nodeIndex], updates);
            }
          }),

        // Notes Actions
        createNote: async (noteData: CreateNoteData) => {
          const noteId = await noteService.create(noteData);
          set((state) => {
            state.notes.notes[noteId] = {
              id: noteId,
              ...noteData,
              created_at: new Date(),
              updated_at: new Date()
            };
          });
          return noteId;
        },

        updateNote: async (noteId: string, updates: Partial<NoteRecord>) => {
          await noteService.update(noteId, updates);
          set((state) => {
            if (state.notes.notes[noteId]) {
              Object.assign(state.notes.notes[noteId], {
                ...updates,
                updated_at: new Date()
              });
            }
          });
        },

        // View Actions
        switchView: async (viewType: ViewType) => {
          const { currentView, saveViewState } = get();

          // 保存当前视图状态
          await saveViewState(currentView);

          set((state) => {
            state.view.isTransitioning = true;
            state.view.currentView = viewType;
          });

          // 恢复目标视图状态
          setTimeout(() => {
            set((state) => {
              state.view.isTransitioning = false;
            });
          }, 300);
        },

        // ... 其他actions
      }))
    ),
    {
      name: 'noteum-app-state',
      partialize: (state) => ({
        // 只持久化需要保存的状态
        flow: {
          nodes: state.flow.nodes,
          edges: state.flow.edges
        },
        view: {
          currentView: state.view.currentView,
          viewConfigs: state.view.viewConfigs
        },
        notes: {
          sortBy: state.notes.sortBy,
          sortOrder: state.notes.sortOrder
        }
      })
    }
  )
);
```

### 状态中间件

#### 性能优化中间件
```typescript
// 防抖中间件
const debounceMiddleware = (config) => (set, get) => {
  const debouncedSet = debounce(set, 100);

  return {
    ...config(
      (args) => {
        // 对频繁更新的状态使用防抖
        if (args.type === 'flow/updateNodePosition') {
          return debouncedSet(args);
        }
        return set(args);
      },
      get
    )
  };
};

// 批量更新中间件
const batchMiddleware = (config) => (set, get) => {
  let batch = [];
  let timeoutId = null;

  const flushBatch = () => {
    if (batch.length > 0) {
      set(batch);
      batch = [];
    }
  };

  return {
    ...config(
      (args) => {
        batch.push(args);

        clearTimeout(timeoutId);
        timeoutId = setTimeout(flushBatch, 16); // 一帧的时间
      },
      get
    ),
    flushBatch // 暴露手动刷新方法
  };
};
```

#### 状态同步中间件
```typescript
// 与数据库同步中间件
const syncMiddleware = (config) => (set, get) => {
  return {
    ...config(set, get),

    // 重写关键操作以包含数据库同步
    createNote: async (noteData) => {
      const localId = `local_${Date.now()}`;

      // 乐观更新
      set((state) => {
        state.notes.notes[localId] = {
          id: localId,
          ...noteData,
          created_at: new Date(),
          updated_at: new Date(),
          _syncStatus: 'pending'
        };
      });

      try {
        // 数据库操作
        const realId = await noteService.create(noteData);

        // 更新为真实ID
        set((state) => {
          state.notes.notes[realId] = { ...state.notes.notes[localId], id: realId, _syncStatus: 'synced' };
          delete state.notes.notes[localId];
        });

        return realId;
      } catch (error) {
        // 回滚操作
        set((state) => {
          delete state.notes.notes[localId];
        });
        throw error;
      }
    }
  };
};
```

### 状态选择器和Hooks

#### 状态选择器
```typescript
// Flow状态选择器
export const useFlowNodes = () => useAppStore((state) => state.flow.nodes);
export const useFlowEdges = () => useAppStore((state) => state.flow.edges);
export const useSelectedNodes = () => useAppStore((state) => state.flow.selectedNodes);
export const useFlowViewport = () => useAppStore((state) => state.flow.viewport);

// 笔记状态选择器
export const useNotes = () => useAppStore((state) => Object.values(state.notes.notes));
export const useActiveNote = () => useAppStore((state) =>
  state.notes.activeNoteId ? state.notes.notes[state.notes.activeNoteId] : null
);
export const useEditingNote = () => useAppStore((state) =>
  state.notes.editingNoteId ? state.notes.notes[state.notes.editingNoteId] : null
);
export const useFilteredNotes = () => useAppStore((state) => {
  let notes = Object.values(state.notes.notes);

  // 应用搜索过滤
  if (state.notes.searchQuery) {
    notes = notes.filter(note =>
      note.title.includes(state.notes.searchQuery) ||
      note.content.includes(state.notes.searchQuery)
    );
  }

  // 应用标签过滤
  if (state.notes.filterTags.length > 0) {
    notes = notes.filter(note =>
      state.notes.filterTags.some(tagId => note.tags.includes(tagId))
    );
  }

  // 应用排序
  notes.sort((a, b) => {
    const aValue = a[state.notes.sortBy];
    const bValue = b[state.notes.sortBy];
    const order = state.notes.sortOrder === 'asc' ? 1 : -1;

    if (aValue < bValue) return -order;
    if (aValue > bValue) return order;
    return 0;
  });

  return notes;
});

// 视图状态选择器
export const useCurrentView = () => useAppStore((state) => state.view.currentView);
export const useViewConfig = (viewType: ViewType) => useAppStore((state) =>
  state.view.viewConfigs[viewType]
);
```

#### 复合Hooks
```typescript
// 笔记编辑Hook
export const useNoteEditor = (noteId: string | null) => {
  const notes = useNotes();
  const activeNote = useActiveNote();
  const { updateNote, setEditingNote } = useAppStore();

  const startEditing = useCallback(() => {
    if (noteId) {
      setEditingNote(noteId);
    }
  }, [noteId, setEditingNote]);

  const saveNote = useCallback(async (updates: Partial<NoteRecord>) => {
    if (noteId) {
      await updateNote(noteId, updates);
      setEditingNote(null);
    }
  }, [noteId, updateNote, setEditingNote]);

  const cancelEditing = useCallback(() => {
    setEditingNote(null);
  }, [setEditingNote]);

  return {
    note: noteId ? notes.find(n => n.id === noteId) : activeNote,
    isEditing: activeNote?.id === noteId,
    startEditing,
    saveNote,
    cancelEditing
  };
};

// 视图切换Hook
export const useViewSwitcher = () => {
  const { currentView, switchView, isTransitioning } = useAppStore();

  const switchToView = useCallback(async (viewType: ViewType) => {
    if (viewType !== currentView && !isTransitioning) {
      await switchView(viewType);
    }
  }, [currentView, isTransitioning, switchView]);

  return {
    currentView,
    isTransitioning,
    switchToView
  };
};
```

### 状态调试工具

#### 开发工具集成
```typescript
// Zustand DevTools集成
const useAppStore = create<AppState>()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // ... store implementation
        }))
      ),
      { name: 'noteum-app-state' }
    ),
    { name: 'Noteum Store' }
  )
);

// 状态检查工具
export const useAppStateInspector = () => {
  const state = useAppStore();

  return {
    inspectState: () => {
      console.group('🔍 App State Inspector');
      console.log('Flow Nodes:', state.flow.nodes.length);
      console.log('Flow Edges:', state.flow.edges.length);
      console.log('Total Notes:', Object.keys(state.notes.notes).length);
      console.log('Active Note:', state.notes.activeNoteId);
      console.log('Current View:', state.view.currentView);
      console.log('Is Transitioning:', state.view.isTransitioning);
      console.groupEnd();
    },

    validateState: () => {
      const errors = [];

      // 检查数据一致性
      state.flow.edges.forEach(edge => {
        const sourceExists = state.flow.nodes.some(n => n.id === edge.source);
        const targetExists = state.flow.nodes.some(n => n.id === edge.target);

        if (!sourceExists) {
          errors.push(`Edge ${edge.id} references non-existent source node ${edge.source}`);
        }
        if (!targetExists) {
          errors.push(`Edge ${edge.id} references non-existent target node ${edge.target}`);
        }
      });

      return errors;
    }
  };
};
```

### 代码文件影响

- `src/stores/AppStore.ts` - 主状态store
- `src/stores/slices/flowSlice.ts` - Flow状态切片
- `src/stores/slices/notesSlice.ts` - 笔记状态切片
- `src/stores/slices/viewSlice.ts` - 视图状态切片
- `src/stores/slices/uiSlice.ts` - UI状态切片
- `src/stores/middleware/` - 自定义中间件
- `src/hooks/store/` - 状态相关hooks
- `src/utils/stateValidation.ts` - 状态验证工具

## Dependencies

- [ ] 任务003：拖拽定位和视图管理完成
- [ ] Zustand状态管理库
- [ ] Immer库（用于不可变更新）
- [ ] React DevTools集成

## Effort Estimate

- Size: M
- Days: 2天
- Parallel: true

## Definition of Done

- [ ] Zustand状态管理配置完成
- [ ] 所有状态切片实现完成
- [ ] 状态持久化机制正常工作
- [ ] 状态选择器和hooks完整可用
- [ ] 性能优化中间件正常工作
- [ ] 调试工具集成完成
- [ ] 单元测试覆盖率达到90%以上
- [ ] 集成测试验证状态同步
- [ ] 代码审查通过
- [ ] 状态管理文档完成