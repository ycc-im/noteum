---
name: 状态管理：Zustand统一状态管理（TDD）
status: open
created: 2025-10-07T00:00:00Z
github: https://github.com/ycc-im/noteum/issues/133
depends_on: [008, 003]
parallel: true
conflicts_with: []
---

# Task: 状态管理：Zustand统一状态管理（TDD）

## Description

**采用TDD（测试驱动开发）方法**配置Zustand状态管理库，实现Flow状态、笔记状态、视图状态的统一管理，建立高效的状态同步机制，支持组件间的状态共享和实时更新，确保应用状态的一致性和可预测性。

**TDD开发流程**：严格遵循Red-Green-Refactor循环，先为每个状态管理功能编写失败的测试，再实现功能，最后优化性能和可维护性。

## Acceptance Criteria

### 🔴 TDD阶段：测试先行（Red）
- [ ] **编写状态管理测试套件**：先为所有状态管理功能编写失败的测试
- [ ] **Flow状态测试**：节点增删改查、选中状态、拖拽状态的测试
- [ ] **笔记状态测试**：CRUD操作、搜索过滤、排序功能的测试
- [ ] **视图状态测试**：视图切换、状态持久化、配置管理的测试
- [ ] **状态同步测试**：状态间依赖、数据一致性、冲突解决的测试
- [ ] **性能优化测试**：防抖、批量更新、选择器优化的测试
- [ ] **持久化测试**：本地存储、数据恢复、错误处理的测试

### 🟢 实现阶段：功能实现（Green）
- [ ] 配置Zustand状态管理库，集成到现有React应用中，让TDD测试通过
- [ ] 实现Flow状态管理，包括工作流状态、节点位置、连接关系
- [ ] 实现笔记状态管理，包括CRUD操作、选中状态、编辑状态
- [ ] 实现视图状态管理，包括当前视图、视图配置、UI状态
- [ ] 建立状态间的依赖关系和同步机制
- [ ] 实现状态持久化，支持本地存储和云端同步
- [ ] 添加状态调试工具和开发时状态检查

### 🔄 重构阶段：代码优化（Refactor）
- [ ] **优化状态性能**：在保持测试通过的前提下优化状态更新性能
- [ ] **重构状态结构**：提升状态组织结构的可维护性
- [ ] **优化中间件**：减少中间件开销，提升响应速度
- [ ] **TDD质量验证**：确保测试覆盖率≥90%，所有测试稳定通过

## Technical Details

### TDD测试设计

#### Flow状态管理测试
```typescript
/ src/stores flowSlice.test.ts
describe('Flow State Management TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Node Management', () => {
    it('should add node to flow state', () => {
      const node: FlowNode = {
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Test Note', content: 'Test content' }
      };

      store.getState().addNode(node);

      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(1);
      expect(state.flow.nodes[0]).toEqual(node);
    });

    it('should remove node and related edges', () => {
      / Setup: Add node and edges
      const node: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };
      const edge: FlowEdge = { id: 'edge-1', source: 'node-1', target: 'node-2' };

      store.getState().addNode(node);
      store.getState().addEdge(edge);

      / Action: Remove node
      store.getState().removeNode('node-1');

      / Assert: Node and edge should be removed
      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(0);
      expect(state.flow.edges).toHaveLength(0);
    });

    it('should update node properties', () => {
      const node: FlowNode = {
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Old Title' }
      };

      store.getState().addNode(node);
      store.getState().updateNode('node-1', {
        position: { x: 150, y: 250 },
        data: { title: 'New Title' }
      });

      const state = store.getState();
      const updatedNode = state.flow.nodes[0];
      expect(updatedNode.position).toEqual({ x: 150, y: 250 });
      expect(updatedNode.data.title).toBe('New Title');
    });
  });

  describe('Node Selection', () => {
    it('should select multiple nodes', () => {
      const nodes = [
        { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} },
        { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} }
      ];

      nodes.forEach(node => store.getState().addNode(node));
      store.getState().selectNodes(['node-1', 'node-2']);

      const state = store.getState();
      expect(state.flow.selectedNodes).toEqual(['node-1', 'node-2']);
    });

    it('should clear selection', () => {
      const node: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };

      store.getState().addNode(node);
      store.getState().selectNodes(['node-1']);
      store.getState().clearSelection();

      const state = store.getState();
      expect(state.flow.selectedNodes).toHaveLength(0);
    });
  });

  describe('Edge Management', () => {
    it('should add edge between nodes', () => {
      const sourceNode: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };
      const targetNode: FlowNode = { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} };
      const edge: FlowEdge = {
        id: 'edge-1',
        source: 'node-1',
        target: 'node-2',
        sourceHandle: 'output',
        targetHandle: 'input'
      };

      store.getState().addNode(sourceNode);
      store.getState().addNode(targetNode);
      store.getState().addEdge(edge);

      const state = store.getState();
      expect(state.flow.edges).toHaveLength(1);
      expect(state.flow.edges[0]).toEqual(edge);
    });

    it('should validate edge exists before adding', () => {
      const edge: FlowEdge = {
        id: 'edge-1',
        source: 'nonexistent',
        target: 'node-2',
        sourceHandle: 'output',
        targetHandle: 'input'
      };

      expect(() => {
        store.getState().addEdge(edge);
      }).toThrow('Cannot create edge: source node does not exist');
    });
  });
});
```

#### 笔记状态管理测试
```typescript
/ src/stores notesSlice.test.ts
describe('Notes State Management TDD', () => {
  let store: AppStore;
  let mockNoteService: jest.Mocked<NoteService>;

  beforeEach(() => {
    mockNoteService = createMockNoteService();
    store = createTestStore({ noteService: mockNoteService });
  });

  describe('Note CRUD Operations', () => {
    it('should create note and update state', async () => {
      const noteData: CreateNoteData = {
        title: 'Test Note',
        content: 'Test content'
      };

      mockNoteService.create.mockResolvedValue('note-1');

      const noteId = await store.getState().createNote(noteData);

      expect(noteId).toBe('note-1');
      expect(mockNoteService.create).toHaveBeenCalledWith(noteData);

      const state = store.getState();
      expect(state.notes.notes).toHaveProperty('note-1');
      expect(state.notes.notes['note-1']).toEqual(
        expect.objectContaining({
          id: 'note-1',
          title: 'Test Note',
          content: 'Test content',
          created_at: expect.any(Date),
          updated_at: expect.any(Date)
        })
      );
    });

    it('should handle note creation failure gracefully', async () => {
      const noteData: CreateNoteData = {
        title: 'Test Note',
        content: 'Test content'
      };

      mockNoteService.create.mockRejectedValue(new Error('Database error'));

      await expect(store.getState().createNote(noteData)).rejects.toThrow('Database error');

      const state = store.getState();
      expect(Object.keys(state.notes.notes)).toHaveLength(0);
    });

    it('should update note and sync with database', async () => {
      / Setup: Create note first
      const noteData: CreateNoteData = { title: 'Original Title', content: 'Original content' };
      mockNoteService.create.mockResolvedValue('note-1');
      await store.getState().createNote(noteData);

      / Update note
      const updates = { title: 'Updated Title', content: 'Updated content' };
      mockNoteService.update.mockResolvedValue(undefined);

      await store.getState().updateNote('note-1', updates);

      expect(mockNoteService.update).toHaveBeenCalledWith('note-1', updates);

      const state = store.getState();
      const updatedNote = state.notes.notes['note-1'];
      expect(updatedNote.title).toBe('Updated Title');
      expect(updatedNote.content).toBe('Updated content');
      expect(updatedNote.updated_at).not.toEqual(noteData.created_at);
    });

    it('should delete note and remove from state', async () => {
      / Setup: Create note first
      const noteData: CreateNoteData = { title: 'Test Note', content: 'Test content' };
      mockNoteService.create.mockResolvedValue('note-1');
      mockNoteService.delete.mockResolvedValue(undefined);
      await store.getState().createNote(noteData);

      / Delete note
      await store.getState().deleteNote('note-1');

      expect(mockNoteService.delete).toHaveBeenCalledWith('note-1');

      const state = store.getState();
      expect(state.notes.notes).not.toHaveProperty('note-1');
    });
  });

  describe('Note Selection and Editing', () => {
    it('should set active note', () => {
      const note: NoteRecord = {
        id: 'note-1',
        title: 'Test Note',
        content: 'Test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      store.setState({ notes: { notes: { 'note-1': note } } });
      store.getState().setActiveNote('note-1');

      const state = store.getState();
      expect(state.notes.activeNoteId).toBe('note-1');
    });

    it('should set editing note', () => {
      const note: NoteRecord = {
        id: 'note-1',
        title: 'Test Note',
        content: 'Test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      store.setState({ notes: { notes: { 'note-1': note } } });
      store.getState().setEditingNote('note-1');

      const state = store.getState();
      expect(state.notes.editingNoteId).toBe('note-1');
    });

    it('should clear editing note when set to null', () => {
      store.setState({ notes: { editingNoteId: 'note-1' } });
      store.getState().setEditingNote(null);

      const state = store.getState();
      expect(state.notes.editingNoteId).toBeNull();
    });
  });

  describe('Note Filtering and Sorting', () => {
    beforeEach(() => {
      const notes: NoteRecord[] = [
        { id: 'note-1', title: 'Work Task', content: 'Important work', created_at: new Date('2025-01-15'), updated_at: new Date(), tags: ['work'] },
        { id: 'note-2', title: 'Personal Note', content: 'Personal reminder', created_at: new Date('2025-01-10'), updated_at: new Date(), tags: ['personal'] },
        { id: 'note-3', title: 'Work Meeting', content: 'Meeting notes', created_at: new Date('2025-01-20'), updated_at: new Date(), tags: ['work'] }
      ];

      store.setState({
        notes: {
          notes: notes.reduce((acc, note) => ({ ...acc, [note.id]: note }), {}),
          activeNoteId: null,
          editingNoteId: null,
          selectedNoteIds: [],
          searchQuery: '',
          filterTags: [],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });
    });

    it('should filter notes by search query', () => {
      store.getState().searchNotes('work');

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(2);
      expect(filteredNotes.every(note =>
        note.title.includes('work') || note.content.includes('work')
      )).toBe(true);
    });

    it('should filter notes by tags', () => {
      / Assume 'work' tag has id 'tag-1'
      store.getState().filterByTags(['tag-1']);

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(2);
      expect(filteredNotes.every(note => note.tags.includes('tag-1'))).toBe(true);
    });

    it('should sort notes by date', () => {
      store.getState().setSortOrder('created_at', 'asc');

      const sortedNotes = useFilteredNotes.getState();
      expect(sortedNotes[0].id).toBe('note-2'); / 2025-01-10
      expect(sortedNotes[1].id).toBe('note-1'); / 2025-01-15
      expect(sortedNotes[2].id).toBe('note-3'); / 2025-01-20
    });

    it('should sort notes by title', () => {
      store.getState().setSortOrder('title', 'asc');

      const sortedNotes = useFilteredNotes.getState();
      expect(sortedNotes[0].title).toBe('Personal Note');
      expect(sortedNotes[1].title).toBe('Work Meeting');
      expect(sortedNotes[2].title).toBe('Work Task');
    });
  });
});
```

#### 视图状态管理测试
```typescript
/ src/stores viewSlice.test.ts
describe('View State Management TDD', () => {
  let store: AppStore;
  let mockViewService: jest.Mocked<ViewService>;

  beforeEach(() => {
    mockViewService = createMockViewService();
    store = createTestStore({ viewService: mockViewService });
  });

  describe('View Switching', () => {
    it('should switch view and save current state', async () => {
      mockViewService.saveViewState.mockResolvedValue(undefined);
      mockViewService.restoreViewState.mockResolvedValue(undefined);

      store.setState({ view: { currentView: 'daily' } });
      await store.getState().switchView('tags');

      const state = store.getState();
      expect(state.view.currentView).toBe('tags');
      expect(state.view.isTransitioning).toBe(false);
      expect(mockViewService.saveViewState).toHaveBeenCalledWith('daily');
      expect(mockViewService.restoreViewState).toHaveBeenCalledWith('tags');
    });

    it('should handle view switching errors gracefully', async () => {
      mockViewService.saveViewState.mockRejectedValue(new Error('Save failed'));

      store.setState({ view: { currentView: 'daily' } });

      await expect(store.getState().switchView('tags')).rejects.toThrow('Save failed');

      const state = store.getState();
      expect(state.view.currentView).toBe('daily'); / Should remain unchanged
    });

    it('should not switch if same view', async () => {
      store.setState({ view: { currentView: 'daily' } });
      await store.getState().switchView('daily');

      expect(mockViewService.saveViewState).not.toHaveBeenCalled();
      expect(mockViewService.restoreViewState).not.toHaveBeenCalled();
    });
  });

  describe('View Configuration', () => {
    it('should update view config', () => {
      const configUpdate = {
        layout: 'grid',
        animation: { duration: 500, type: 'slide' }
      };

      store.getState().updateViewConfig('daily', configUpdate);

      const state = store.getState();
      expect(state.view.viewConfigs['daily']).toEqual(
        expect.objectContaining(configUpdate)
      );
    });

    it('should save view state', () => {
      const viewState = {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5
      };

      store.getState().saveViewState('daily', viewState);

      const state = store.getState();
      expect(state.view.viewStates['daily']).toEqual(
        expect.objectContaining(viewState)
      );
    });

    it('should restore view state', () => {
      const savedState = {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5
      };

      store.setState({
        view: {
          viewStates: { daily: savedState }
        }
      });

      store.getState().restoreViewState('daily');

      / Verify state restoration through getters or effects
      expect(mockViewService.applyViewState).toHaveBeenCalledWith(savedState);
    });
  });

  describe('View Transition States', () => {
    it('should set transitioning state during view switch', async () => {
      mockViewService.saveViewState.mockImplementation(() =>
        new Promise(resolve => setTimeout(resolve, 100))
      );

      store.setState({ view: { currentView: 'daily' } });

      const switchPromise = store.getState().switchView('tags');

      / Check intermediate state
      let state = store.getState();
      expect(state.view.isTransitioning).toBe(true);

      await switchPromise;

      / Check final state
      state = store.getState();
      expect(state.view.isTransitioning).toBe(false);
      expect(state.view.currentView).toBe('tags');
    });
  });
});
```

#### 状态选择器测试
```typescript
/ src/hooks/store selectors.test.ts
describe('State Selectors TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Flow Selectors', () => {
    it('should select flow nodes', () => {
      const nodes: FlowNode[] = [
        { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} },
        { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} }
      ];

      store.setState({ flow: { nodes } });

      const selectedNodes = useFlowNodes.getState();
      expect(selectedNodes).toEqual(nodes);
    });

    it('should select selected nodes', () => {
      store.setState({ flow: { selectedNodes: ['node-1', 'node-2'] } });

      const selectedNodeIds = useSelectedNodes.getState();
      expect(selectedNodeIds).toEqual(['node-1', 'node-2']);
    });

    it('should select flow viewport', () => {
      const viewport = { x: 100, y: 200, zoom: 1.5 };
      store.setState({ flow: { viewport } });

      const selectedViewport = useFlowViewport.getState();
      expect(selectedViewport).toEqual(viewport);
    });
  });

  describe('Notes Selectors', () => {
    it('should select notes as array', () => {
      const notes: Record<string, NoteRecord> = {
        'note-1': { id: 'note-1', title: 'Note 1', content: 'Content 1', created_at: new Date(), updated_at: new Date() },
        'note-2': { id: 'note-2', title: 'Note 2', content: 'Content 2', created_at: new Date(), updated_at: new Date() }
      };

      store.setState({ notes: { notes } });

      const selectedNotes = useNotes.getState();
      expect(selectedNotes).toHaveLength(2);
      expect(selectedNotes[0].id).toBe('note-1');
      expect(selectedNotes[1].id).toBe('note-2');
    });

    it('should select active note', () => {
      const note: NoteRecord = { id: 'note-1', title: 'Active Note', content: 'Content', created_at: new Date(), updated_at: new Date() };

      store.setState({
        notes: {
          notes: { 'note-1': note },
          activeNoteId: 'note-1'
        }
      });

      const activeNote = useActiveNote.getState();
      expect(activeNote).toEqual(note);
    });

    it('should return null for active note when none selected', () => {
      store.setState({ notes: { activeNoteId: null } });

      const activeNote = useActiveNote.getState();
      expect(activeNote).toBeNull();
    });

    it('should filter and sort notes correctly', () => {
      const notes: Record<string, NoteRecord> = {
        'note-1': { id: 'note-1', title: 'Work Task', content: 'Important work', created_at: new Date('2025-01-15'), updated_at: new Date(), tags: ['work'] },
        'note-2': { id: 'note-2', title: 'Personal Note', content: 'Personal reminder', created_at: new Date('2025-01-10'), updated_at: new Date(), tags: ['personal'] }
      };

      store.setState({
        notes: {
          notes,
          searchQuery: 'work',
          filterTags: ['work'],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(1);
      expect(filteredNotes[0].id).toBe('note-1');
    });
  });

  describe('View Selectors', () => {
    it('should select current view', () => {
      store.setState({ view: { currentView: 'daily' } });

      const currentView = useCurrentView.getState();
      expect(currentView).toBe('daily');
    });

    it('should select view config by type', () => {
      const configs: Record<ViewType, ViewConfig> = {
        daily: { id: 'daily', name: 'Daily View', layout: 'timeline', sorting: 'date', animation: {}, interactions: {} },
        tags: { id: 'tags', name: 'Tags View', layout: 'grid', sorting: 'tag', animation: {}, interactions: {} }
      };

      store.setState({ view: { viewConfigs: configs } });

      const dailyConfig = useViewConfig('daily').getState();
      expect(dailyConfig.layout).toBe('timeline');
      expect(dailyConfig.name).toBe('Daily View');
    });
  });
});
```

#### 状态持久化测试
```typescript
/ src/stores persistence.test.ts
describe('State Persistence TDD', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('Local Storage Persistence', () => {
    it('should persist state to localStorage', () => {
      const store = createTestStore();

      / Update some state
      store.getState().addNode({
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Test Note' }
      });

      / Force persistence
      store.getState().flushBatch?.();

      const storedData = localStorage.getItem('noteum-app-state');
      expect(storedData).toBeTruthy();

      const parsedData = JSON.parse(storedData);
      expect(parsedData.state.flow.nodes).toHaveLength(1);
      expect(parsedData.state.flow.nodes[0].id).toBe('node-1');
    });

    it('should restore state from localStorage', () => {
      / Pre-populate localStorage
      const initialState = {
        state: {
          flow: {
            nodes: [{ id: 'node-1', type: 'note', position: { x: 100, y: 200 }, data: {} }],
            edges: [],
            selectedNodes: [],
            selectedEdges: [],
            viewport: { x: 0, y: 0, zoom: 1 }
          },
          notes: {
            notes: {},
            activeNoteId: null,
            editingNoteId: null,
            selectedNoteIds: [],
            searchQuery: '',
            filterTags: [],
            sortBy: 'created_at',
            sortOrder: 'desc'
          },
          view: {
            currentView: 'daily',
            viewConfigs: {},
            viewStates: {},
            isTransitioning: false
          }
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(initialState));

      const store = createTestStore();
      const state = store.getState();

      expect(state.flow.nodes).toHaveLength(1);
      expect(state.flow.nodes[0].id).toBe('node-1');
      expect(state.view.currentView).toBe('daily');
    });

    it('should handle corrupted localStorage gracefully', () => {
      localStorage.setItem('noteum-app-state', 'invalid json');

      expect(() => {
        createTestStore();
      }).not.toThrow();

      const store = createTestStore();
      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(0); / Should default to empty state
    });
  });

  describe('State Migration', () => {
    it('should migrate old state format to new format', () => {
      / Old format without view states
      const oldState = {
        state: {
          flow: { nodes: [], edges: [] },
          notes: { notes: {} },
          / Missing view section
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(oldState));

      const store = createTestStore();
      const state = store.getState();

      / Should have default view state
      expect(state.view.currentView).toBe('daily');
      expect(state.view.viewConfigs).toBeDefined();
    });

    it('should handle version upgrades', () => {
      const v1State = {
        version: 1,
        state: {
          flow: { nodes: [] },
          notes: { notes: {} }
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(v1State));

      const store = createTestStore();
      const state = store.getState();

      / Should be migrated to current version
      expect(state.view).toBeDefined();
      expect(state.ui).toBeDefined();
    });
  });
});
```

#### 性能优化测试
```typescript
/ src/stores performance.test.ts
describe('State Performance TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Batch Updates', () => {
    it('should batch multiple updates', async () => {
      const renderSpy = jest.fn();

      / Subscribe to state changes
      store.subscribe(renderSpy);

      / Perform multiple rapid updates
      store.getState().addNode({ id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} });
      store.getState().addNode({ id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} });
      store.getState().addNode({ id: 'node-3', type: 'note', position: { x: 200, y: 200 }, data: {} });

      / Force batch flush
      store.getState().flushBatch?.();

      / Should only render once for the batch
      expect(renderSpy).toHaveBeenCalledTimes(1);

      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(3);
    });

    it('should debounce position updates', (done) => {
      const renderSpy = jest.fn();
      store.subscribe(renderSpy);

      / Simulate rapid position updates during drag
      for (let i = 0; i < 10; i++) {
        store.getState().updateNode('node-1', {
          position: { x: i * 10, y: i * 10 }
        });
      }

      / Should not render immediately
      setTimeout(() => {
        expect(renderSpy).not.toHaveBeenCalled();
      }, 50);

      / Should render after debounce delay
      setTimeout(() => {
        expect(renderSpy).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });
  });

  describe('Selector Optimization', () => {
    it('should memoize expensive selectors', () => {
      const notes = Array.from({ length: 1000 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `Content ${i}`,
        created_at: new Date(),
        updated_at: new Date(),
        tags: [`tag-${i % 10}`]
      }));

      store.setState({
        notes: {
          notes: notes.reduce((acc, note) => ({ ...acc, [note.id]: note }), {}),
          searchQuery: '',
          filterTags: [],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });

      const startTime = performance.now();
      const result1 = useFilteredNotes.getState();
      const endTime1 = performance.now();

      const startTime2 = performance.now();
      const result2 = useFilteredNotes.getState();
      const endTime2 = performance.now();

      / First call should be slower
      expect(endTime1 - startTime1).toBeGreaterThan(0);

      / Second call should be much faster (memoized)
      expect(endTime2 - startTime2).toBeLessThan(endTime1 - startTime1);

      / Results should be identical
      expect(result1).toEqual(result2);
    });
  });
});
```

### Zustand架构设计

#### TDD核心接口
```typescript
/ src/stores/AppStore.ts
interface AppState {
  flow: FlowState;
  notes: NotesState;
  view: ViewState;
  ui: UIState;
}

interface FlowState {
  nodes: FlowNode[];
  edges: FlowEdge[];
  selectedNodes: string[];
  selectedEdges: string[];
  viewport: ViewportState;
  isDragging: boolean;
  isConnecting: boolean;
  connectionSource: string | null;
}

interface NotesState {
  notes: Record<string, NoteRecord>;
  activeNoteId: string | null;
  editingNoteId: string | null;
  selectedNoteIds: string[];
  searchQuery: string;
  filterTags: string[];
  sortBy: 'date' | 'title' | 'tag' | 'custom';
  sortOrder: 'asc' | 'desc';
}

interface ViewState {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;
  viewStates: Record<ViewType, ViewStateData>;
  isTransitioning: boolean;
}
```

### TDD实现要点

#### Red阶段：失败的测试
- **状态管理测试**：节点、笔记、视图的CRUD操作
- **状态选择器测试**：各种选择器的正确性和性能
- **状态同步测试**：状态间依赖和数据一致性
- **持久化测试**：本地存储、数据恢复、迁移
- **性能优化测试**：批量更新、防抖、选择器缓存

#### Green阶段：最小实现
- **基础Store**：Zustand配置、状态结构
- **状态操作**：CRUD方法、状态更新逻辑
- **中间件集成**：持久化、性能优化、调试
- **选择器实现**：基础选择器和复合hooks

#### Refactor阶段：优化提升
- **性能优化**：中间件优化、选择器缓存
- **代码质量**：类型安全、错误处理
- **开发体验**：调试工具、状态检查

### 代码文件影响

#### TDD测试文件（优先级最高）
- `src/stores flowSlice.test.ts` - Flow状态管理测试
- `src/stores notesSlice.test.ts` - 笔记状态管理测试
- `src/stores viewSlice.test.ts` - 视图状态管理测试
- `src/hooks/store selectors.test.ts` - 状态选择器测试
- `src/stores persistence.test.ts` - 状态持久化测试
- `src/stores performance.test.ts` - 性能优化测试

#### 核心实现文件
- `src/stores/AppStore.ts` - 主状态store
- `src/stores/slices/flowSlice.ts` - Flow状态切片
- `src/stores/slices/notesSlice.ts` - 笔记状态切片
- `src/stores/slices/viewSlice.ts` - 视图状态切片
- `src/stores/middleware/` - 自定义中间件
- `src/hooks/store/` - 状态相关hooks

## Dependencies

- [ ] **任务008：TDD基础设施**完成，测试框架就位
- [ ] **任务003：Flow节点开发**完成，状态需求明确
- [ ] Zustand状态管理库
- [ ] Immer库（用于不可变更新）
- [ ] React DevTools集成

## Effort Estimate

- Size: M（包含较多状态逻辑和测试工作）
- Days: 2天
- Parallel: true

### 工作量分解
- **TDD测试编写**：0.8天（最重要，优先级最高）
- **功能实现**：0.8天（让测试通过）
- **重构优化**：0.3天（性能和代码质量）
- **集成验证**：0.1天（端到端测试）

## Definition of Done

- [ ] **TDD流程完整**：Red-Green-Refactor循环完整执行
- [ ] **状态管理**：所有状态切片功能完整
- [ ] **状态同步**：状态间依赖关系正确
- [ ] **持久化机制**：本地存储和数据恢复稳定
- [ ] **性能达标**：大量状态更新性能测试通过
- [ ] **代码质量**：测试覆盖率≥90%，通过所有检查
- [ ] **调试工具**：开发时状态检查工具可用