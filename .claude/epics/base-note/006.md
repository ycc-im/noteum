---
name: çŠ¶æ€ç®¡ç†ï¼šZustandç»Ÿä¸€çŠ¶æ€ç®¡ç†ï¼ˆTDDï¼‰
status: open
created: 2025-10-07T00:00:00Z
github: https://github.com/ycc-im/noteum/issues/133
depends_on: [008, 003]
parallel: true
conflicts_with: []
---

# Task: çŠ¶æ€ç®¡ç†ï¼šZustandç»Ÿä¸€çŠ¶æ€ç®¡ç†ï¼ˆTDDï¼‰

## Description

**é‡‡ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰æ–¹æ³•**é…ç½®ZustandçŠ¶æ€ç®¡ç†åº“ï¼Œå®ç°FlowçŠ¶æ€ã€ç¬”è®°çŠ¶æ€ã€è§†å›¾çŠ¶æ€çš„ç»Ÿä¸€ç®¡ç†ï¼Œå»ºç«‹é«˜æ•ˆçš„çŠ¶æ€åŒæ­¥æœºåˆ¶ï¼Œæ”¯æŒç»„ä»¶é—´çš„çŠ¶æ€å…±äº«å’Œå®æ—¶æ›´æ–°ï¼Œç¡®ä¿åº”ç”¨çŠ¶æ€çš„ä¸€è‡´æ€§å’Œå¯é¢„æµ‹æ€§ã€‚

**TDDå¼€å‘æµç¨‹**ï¼šä¸¥æ ¼éµå¾ªRed-Green-Refactorå¾ªç¯ï¼Œå…ˆä¸ºæ¯ä¸ªçŠ¶æ€ç®¡ç†åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½ï¼Œæœ€åä¼˜åŒ–æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚

## Acceptance Criteria

### ğŸ”´ TDDé˜¶æ®µï¼šæµ‹è¯•å…ˆè¡Œï¼ˆRedï¼‰
- [ ] **ç¼–å†™çŠ¶æ€ç®¡ç†æµ‹è¯•å¥—ä»¶**ï¼šå…ˆä¸ºæ‰€æœ‰çŠ¶æ€ç®¡ç†åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•
- [ ] **FlowçŠ¶æ€æµ‹è¯•**ï¼šèŠ‚ç‚¹å¢åˆ æ”¹æŸ¥ã€é€‰ä¸­çŠ¶æ€ã€æ‹–æ‹½çŠ¶æ€çš„æµ‹è¯•
- [ ] **ç¬”è®°çŠ¶æ€æµ‹è¯•**ï¼šCRUDæ“ä½œã€æœç´¢è¿‡æ»¤ã€æ’åºåŠŸèƒ½çš„æµ‹è¯•
- [ ] **è§†å›¾çŠ¶æ€æµ‹è¯•**ï¼šè§†å›¾åˆ‡æ¢ã€çŠ¶æ€æŒä¹…åŒ–ã€é…ç½®ç®¡ç†çš„æµ‹è¯•
- [ ] **çŠ¶æ€åŒæ­¥æµ‹è¯•**ï¼šçŠ¶æ€é—´ä¾èµ–ã€æ•°æ®ä¸€è‡´æ€§ã€å†²çªè§£å†³çš„æµ‹è¯•
- [ ] **æ€§èƒ½ä¼˜åŒ–æµ‹è¯•**ï¼šé˜²æŠ–ã€æ‰¹é‡æ›´æ–°ã€é€‰æ‹©å™¨ä¼˜åŒ–çš„æµ‹è¯•
- [ ] **æŒä¹…åŒ–æµ‹è¯•**ï¼šæœ¬åœ°å­˜å‚¨ã€æ•°æ®æ¢å¤ã€é”™è¯¯å¤„ç†çš„æµ‹è¯•

### ğŸŸ¢ å®ç°é˜¶æ®µï¼šåŠŸèƒ½å®ç°ï¼ˆGreenï¼‰
- [ ] é…ç½®ZustandçŠ¶æ€ç®¡ç†åº“ï¼Œé›†æˆåˆ°ç°æœ‰Reactåº”ç”¨ä¸­ï¼Œè®©TDDæµ‹è¯•é€šè¿‡
- [ ] å®ç°FlowçŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬å·¥ä½œæµçŠ¶æ€ã€èŠ‚ç‚¹ä½ç½®ã€è¿æ¥å…³ç³»
- [ ] å®ç°ç¬”è®°çŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬CRUDæ“ä½œã€é€‰ä¸­çŠ¶æ€ã€ç¼–è¾‘çŠ¶æ€
- [ ] å®ç°è§†å›¾çŠ¶æ€ç®¡ç†ï¼ŒåŒ…æ‹¬å½“å‰è§†å›¾ã€è§†å›¾é…ç½®ã€UIçŠ¶æ€
- [ ] å»ºç«‹çŠ¶æ€é—´çš„ä¾èµ–å…³ç³»å’ŒåŒæ­¥æœºåˆ¶
- [ ] å®ç°çŠ¶æ€æŒä¹…åŒ–ï¼Œæ”¯æŒæœ¬åœ°å­˜å‚¨å’Œäº‘ç«¯åŒæ­¥
- [ ] æ·»åŠ çŠ¶æ€è°ƒè¯•å·¥å…·å’Œå¼€å‘æ—¶çŠ¶æ€æ£€æŸ¥

### ğŸ”„ é‡æ„é˜¶æ®µï¼šä»£ç ä¼˜åŒ–ï¼ˆRefactorï¼‰
- [ ] **ä¼˜åŒ–çŠ¶æ€æ€§èƒ½**ï¼šåœ¨ä¿æŒæµ‹è¯•é€šè¿‡çš„å‰æä¸‹ä¼˜åŒ–çŠ¶æ€æ›´æ–°æ€§èƒ½
- [ ] **é‡æ„çŠ¶æ€ç»“æ„**ï¼šæå‡çŠ¶æ€ç»„ç»‡ç»“æ„çš„å¯ç»´æŠ¤æ€§
- [ ] **ä¼˜åŒ–ä¸­é—´ä»¶**ï¼šå‡å°‘ä¸­é—´ä»¶å¼€é”€ï¼Œæå‡å“åº”é€Ÿåº¦
- [ ] **TDDè´¨é‡éªŒè¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œæ‰€æœ‰æµ‹è¯•ç¨³å®šé€šè¿‡

## Technical Details

### TDDæµ‹è¯•è®¾è®¡

#### FlowçŠ¶æ€ç®¡ç†æµ‹è¯•
```typescript
/ src/stores flowSlice.test.ts
describe('Flow State Management TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Node Management', () => {
    it('should add node to flow state', () => {
      const node: FlowNode = {
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Test Note', content: 'Test content' }
      };

      store.getState().addNode(node);

      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(1);
      expect(state.flow.nodes[0]).toEqual(node);
    });

    it('should remove node and related edges', () => {
      / Setup: Add node and edges
      const node: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };
      const edge: FlowEdge = { id: 'edge-1', source: 'node-1', target: 'node-2' };

      store.getState().addNode(node);
      store.getState().addEdge(edge);

      / Action: Remove node
      store.getState().removeNode('node-1');

      / Assert: Node and edge should be removed
      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(0);
      expect(state.flow.edges).toHaveLength(0);
    });

    it('should update node properties', () => {
      const node: FlowNode = {
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Old Title' }
      };

      store.getState().addNode(node);
      store.getState().updateNode('node-1', {
        position: { x: 150, y: 250 },
        data: { title: 'New Title' }
      });

      const state = store.getState();
      const updatedNode = state.flow.nodes[0];
      expect(updatedNode.position).toEqual({ x: 150, y: 250 });
      expect(updatedNode.data.title).toBe('New Title');
    });
  });

  describe('Node Selection', () => {
    it('should select multiple nodes', () => {
      const nodes = [
        { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} },
        { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} }
      ];

      nodes.forEach(node => store.getState().addNode(node));
      store.getState().selectNodes(['node-1', 'node-2']);

      const state = store.getState();
      expect(state.flow.selectedNodes).toEqual(['node-1', 'node-2']);
    });

    it('should clear selection', () => {
      const node: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };

      store.getState().addNode(node);
      store.getState().selectNodes(['node-1']);
      store.getState().clearSelection();

      const state = store.getState();
      expect(state.flow.selectedNodes).toHaveLength(0);
    });
  });

  describe('Edge Management', () => {
    it('should add edge between nodes', () => {
      const sourceNode: FlowNode = { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} };
      const targetNode: FlowNode = { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} };
      const edge: FlowEdge = {
        id: 'edge-1',
        source: 'node-1',
        target: 'node-2',
        sourceHandle: 'output',
        targetHandle: 'input'
      };

      store.getState().addNode(sourceNode);
      store.getState().addNode(targetNode);
      store.getState().addEdge(edge);

      const state = store.getState();
      expect(state.flow.edges).toHaveLength(1);
      expect(state.flow.edges[0]).toEqual(edge);
    });

    it('should validate edge exists before adding', () => {
      const edge: FlowEdge = {
        id: 'edge-1',
        source: 'nonexistent',
        target: 'node-2',
        sourceHandle: 'output',
        targetHandle: 'input'
      };

      expect(() => {
        store.getState().addEdge(edge);
      }).toThrow('Cannot create edge: source node does not exist');
    });
  });
});
```

#### ç¬”è®°çŠ¶æ€ç®¡ç†æµ‹è¯•
```typescript
/ src/stores notesSlice.test.ts
describe('Notes State Management TDD', () => {
  let store: AppStore;
  let mockNoteService: jest.Mocked<NoteService>;

  beforeEach(() => {
    mockNoteService = createMockNoteService();
    store = createTestStore({ noteService: mockNoteService });
  });

  describe('Note CRUD Operations', () => {
    it('should create note and update state', async () => {
      const noteData: CreateNoteData = {
        title: 'Test Note',
        content: 'Test content'
      };

      mockNoteService.create.mockResolvedValue('note-1');

      const noteId = await store.getState().createNote(noteData);

      expect(noteId).toBe('note-1');
      expect(mockNoteService.create).toHaveBeenCalledWith(noteData);

      const state = store.getState();
      expect(state.notes.notes).toHaveProperty('note-1');
      expect(state.notes.notes['note-1']).toEqual(
        expect.objectContaining({
          id: 'note-1',
          title: 'Test Note',
          content: 'Test content',
          created_at: expect.any(Date),
          updated_at: expect.any(Date)
        })
      );
    });

    it('should handle note creation failure gracefully', async () => {
      const noteData: CreateNoteData = {
        title: 'Test Note',
        content: 'Test content'
      };

      mockNoteService.create.mockRejectedValue(new Error('Database error'));

      await expect(store.getState().createNote(noteData)).rejects.toThrow('Database error');

      const state = store.getState();
      expect(Object.keys(state.notes.notes)).toHaveLength(0);
    });

    it('should update note and sync with database', async () => {
      / Setup: Create note first
      const noteData: CreateNoteData = { title: 'Original Title', content: 'Original content' };
      mockNoteService.create.mockResolvedValue('note-1');
      await store.getState().createNote(noteData);

      / Update note
      const updates = { title: 'Updated Title', content: 'Updated content' };
      mockNoteService.update.mockResolvedValue(undefined);

      await store.getState().updateNote('note-1', updates);

      expect(mockNoteService.update).toHaveBeenCalledWith('note-1', updates);

      const state = store.getState();
      const updatedNote = state.notes.notes['note-1'];
      expect(updatedNote.title).toBe('Updated Title');
      expect(updatedNote.content).toBe('Updated content');
      expect(updatedNote.updated_at).not.toEqual(noteData.created_at);
    });

    it('should delete note and remove from state', async () => {
      / Setup: Create note first
      const noteData: CreateNoteData = { title: 'Test Note', content: 'Test content' };
      mockNoteService.create.mockResolvedValue('note-1');
      mockNoteService.delete.mockResolvedValue(undefined);
      await store.getState().createNote(noteData);

      / Delete note
      await store.getState().deleteNote('note-1');

      expect(mockNoteService.delete).toHaveBeenCalledWith('note-1');

      const state = store.getState();
      expect(state.notes.notes).not.toHaveProperty('note-1');
    });
  });

  describe('Note Selection and Editing', () => {
    it('should set active note', () => {
      const note: NoteRecord = {
        id: 'note-1',
        title: 'Test Note',
        content: 'Test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      store.setState({ notes: { notes: { 'note-1': note } } });
      store.getState().setActiveNote('note-1');

      const state = store.getState();
      expect(state.notes.activeNoteId).toBe('note-1');
    });

    it('should set editing note', () => {
      const note: NoteRecord = {
        id: 'note-1',
        title: 'Test Note',
        content: 'Test content',
        created_at: new Date(),
        updated_at: new Date()
      };

      store.setState({ notes: { notes: { 'note-1': note } } });
      store.getState().setEditingNote('note-1');

      const state = store.getState();
      expect(state.notes.editingNoteId).toBe('note-1');
    });

    it('should clear editing note when set to null', () => {
      store.setState({ notes: { editingNoteId: 'note-1' } });
      store.getState().setEditingNote(null);

      const state = store.getState();
      expect(state.notes.editingNoteId).toBeNull();
    });
  });

  describe('Note Filtering and Sorting', () => {
    beforeEach(() => {
      const notes: NoteRecord[] = [
        { id: 'note-1', title: 'Work Task', content: 'Important work', created_at: new Date('2025-01-15'), updated_at: new Date(), tags: ['work'] },
        { id: 'note-2', title: 'Personal Note', content: 'Personal reminder', created_at: new Date('2025-01-10'), updated_at: new Date(), tags: ['personal'] },
        { id: 'note-3', title: 'Work Meeting', content: 'Meeting notes', created_at: new Date('2025-01-20'), updated_at: new Date(), tags: ['work'] }
      ];

      store.setState({
        notes: {
          notes: notes.reduce((acc, note) => ({ ...acc, [note.id]: note }), {}),
          activeNoteId: null,
          editingNoteId: null,
          selectedNoteIds: [],
          searchQuery: '',
          filterTags: [],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });
    });

    it('should filter notes by search query', () => {
      store.getState().searchNotes('work');

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(2);
      expect(filteredNotes.every(note =>
        note.title.includes('work') || note.content.includes('work')
      )).toBe(true);
    });

    it('should filter notes by tags', () => {
      / Assume 'work' tag has id 'tag-1'
      store.getState().filterByTags(['tag-1']);

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(2);
      expect(filteredNotes.every(note => note.tags.includes('tag-1'))).toBe(true);
    });

    it('should sort notes by date', () => {
      store.getState().setSortOrder('created_at', 'asc');

      const sortedNotes = useFilteredNotes.getState();
      expect(sortedNotes[0].id).toBe('note-2'); / 2025-01-10
      expect(sortedNotes[1].id).toBe('note-1'); / 2025-01-15
      expect(sortedNotes[2].id).toBe('note-3'); / 2025-01-20
    });

    it('should sort notes by title', () => {
      store.getState().setSortOrder('title', 'asc');

      const sortedNotes = useFilteredNotes.getState();
      expect(sortedNotes[0].title).toBe('Personal Note');
      expect(sortedNotes[1].title).toBe('Work Meeting');
      expect(sortedNotes[2].title).toBe('Work Task');
    });
  });
});
```

#### è§†å›¾çŠ¶æ€ç®¡ç†æµ‹è¯•
```typescript
/ src/stores viewSlice.test.ts
describe('View State Management TDD', () => {
  let store: AppStore;
  let mockViewService: jest.Mocked<ViewService>;

  beforeEach(() => {
    mockViewService = createMockViewService();
    store = createTestStore({ viewService: mockViewService });
  });

  describe('View Switching', () => {
    it('should switch view and save current state', async () => {
      mockViewService.saveViewState.mockResolvedValue(undefined);
      mockViewService.restoreViewState.mockResolvedValue(undefined);

      store.setState({ view: { currentView: 'daily' } });
      await store.getState().switchView('tags');

      const state = store.getState();
      expect(state.view.currentView).toBe('tags');
      expect(state.view.isTransitioning).toBe(false);
      expect(mockViewService.saveViewState).toHaveBeenCalledWith('daily');
      expect(mockViewService.restoreViewState).toHaveBeenCalledWith('tags');
    });

    it('should handle view switching errors gracefully', async () => {
      mockViewService.saveViewState.mockRejectedValue(new Error('Save failed'));

      store.setState({ view: { currentView: 'daily' } });

      await expect(store.getState().switchView('tags')).rejects.toThrow('Save failed');

      const state = store.getState();
      expect(state.view.currentView).toBe('daily'); / Should remain unchanged
    });

    it('should not switch if same view', async () => {
      store.setState({ view: { currentView: 'daily' } });
      await store.getState().switchView('daily');

      expect(mockViewService.saveViewState).not.toHaveBeenCalled();
      expect(mockViewService.restoreViewState).not.toHaveBeenCalled();
    });
  });

  describe('View Configuration', () => {
    it('should update view config', () => {
      const configUpdate = {
        layout: 'grid',
        animation: { duration: 500, type: 'slide' }
      };

      store.getState().updateViewConfig('daily', configUpdate);

      const state = store.getState();
      expect(state.view.viewConfigs['daily']).toEqual(
        expect.objectContaining(configUpdate)
      );
    });

    it('should save view state', () => {
      const viewState = {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5
      };

      store.getState().saveViewState('daily', viewState);

      const state = store.getState();
      expect(state.view.viewStates['daily']).toEqual(
        expect.objectContaining(viewState)
      );
    });

    it('should restore view state', () => {
      const savedState = {
        scrollPosition: { x: 100, y: 200 },
        zoomLevel: 1.5
      };

      store.setState({
        view: {
          viewStates: { daily: savedState }
        }
      });

      store.getState().restoreViewState('daily');

      / Verify state restoration through getters or effects
      expect(mockViewService.applyViewState).toHaveBeenCalledWith(savedState);
    });
  });

  describe('View Transition States', () => {
    it('should set transitioning state during view switch', async () => {
      mockViewService.saveViewState.mockImplementation(() =>
        new Promise(resolve => setTimeout(resolve, 100))
      );

      store.setState({ view: { currentView: 'daily' } });

      const switchPromise = store.getState().switchView('tags');

      / Check intermediate state
      let state = store.getState();
      expect(state.view.isTransitioning).toBe(true);

      await switchPromise;

      / Check final state
      state = store.getState();
      expect(state.view.isTransitioning).toBe(false);
      expect(state.view.currentView).toBe('tags');
    });
  });
});
```

#### çŠ¶æ€é€‰æ‹©å™¨æµ‹è¯•
```typescript
/ src/hooks/store selectors.test.ts
describe('State Selectors TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Flow Selectors', () => {
    it('should select flow nodes', () => {
      const nodes: FlowNode[] = [
        { id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} },
        { id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} }
      ];

      store.setState({ flow: { nodes } });

      const selectedNodes = useFlowNodes.getState();
      expect(selectedNodes).toEqual(nodes);
    });

    it('should select selected nodes', () => {
      store.setState({ flow: { selectedNodes: ['node-1', 'node-2'] } });

      const selectedNodeIds = useSelectedNodes.getState();
      expect(selectedNodeIds).toEqual(['node-1', 'node-2']);
    });

    it('should select flow viewport', () => {
      const viewport = { x: 100, y: 200, zoom: 1.5 };
      store.setState({ flow: { viewport } });

      const selectedViewport = useFlowViewport.getState();
      expect(selectedViewport).toEqual(viewport);
    });
  });

  describe('Notes Selectors', () => {
    it('should select notes as array', () => {
      const notes: Record<string, NoteRecord> = {
        'note-1': { id: 'note-1', title: 'Note 1', content: 'Content 1', created_at: new Date(), updated_at: new Date() },
        'note-2': { id: 'note-2', title: 'Note 2', content: 'Content 2', created_at: new Date(), updated_at: new Date() }
      };

      store.setState({ notes: { notes } });

      const selectedNotes = useNotes.getState();
      expect(selectedNotes).toHaveLength(2);
      expect(selectedNotes[0].id).toBe('note-1');
      expect(selectedNotes[1].id).toBe('note-2');
    });

    it('should select active note', () => {
      const note: NoteRecord = { id: 'note-1', title: 'Active Note', content: 'Content', created_at: new Date(), updated_at: new Date() };

      store.setState({
        notes: {
          notes: { 'note-1': note },
          activeNoteId: 'note-1'
        }
      });

      const activeNote = useActiveNote.getState();
      expect(activeNote).toEqual(note);
    });

    it('should return null for active note when none selected', () => {
      store.setState({ notes: { activeNoteId: null } });

      const activeNote = useActiveNote.getState();
      expect(activeNote).toBeNull();
    });

    it('should filter and sort notes correctly', () => {
      const notes: Record<string, NoteRecord> = {
        'note-1': { id: 'note-1', title: 'Work Task', content: 'Important work', created_at: new Date('2025-01-15'), updated_at: new Date(), tags: ['work'] },
        'note-2': { id: 'note-2', title: 'Personal Note', content: 'Personal reminder', created_at: new Date('2025-01-10'), updated_at: new Date(), tags: ['personal'] }
      };

      store.setState({
        notes: {
          notes,
          searchQuery: 'work',
          filterTags: ['work'],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });

      const filteredNotes = useFilteredNotes.getState();
      expect(filteredNotes).toHaveLength(1);
      expect(filteredNotes[0].id).toBe('note-1');
    });
  });

  describe('View Selectors', () => {
    it('should select current view', () => {
      store.setState({ view: { currentView: 'daily' } });

      const currentView = useCurrentView.getState();
      expect(currentView).toBe('daily');
    });

    it('should select view config by type', () => {
      const configs: Record<ViewType, ViewConfig> = {
        daily: { id: 'daily', name: 'Daily View', layout: 'timeline', sorting: 'date', animation: {}, interactions: {} },
        tags: { id: 'tags', name: 'Tags View', layout: 'grid', sorting: 'tag', animation: {}, interactions: {} }
      };

      store.setState({ view: { viewConfigs: configs } });

      const dailyConfig = useViewConfig('daily').getState();
      expect(dailyConfig.layout).toBe('timeline');
      expect(dailyConfig.name).toBe('Daily View');
    });
  });
});
```

#### çŠ¶æ€æŒä¹…åŒ–æµ‹è¯•
```typescript
/ src/stores persistence.test.ts
describe('State Persistence TDD', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('Local Storage Persistence', () => {
    it('should persist state to localStorage', () => {
      const store = createTestStore();

      / Update some state
      store.getState().addNode({
        id: 'node-1',
        type: 'note',
        position: { x: 100, y: 200 },
        data: { title: 'Test Note' }
      });

      / Force persistence
      store.getState().flushBatch?.();

      const storedData = localStorage.getItem('noteum-app-state');
      expect(storedData).toBeTruthy();

      const parsedData = JSON.parse(storedData);
      expect(parsedData.state.flow.nodes).toHaveLength(1);
      expect(parsedData.state.flow.nodes[0].id).toBe('node-1');
    });

    it('should restore state from localStorage', () => {
      / Pre-populate localStorage
      const initialState = {
        state: {
          flow: {
            nodes: [{ id: 'node-1', type: 'note', position: { x: 100, y: 200 }, data: {} }],
            edges: [],
            selectedNodes: [],
            selectedEdges: [],
            viewport: { x: 0, y: 0, zoom: 1 }
          },
          notes: {
            notes: {},
            activeNoteId: null,
            editingNoteId: null,
            selectedNoteIds: [],
            searchQuery: '',
            filterTags: [],
            sortBy: 'created_at',
            sortOrder: 'desc'
          },
          view: {
            currentView: 'daily',
            viewConfigs: {},
            viewStates: {},
            isTransitioning: false
          }
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(initialState));

      const store = createTestStore();
      const state = store.getState();

      expect(state.flow.nodes).toHaveLength(1);
      expect(state.flow.nodes[0].id).toBe('node-1');
      expect(state.view.currentView).toBe('daily');
    });

    it('should handle corrupted localStorage gracefully', () => {
      localStorage.setItem('noteum-app-state', 'invalid json');

      expect(() => {
        createTestStore();
      }).not.toThrow();

      const store = createTestStore();
      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(0); / Should default to empty state
    });
  });

  describe('State Migration', () => {
    it('should migrate old state format to new format', () => {
      / Old format without view states
      const oldState = {
        state: {
          flow: { nodes: [], edges: [] },
          notes: { notes: {} },
          / Missing view section
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(oldState));

      const store = createTestStore();
      const state = store.getState();

      / Should have default view state
      expect(state.view.currentView).toBe('daily');
      expect(state.view.viewConfigs).toBeDefined();
    });

    it('should handle version upgrades', () => {
      const v1State = {
        version: 1,
        state: {
          flow: { nodes: [] },
          notes: { notes: {} }
        }
      };

      localStorage.setItem('noteum-app-state', JSON.stringify(v1State));

      const store = createTestStore();
      const state = store.getState();

      / Should be migrated to current version
      expect(state.view).toBeDefined();
      expect(state.ui).toBeDefined();
    });
  });
});
```

#### æ€§èƒ½ä¼˜åŒ–æµ‹è¯•
```typescript
/ src/stores performance.test.ts
describe('State Performance TDD', () => {
  let store: AppStore;

  beforeEach(() => {
    store = createTestStore();
  });

  describe('Batch Updates', () => {
    it('should batch multiple updates', async () => {
      const renderSpy = jest.fn();

      / Subscribe to state changes
      store.subscribe(renderSpy);

      / Perform multiple rapid updates
      store.getState().addNode({ id: 'node-1', type: 'note', position: { x: 0, y: 0 }, data: {} });
      store.getState().addNode({ id: 'node-2', type: 'note', position: { x: 100, y: 100 }, data: {} });
      store.getState().addNode({ id: 'node-3', type: 'note', position: { x: 200, y: 200 }, data: {} });

      / Force batch flush
      store.getState().flushBatch?.();

      / Should only render once for the batch
      expect(renderSpy).toHaveBeenCalledTimes(1);

      const state = store.getState();
      expect(state.flow.nodes).toHaveLength(3);
    });

    it('should debounce position updates', (done) => {
      const renderSpy = jest.fn();
      store.subscribe(renderSpy);

      / Simulate rapid position updates during drag
      for (let i = 0; i < 10; i++) {
        store.getState().updateNode('node-1', {
          position: { x: i * 10, y: i * 10 }
        });
      }

      / Should not render immediately
      setTimeout(() => {
        expect(renderSpy).not.toHaveBeenCalled();
      }, 50);

      / Should render after debounce delay
      setTimeout(() => {
        expect(renderSpy).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });
  });

  describe('Selector Optimization', () => {
    it('should memoize expensive selectors', () => {
      const notes = Array.from({ length: 1000 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `Content ${i}`,
        created_at: new Date(),
        updated_at: new Date(),
        tags: [`tag-${i % 10}`]
      }));

      store.setState({
        notes: {
          notes: notes.reduce((acc, note) => ({ ...acc, [note.id]: note }), {}),
          searchQuery: '',
          filterTags: [],
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      });

      const startTime = performance.now();
      const result1 = useFilteredNotes.getState();
      const endTime1 = performance.now();

      const startTime2 = performance.now();
      const result2 = useFilteredNotes.getState();
      const endTime2 = performance.now();

      / First call should be slower
      expect(endTime1 - startTime1).toBeGreaterThan(0);

      / Second call should be much faster (memoized)
      expect(endTime2 - startTime2).toBeLessThan(endTime1 - startTime1);

      / Results should be identical
      expect(result1).toEqual(result2);
    });
  });
});
```

### Zustandæ¶æ„è®¾è®¡

#### TDDæ ¸å¿ƒæ¥å£
```typescript
/ src/stores/AppStore.ts
interface AppState {
  flow: FlowState;
  notes: NotesState;
  view: ViewState;
  ui: UIState;
}

interface FlowState {
  nodes: FlowNode[];
  edges: FlowEdge[];
  selectedNodes: string[];
  selectedEdges: string[];
  viewport: ViewportState;
  isDragging: boolean;
  isConnecting: boolean;
  connectionSource: string | null;
}

interface NotesState {
  notes: Record<string, NoteRecord>;
  activeNoteId: string | null;
  editingNoteId: string | null;
  selectedNoteIds: string[];
  searchQuery: string;
  filterTags: string[];
  sortBy: 'date' | 'title' | 'tag' | 'custom';
  sortOrder: 'asc' | 'desc';
}

interface ViewState {
  currentView: ViewType;
  viewConfigs: Record<ViewType, ViewConfig>;
  viewStates: Record<ViewType, ViewStateData>;
  isTransitioning: boolean;
}
```

### TDDå®ç°è¦ç‚¹

#### Redé˜¶æ®µï¼šå¤±è´¥çš„æµ‹è¯•
- **çŠ¶æ€ç®¡ç†æµ‹è¯•**ï¼šèŠ‚ç‚¹ã€ç¬”è®°ã€è§†å›¾çš„CRUDæ“ä½œ
- **çŠ¶æ€é€‰æ‹©å™¨æµ‹è¯•**ï¼šå„ç§é€‰æ‹©å™¨çš„æ­£ç¡®æ€§å’Œæ€§èƒ½
- **çŠ¶æ€åŒæ­¥æµ‹è¯•**ï¼šçŠ¶æ€é—´ä¾èµ–å’Œæ•°æ®ä¸€è‡´æ€§
- **æŒä¹…åŒ–æµ‹è¯•**ï¼šæœ¬åœ°å­˜å‚¨ã€æ•°æ®æ¢å¤ã€è¿ç§»
- **æ€§èƒ½ä¼˜åŒ–æµ‹è¯•**ï¼šæ‰¹é‡æ›´æ–°ã€é˜²æŠ–ã€é€‰æ‹©å™¨ç¼“å­˜

#### Greené˜¶æ®µï¼šæœ€å°å®ç°
- **åŸºç¡€Store**ï¼šZustandé…ç½®ã€çŠ¶æ€ç»“æ„
- **çŠ¶æ€æ“ä½œ**ï¼šCRUDæ–¹æ³•ã€çŠ¶æ€æ›´æ–°é€»è¾‘
- **ä¸­é—´ä»¶é›†æˆ**ï¼šæŒä¹…åŒ–ã€æ€§èƒ½ä¼˜åŒ–ã€è°ƒè¯•
- **é€‰æ‹©å™¨å®ç°**ï¼šåŸºç¡€é€‰æ‹©å™¨å’Œå¤åˆhooks

#### Refactoré˜¶æ®µï¼šä¼˜åŒ–æå‡
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¸­é—´ä»¶ä¼˜åŒ–ã€é€‰æ‹©å™¨ç¼“å­˜
- **ä»£ç è´¨é‡**ï¼šç±»å‹å®‰å…¨ã€é”™è¯¯å¤„ç†
- **å¼€å‘ä½“éªŒ**ï¼šè°ƒè¯•å·¥å…·ã€çŠ¶æ€æ£€æŸ¥

### ä»£ç æ–‡ä»¶å½±å“

#### TDDæµ‹è¯•æ–‡ä»¶ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
- `src/stores flowSlice.test.ts` - FlowçŠ¶æ€ç®¡ç†æµ‹è¯•
- `src/stores notesSlice.test.ts` - ç¬”è®°çŠ¶æ€ç®¡ç†æµ‹è¯•
- `src/stores viewSlice.test.ts` - è§†å›¾çŠ¶æ€ç®¡ç†æµ‹è¯•
- `src/hooks/store selectors.test.ts` - çŠ¶æ€é€‰æ‹©å™¨æµ‹è¯•
- `src/stores persistence.test.ts` - çŠ¶æ€æŒä¹…åŒ–æµ‹è¯•
- `src/stores performance.test.ts` - æ€§èƒ½ä¼˜åŒ–æµ‹è¯•

#### æ ¸å¿ƒå®ç°æ–‡ä»¶
- `src/stores/AppStore.ts` - ä¸»çŠ¶æ€store
- `src/stores/slices/flowSlice.ts` - FlowçŠ¶æ€åˆ‡ç‰‡
- `src/stores/slices/notesSlice.ts` - ç¬”è®°çŠ¶æ€åˆ‡ç‰‡
- `src/stores/slices/viewSlice.ts` - è§†å›¾çŠ¶æ€åˆ‡ç‰‡
- `src/stores/middleware/` - è‡ªå®šä¹‰ä¸­é—´ä»¶
- `src/hooks/store/` - çŠ¶æ€ç›¸å…³hooks

## Dependencies

- [ ] **ä»»åŠ¡008ï¼šTDDåŸºç¡€è®¾æ–½**å®Œæˆï¼Œæµ‹è¯•æ¡†æ¶å°±ä½
- [ ] **ä»»åŠ¡003ï¼šFlowèŠ‚ç‚¹å¼€å‘**å®Œæˆï¼ŒçŠ¶æ€éœ€æ±‚æ˜ç¡®
- [ ] ZustandçŠ¶æ€ç®¡ç†åº“
- [ ] Immeråº“ï¼ˆç”¨äºä¸å¯å˜æ›´æ–°ï¼‰
- [ ] React DevToolsé›†æˆ

## Effort Estimate

- Size: Mï¼ˆåŒ…å«è¾ƒå¤šçŠ¶æ€é€»è¾‘å’Œæµ‹è¯•å·¥ä½œï¼‰
- Days: 2å¤©
- Parallel: true

### å·¥ä½œé‡åˆ†è§£
- **TDDæµ‹è¯•ç¼–å†™**ï¼š0.8å¤©ï¼ˆæœ€é‡è¦ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
- **åŠŸèƒ½å®ç°**ï¼š0.8å¤©ï¼ˆè®©æµ‹è¯•é€šè¿‡ï¼‰
- **é‡æ„ä¼˜åŒ–**ï¼š0.3å¤©ï¼ˆæ€§èƒ½å’Œä»£ç è´¨é‡ï¼‰
- **é›†æˆéªŒè¯**ï¼š0.1å¤©ï¼ˆç«¯åˆ°ç«¯æµ‹è¯•ï¼‰

## Definition of Done

- [ ] **TDDæµç¨‹å®Œæ•´**ï¼šRed-Green-Refactorå¾ªç¯å®Œæ•´æ‰§è¡Œ
- [ ] **çŠ¶æ€ç®¡ç†**ï¼šæ‰€æœ‰çŠ¶æ€åˆ‡ç‰‡åŠŸèƒ½å®Œæ•´
- [ ] **çŠ¶æ€åŒæ­¥**ï¼šçŠ¶æ€é—´ä¾èµ–å…³ç³»æ­£ç¡®
- [ ] **æŒä¹…åŒ–æœºåˆ¶**ï¼šæœ¬åœ°å­˜å‚¨å’Œæ•°æ®æ¢å¤ç¨³å®š
- [ ] **æ€§èƒ½è¾¾æ ‡**ï¼šå¤§é‡çŠ¶æ€æ›´æ–°æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] **ä»£ç è´¨é‡**ï¼šæµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œé€šè¿‡æ‰€æœ‰æ£€æŸ¥
- [ ] **è°ƒè¯•å·¥å…·**ï¼šå¼€å‘æ—¶çŠ¶æ€æ£€æŸ¥å·¥å…·å¯ç”¨