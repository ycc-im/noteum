---
name: 性能优化：虚拟化和懒加载
status: open
created: 2025-10-07T00:00:00Z
github: [待创建GitHub Issue]
depends_on: [005, 006]
parallel: true
conflicts_with: []
---

# Task: 性能优化：虚拟化和懒加载

## Description

实现节点虚拟化和懒加载机制，优化位置缓存系统，添加防抖处理和批量更新，确保在大量笔记情况下的流畅性能表现，提升用户体验和响应速度。

## Acceptance Criteria

- [ ] 实现Flow节点的虚拟化渲染，支持大量节点的高效显示
- [ ] 实现笔记列表的虚拟滚动，优化长列表性能
- [ ] 开发懒加载机制，按需加载笔记内容和标签数据
- [ ] 优化位置缓存机制，减少重复计算和内存占用
- [ ] 添加防抖处理，优化频繁更新场景的性能
- [ ] 实现批量更新机制，减少状态变更次数
- [ ] 优化动画性能，使用transform和will-change属性
- [ ] 实现内存管理，及时清理不需要的数据
- [ ] 添加性能监控和分析工具
- [ ] 编写性能优化的测试和基准测试

## Technical Details

### 虚拟化渲染系统

#### Flow节点虚拟化
```typescript
interface VirtualizationConfig {
  containerSize: Dimensions;
  itemSize: { width: number; height: number };
  overscan: number; // 预渲染数量
  bufferSize: number; // 缓冲区大小
}

class FlowVirtualizer {
  private config: VirtualizationConfig;
  private visibleRange: { start: number; end: number };
  private containerRef: React.RefObject<HTMLElement>;

  constructor(config: VirtualizationConfig) {
    this.config = config;
    this.visibleRange = { start: 0, end: 0 };
  }

  // 计算可见节点范围
  calculateVisibleRange(scrollOffset: { x: number; y: number }): Range {
    const { containerSize, itemSize, overscan } = this.config;

    const startRow = Math.max(0, Math.floor(scrollOffset.y / itemSize.height) - overscan);
    const endRow = Math.min(
      Math.ceil((scrollOffset.y + containerSize.height) / itemSize.height) + overscan,
      this.totalItems
    );

    return {
      start: startRow,
      end: endRow
    };
  }

  // 渲染虚拟化节点
  renderVirtualizedNodes(nodes: FlowNode[], scrollOffset: { x: number; y: number }) {
    const visibleRange = this.calculateVisibleRange(scrollOffset);
    const visibleNodes = nodes.slice(visibleRange.start, visibleRange.end);

    return (
      <VirtualizedContainer>
        {/* 占位容器，确保滚动条正确 */}
        <PlaceholderContainer
          width={this.config.containerSize.width}
          height={nodes.length * this.config.itemSize.height}
        />

        {/* 可见节点容器 */}
        <VisibleNodesContainer
          style={{
            transform: `translateY(${visibleRange.start * this.config.itemSize.height}px)`
          }}
        >
          {visibleNodes.map((node, index) => (
            <VirtualizedNode
              key={node.id}
              node={node}
              index={visibleRange.start + index}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: this.config.itemSize.width,
                height: this.config.itemSize.height,
                transform: `translate(${node.x}px, ${node.y}px)`,
                willChange: 'transform'
              }}
            />
          ))}
        </VisibleNodesContainer>
      </VirtualizedContainer>
    );
  }
}
```

#### 笔记列表虚拟滚动
```typescript
interface VirtualScrollConfig {
  itemHeight: number | ((index: number) => number);
  overscan: number;
  estimatedItemHeight: number;
}

class NotesVirtualScroller {
  private config: VirtualScrollConfig;
  private itemHeights: Map<number, number> = new Map();
  private scrollTop = 0;
  private containerHeight = 0;

  constructor(config: VirtualScrollConfig) {
    this.config = config;
  }

  // 动态计算项目高度
  getItemHeight(index: number): number {
    if (this.itemHeights.has(index)) {
      return this.itemHeights.get(index)!;
    }

    const height = typeof this.config.itemHeight === 'function'
      ? this.config.itemHeight(index)
      : this.config.itemHeight;

    this.itemHeights.set(index, height);
    return height;
  }

  // 计算总高度
  getTotalHeight(itemsCount: number): number {
    let totalHeight = 0;
    for (let i = 0; i < itemsCount; i++) {
      totalHeight += this.getItemHeight(i);
    }
    return totalHeight;
  }

  // 计算可见项目范围
  getVisibleRange(itemsCount: number): Range {
    let accumulatedHeight = 0;
    let startIndex = 0;
    let endIndex = 0;

    // 找到开始索引
    for (let i = 0; i < itemsCount; i++) {
      const itemHeight = this.getItemHeight(i);
      if (accumulatedHeight + itemHeight > this.scrollTop) {
        startIndex = Math.max(0, i - this.config.overscan);
        break;
      }
      accumulatedHeight += itemHeight;
    }

    // 找到结束索引
    accumulatedHeight = 0;
    for (let i = 0; i < itemsCount; i++) {
      accumulatedHeight += this.getItemHeight(i);
      if (accumulatedHeight > this.scrollTop + this.containerHeight) {
        endIndex = Math.min(itemsCount - 1, i + this.config.overscan);
        break;
      }
    }

    return { start: startIndex, end: endIndex };
  }

  // 渲染虚拟滚动列表
  renderVirtualizedList(notes: NoteRecord[], containerHeight: number) {
    this.containerHeight = containerHeight;
    const totalHeight = this.getTotalHeight(notes.length);
    const visibleRange = this.getVisibleRange(notes.length);

    let offsetY = 0;
    for (let i = 0; i < visibleRange.start; i++) {
      offsetY += this.getItemHeight(i);
    }

    return (
      <VirtualScrollContainer>
        {/* 总高度占位符 */}
        <TotalHeightPlaceholder height={totalHeight} />

        {/* 可见项目容器 */}
        <VisibleItemsContainer style={{ transform: `translateY(${offsetY}px)` }}>
          {notes.slice(visibleRange.start, visibleRange.end + 1).map((note, index) => {
            const actualIndex = visibleRange.start + index;
            const height = this.getItemHeight(actualIndex);

            return (
              <VirtualizedNoteItem
                key={note.id}
                note={note}
                index={actualIndex}
                height={height}
                onHeightChange={(newHeight) => {
                  this.itemHeights.set(actualIndex, newHeight);
                }}
              />
            );
          })}
        </VisibleItemsContainer>
      </VirtualScrollContainer>
    );
  }
}
```

### 懒加载机制

#### 数据懒加载
```typescript
interface LazyLoadConfig {
  threshold: number; // 触发加载的距离阈值
  batchSize: number; // 每次加载的数量
  preloadCount: number; // 预加载数量
}

class DataLazyLoader {
  private config: LazyLoadConfig;
  private loadedPages: Set<number> = new Set();
  private loadingPages: Set<number> = new Set();

  constructor(config: LazyLoadConfig) {
    this.config = config;
  }

  // 检查是否需要加载更多数据
  shouldLoadMore(currentIndex: number, totalItems: number): boolean {
    const threshold = totalItems - currentIndex - this.config.threshold;
    return threshold <= 0 && !this.isLoading();
  }

  // 加载指定页面数据
  async loadPage(pageIndex: number, loader: (page: number, size: number) => Promise<NoteRecord[]>) {
    if (this.loadedPages.has(pageIndex) || this.loadingPages.has(pageIndex)) {
      return [];
    }

    this.loadingPages.add(pageIndex);

    try {
      const items = await loader(pageIndex, this.config.batchSize);
      this.loadedPages.add(pageIndex);
      return items;
    } finally {
      this.loadingPages.delete(pageIndex);
    }
  }

  // 预加载下一页
  async preloadNextPage(currentPage: number, loader: (page: number, size: number) => Promise<NoteRecord[]>) {
    const nextPage = currentPage + 1;
    if (!this.loadedPages.has(nextPage) && !this.loadingPages.has(nextPage)) {
      // 延迟预加载，避免影响当前页面性能
      setTimeout(() => {
        this.loadPage(nextPage, loader);
      }, 100);
    }
  }

  private isLoading(): boolean {
    return this.loadingPages.size > 0;
  }
}
```

#### 图片和媒体懒加载
```typescript
class MediaLazyLoader {
  private observer: IntersectionObserver;
  private loadedImages: Set<string> = new Set();

  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: '50px', // 提前50px开始加载
        threshold: 0.1
      }
    );
  }

  // 注册需要懒加载的图片
  observeImage(imageElement: HTMLImageElement, src: string) {
    if (this.loadedImages.has(src)) {
      imageElement.src = src;
      return;
    }

    imageElement.dataset.src = src;
    this.observer.observe(imageElement);
  }

  private handleIntersection(entries: IntersectionObserverEntry[]) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        const src = img.dataset.src;

        if (src && !this.loadedImages.has(src)) {
          this.loadImage(img, src);
          this.observer.unobserve(img);
        }
      }
    });
  }

  private loadImage(img: HTMLImageElement, src: string) {
    // 使用临时图片预加载
    const tempImg = new Image();
    tempImg.onload = () => {
      img.src = src;
      this.loadedImages.add(src);
      img.classList.add('loaded');
    };
    tempImg.onerror = () => {
      img.classList.add('error');
    };
    tempImg.src = src;
  }
}
```

### 位置缓存优化

#### 智能位置缓存
```typescript
interface PositionCache {
  positions: Map<string, CachedPosition>;
  dirty: Set<string>;
  maxSize: number;
  ttl: number; // 缓存生存时间
}

interface CachedPosition {
  x: number;
  y: number;
  timestamp: number;
  view: ViewType;
  dirty: boolean;
}

class OptimizedPositionCache {
  private cache: PositionCache;
  private cleanupInterval: NodeJS.Timeout;

  constructor(maxSize = 1000, ttl = 300000) { // 5分钟TTL
    this.cache = {
      positions: new Map(),
      dirty: new Set(),
      maxSize,
      ttl
    };

    // 定期清理过期缓存
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 60000); // 每分钟清理一次
  }

  // 获取缓存位置
  getPosition(key: string, view: ViewType): CachedPosition | null {
    const cached = this.cache.positions.get(key);
    if (!cached) return null;

    // 检查是否过期
    if (Date.now() - cached.timestamp > this.cache.ttl) {
      this.cache.positions.delete(key);
      return null;
    }

    // 检查视图是否匹配
    if (cached.view !== view) {
      return null;
    }

    return cached;
  }

  // 设置缓存位置
  setPosition(key: string, position: { x: number; y: number }, view: ViewType) {
    const cached: CachedPosition = {
      ...position,
      timestamp: Date.now(),
      view,
      dirty: false
    };

    // 如果缓存已满，删除最旧的条目
    if (this.cache.positions.size >= this.cache.maxSize) {
      const oldestKey = this.findOldestKey();
      if (oldestKey) {
        this.cache.positions.delete(oldestKey);
      }
    }

    this.cache.positions.set(key, cached);
  }

  // 批量更新位置
  batchUpdatePositions(updates: Array<{ key: string; position: { x: number; y: number }; view: ViewType }>) {
    updates.forEach(({ key, position, view }) => {
      this.setPosition(key, position, view);
    });
  }

  // 标记为脏数据
  markDirty(key: string) {
    this.cache.dirty.add(key);
    const cached = this.cache.positions.get(key);
    if (cached) {
      cached.dirty = true;
    }
  }

  // 清理脏数据
  flushDirty() {
    this.cache.dirty.forEach(key => {
      const cached = this.cache.positions.get(key);
      if (cached && cached.dirty) {
        // 持久化到数据库
        this.persistPosition(key, cached);
        cached.dirty = false;
      }
    });
    this.cache.dirty.clear();
  }

  private cleanup() {
    const now = Date.now();
    const toDelete: string[] = [];

    this.cache.positions.forEach((cached, key) => {
      if (now - cached.timestamp > this.cache.ttl) {
        toDelete.push(key);
      }
    });

    toDelete.forEach(key => this.cache.positions.delete(key));
  }

  private findOldestKey(): string | null {
    let oldestKey: string | null = null;
    let oldestTime = Date.now();

    this.cache.positions.forEach((cached, key) => {
      if (cached.timestamp < oldestTime) {
        oldestTime = cached.timestamp;
        oldestKey = key;
      }
    });

    return oldestKey;
  }

  private async persistPosition(key: string, cached: CachedPosition) {
    try {
      await positionService.update(key, {
        x: cached.x,
        y: cached.y,
        view: cached.view
      });
    } catch (error) {
      console.error('Failed to persist position:', error);
    }
  }

  destroy() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
  }
}
```

### 防抖和批量处理

#### 防抖优化
```typescript
class PerformanceOptimizer {
  private debounceTimers: Map<string, NodeJS.Timeout> = new Map();
  private batchQueue: Map<string, Function[]> = new Map();
  private animationFrameId: number | null = null;

  // 防抖函数
  debounce<T extends (...args: any[]) => any>(
    key: string,
    fn: T,
    delay: number
  ): (...args: Parameters<T>) => void {
    return (...args: Parameters<T>) => {
      const existingTimer = this.debounceTimers.get(key);
      if (existingTimer) {
        clearTimeout(existingTimer);
      }

      const timer = setTimeout(() => {
        fn(...args);
        this.debounceTimers.delete(key);
      }, delay);

      this.debounceTimers.set(key, timer);
    };
  }

  // 节流函数
  throttle<T extends (...args: any[]) => any>(
    key: string,
    fn: T,
    interval: number
  ): (...args: Parameters<T>) => void {
    let lastExecution = 0;

    return (...args: Parameters<T>) => {
      const now = Date.now();
      if (now - lastExecution >= interval) {
        fn(...args);
        lastExecution = now;
      }
    };
  }

  // 批量处理
  batch(key: string, fn: Function) {
    if (!this.batchQueue.has(key)) {
      this.batchQueue.set(key, []);
    }

    this.batchQueue.get(key)!.push(fn);

    // 在下一个动画帧中执行
    if (!this.animationFrameId) {
      this.animationFrameId = requestAnimationFrame(() => {
        this.flushBatch();
      });
    }
  }

  private flushBatch() {
    this.batchQueue.forEach((functions, key) => {
      // 批量执行所有函数
      functions.forEach(fn => fn());
    });

    this.batchQueue.clear();
    this.animationFrameId = null;
  }
}
```

### 性能监控

#### 性能分析工具
```typescript
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map();

  // 开始测量
  startMeasure(name: string) {
    performance.mark(`${name}-start`);
  }

  // 结束测量
  endMeasure(name: string) {
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);

    const measure = performance.getEntriesByName(name).pop();
    if (measure) {
      this.recordMetric(name, measure.duration);
    }
  }

  // 记录指标
  private recordMetric(name: string, duration: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push({
      timestamp: Date.now(),
      duration,
      type: 'custom'
    });

    // 保持最近100个指标
    if (metrics.length > 100) {
      metrics.shift();
    }
  }

  // 获取性能统计
  getStats(name: string) {
    const metrics = this.metrics.get(name) || [];
    if (metrics.length === 0) return null;

    const durations = metrics.map(m => m.duration);
    const avg = durations.reduce((sum, d) => sum + d, 0) / durations.length;
    const min = Math.min(...durations);
    const max = Math.max(...durations);

    return {
      count: metrics.length,
      average: avg,
      min,
      max,
      recent: metrics.slice(-10)
    };
  }

  // 生成性能报告
  generateReport() {
    const report: PerformanceReport = {
      timestamp: Date.now(),
      metrics: {}
    };

    this.metrics.forEach((metrics, name) => {
      report.metrics[name] = this.getStats(name)!;
    });

    return report;
  }
}

// React Hook for performance monitoring
export const usePerformanceMonitor = (componentName: string) => {
  const monitor = useMemo(() => new PerformanceMonitor(), []);

  useEffect(() => {
    monitor.startMeasure(`${componentName}-render`);
    return () => {
      monitor.endMeasure(`${componentName}-render`);
    };
  });

  return monitor;
};
```

### 代码文件影响

- `src/performance/virtualization/FlowVirtualizer.tsx` - Flow虚拟化组件
- `src/performance/virtualization/NotesVirtualScroller.tsx` - 笔记虚拟滚动
- `src/performance/lazyload/DataLazyLoader.ts` - 数据懒加载
- `src/performance/lazyload/MediaLazyLoader.ts` - 媒体懒加载
- `src/performance/cache/PositionCache.ts` - 位置缓存优化
- `src/performance/optimizer/PerformanceOptimizer.ts` - 性能优化器
- `src/performance/monitor/PerformanceMonitor.ts` - 性能监控
- `src/hooks/performance/` - 性能相关hooks
- `src/utils/performance.ts` - 性能工具函数

## Dependencies

- [ ] 任务005：视图引擎完成
- [ ] 任务006：状态管理完成
- [ ] React虚拟化库（react-window或react-virtualized）
- [ ] Intersection Observer API
- [ ] Performance API

## Effort Estimate

- Size: L
- Days: 3天
- Parallel: true

## Definition of Done

- [ ] Flow节点虚拟化实现，支持1000+节点流畅渲染
- [ ] 笔记列表虚拟滚动实现，支持长列表性能优化
- [ ] 懒加载机制完整，支持数据和媒体按需加载
- [ ] 位置缓存优化完成，减少重复计算
- [ ] 防抖和批量处理机制正常工作
- [ ] 性能监控工具集成，可实时查看性能指标
- [ ] 内存管理机制完成，避免内存泄漏
- [ ] 性能基准测试通过，达到预期性能目标
- [ ] 代码审查通过
- [ ] 性能优化文档完成