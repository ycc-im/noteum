---
name: 性能优化：虚拟化、懒加载和缓存（TDD）
status: open
created: 2025-10-07T00:00:00Z
github: [待创建GitHub Issue]
depends_on: [005, 006, 008]
parallel: true
conflicts_with: []
---

# Task: 性能优化：虚拟化、懒加载和缓存（TDD）

## Description

**采用TDD（测试驱动开发）方法**实现节点虚拟化和懒加载机制，优化位置缓存系统，添加防抖处理和批量更新，确保在大量笔记情况下的流畅性能表现，提升用户体验和响应速度。

**TDD开发流程**：严格遵循Red-Green-Refactor循环，先为每个性能优化功能编写失败的测试，再实现功能，最后优化性能和用户体验。

## Acceptance Criteria

### 🔴 TDD阶段：测试先行（Red）
- [ ] **编写性能优化测试套件**：先为所有性能功能编写失败的测试
- [ ] **Flow节点虚拟化测试**：大量节点渲染性能和准确性的测试
- [ ] **笔记列表虚拟滚动测试**：长列表滚动性能和动态高度测试
- [ ] **懒加载机制测试**：数据和媒体按需加载的时机和准确性测试
- [ ] **位置缓存测试**：缓存命中率、更新策略和内存管理测试
- [ ] **防抖批量处理测试**：频繁操作场景下的性能优化测试
- [ ] **性能基准测试**：各种场景下的性能阈值测试
- [ ] **内存泄漏测试**：长时间使用的内存稳定性测试

### 🟢 实现阶段：功能实现（Green）
- [ ] 实现Flow节点虚拟化渲染，让TDD测试通过
- [ ] 实现笔记列表的虚拟滚动，优化长列表性能
- [ ] 开发懒加载机制，按需加载笔记内容和标签数据
- [ ] 优化位置缓存机制，减少重复计算和内存占用
- [ ] 添加防抖处理，优化频繁更新场景的性能
- [ ] 实现批量更新机制，减少状态变更次数
- [ ] 优化动画性能，使用transform和will-change属性

### 🔄 重构阶段：性能优化（Refactor）
- [ ] **进一步优化渲染性能**：在保持测试通过的前提下优化虚拟化算法
- [ ] **重构缓存策略**：提升缓存命中率和内存使用效率
- [ ] **优化懒加载阈值**：根据实际使用情况调整加载策略
- [ ] **TDD质量验证**：确保测试覆盖率≥90%，所有性能测试稳定通过

## Technical Details

### TDD测试设计

#### Flow节点虚拟化测试
```typescript
/ src/performance FlowVirtualizer.test.tsx
describe('FlowVirtualizer TDD', () => {
  describe('Virtual Range Calculation', () => {
    it('should calculate visible range correctly', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 2
      });

      const nodes = Array.from({ length: 100 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 4) * 250,
        y: Math.floor(i  4) * 200
      }));

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 0 });

      expect(visibleRange.start).toBe(0);
      expect(visibleRange.end).toBeGreaterThan(0);
      expect(visibleRange.end).toBeLessThanOrEqual(nodes.length);
    });

    it('should handle scroll offset correctly', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 1
      });

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 400 });

      expect(visibleRange.start).toBeGreaterThan(0);
      expect(visibleRange.end).toBeGreaterThan(visibleRange.start);
    });

    it('should not render nodes outside visible range', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 0
      });

      const nodes = Array.from({ length: 50 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 250,
        y: 0
      }));

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 0 });
      const visibleNodes = nodes.slice(visibleRange.start, visibleRange.end);

      expect(visibleNodes.length).toBeLessThan(nodes.length);
      expect(visibleNodes.length).toBeLessThanOrEqual(4); / 800/200 + 1
    });
  });

  describe('Performance Optimization', () => {
    it('should render 1000 nodes within performance threshold', () => {
      const nodes = Array.from({ length: 1000 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 10) * 100,
        y: Math.floor(i  10) * 100
      }));

      const startTime = performance.now();

      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 100, height: 100 },
        overscan: 2
      });

      const { container } = render(
        <FlowVirtualizer
          nodes={nodes}
          config={virtualizer.getConfig()}
        />
      );

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(100); / 100ms内完成
      expect(container.children.length).toBeLessThan(100); / 只渲染可见节点
    });

    it('should maintain 60fps during scrolling', async () => {
      const nodes = Array.from({ length: 500 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 8) * 120,
        y: Math.floor(i  8) * 120
      }));

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const frameTimes: number[] = [];

      for (let scrollY = 0; scrollY < 2000; scrollY += 50) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        frameTimes.push(frameEnd - frameStart);
      }

      const avgFrameTime = frameTimes.reduce((sum, time) => sum + time, 0)  frameTimes.length;
      expect(avgFrameTime).toBeLessThan(16.67); / 60fps = 16.67ms per frame
    });
  });

  describe('Memory Management', () => {
    it('should cleanup unused nodes from memory', () => {
      const nodes = Array.from({ length: 100 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 100,
        y: 0
      }));

      const { container, unmount } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      / 滚动到末尾
      fireEvent.scroll(container, { target: { scrollTop: 5000 } });

      / 滚动回开头
      fireEvent.scroll(container, { target: { scrollTop: 0 } });

      unmount();

      / 验证内存清理（在实际环境中需要使用内存分析工具）
      expect(true).toBe(true); / 这里可以添加内存清理断言
    });
  });
});
```

#### 笔记列表虚拟滚动测试
```typescript
/ src/performance NotesVirtualScroller.test.tsx
describe('NotesVirtualScroller TDD', () => {
  describe('Dynamic Height Calculation', () => {
    it('should calculate variable item heights correctly', () => {
      const notes = Array.from({ length: 50 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `A`.repeat(i % 10 * 50), / 变化内容长度
        height: 80 + (i % 5) * 20 / 变化高度
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: (index) => notes[index].height,
        overscan: 3,
        estimatedItemHeight: 100
      });

      const heights = Array.from({ length: notes.length }, (_, i) =>
        scroller.getItemHeight(i)
      );

      heights.forEach((height, index) => {
        expect(height).toBe(notes[index].height);
      });

      const totalHeight = scroller.getTotalHeight(notes.length);
      const expectedTotal = notes.reduce((sum, note) => sum + note.height, 0);
      expect(totalHeight).toBe(expectedTotal);
    });

    it('should cache calculated heights', () => {
      const scroller = new NotesVirtualScroller({
        itemHeight: 100,
        overscan: 2,
        estimatedItemHeight: 100
      });

      const height1 = scroller.getItemHeight(5);
      const height2 = scroller.getItemHeight(5);

      expect(height1).toBe(height2);
      expect(height1).toBe(100);
    });
  });

  describe('Visible Range Calculation', () => {
    it('should calculate visible items for scroll position', () => {
      const notes = Array.from({ length: 100 }, () => ({
        id: 'note',
        title: 'Test',
        content: 'Content'
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: 80,
        overscan: 2,
        estimatedItemHeight: 80
      });

      scroller.setScrollTop(400);
      scroller.setContainerHeight(600);

      const visibleRange = scroller.getVisibleRange(notes.length);

      expect(visibleRange.start).toBeGreaterThan(0);
      expect(visibleRange.end).toBeGreaterThan(visibleRange.start);
      expect(visibleRange.end - visibleRange.start).toBeLessThanOrEqual(10); / 600/80 + overscan
    });

    it('should handle scroll to bottom correctly', () => {
      const notes = Array.from({ length: 50 }, () => ({
        id: 'note',
        title: 'Test',
        content: 'Content'
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: 100,
        overscan: 2,
        estimatedItemHeight: 100
      });

      scroller.setScrollTop(4000); / 接近底部
      scroller.setContainerHeight(600);

      const visibleRange = scroller.getVisibleRange(notes.length);

      expect(visibleRange.end).toBe(notes.length - 1);
    });
  });

  describe('Scroll Performance', () => {
    it('should handle rapid scrolling without performance degradation', async () => {
      const notes = Array.from({ length: 1000 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `Content for note ${i}`.repeat(10)
      }));

      const { container } = render(
        <NotesVirtualScroller notes={notes} />
      );

      const scrollTimes: number[] = [];

      for (let i = 0; i < 100; i++) {
        const scrollStart = performance.now();

        fireEvent.scroll(container, {
          target: { scrollTop: Math.random() * 50000 }
        });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const scrollEnd = performance.now();
        scrollTimes.push(scrollEnd - scrollStart);
      }

      const avgScrollTime = scrollTimes.reduce((sum, time) => sum + time, 0)  scrollTimes.length;
      expect(avgScrollTime).toBeLessThan(20); / 滚动响应时间 < 20ms
    });

    it('should maintain smooth rendering with variable heights', async () => {
      const notes = Array.from({ length: 500 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: 'A'.repeat(i % 20 * 100),
        height: 60 + Math.random() * 120
      }));

      const frameRates: number[] = [];

      const { container } = render(
        <NotesVirtualScroller notes={notes} />
      );

      for (let scrollY = 0; scrollY < 10000; scrollY += 100) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        frameRates.push(1000  (frameEnd - frameStart));
      }

      const avgFrameRate = frameRates.reduce((sum, fps) => sum + fps, 0)  frameRates.length;
      expect(avgFrameRate).toBeGreaterThan(30); / 至少30fps
    });
  });
});
```

#### 懒加载机制测试
```typescript
/ src/performance LazyLoader.test.ts
describe('DataLazyLoader TDD', () => {
  describe('Load Triggering', () => {
    it('should trigger load when approaching threshold', () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 20,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn();

      / 当前索引接近总数，且在阈值范围内
      const shouldLoad = lazyLoader.shouldLoadMore(95, 100);
      expect(shouldLoad).toBe(true);

      / 远离阈值，不应该触发加载
      const shouldNotLoad = lazyLoader.shouldLoadMore(80, 100);
      expect(shouldNotLoad).toBe(false);
    });

    it('should not load multiple times simultaneously', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue(
        Array.from({ length: 10 }, (_, i) => ({ id: `item-${i}` }))
      );

      / 同时触发两次加载
      const load1 = lazyLoader.loadPage(1, mockLoadFn);
      const load2 = lazyLoader.loadPage(1, mockLoadFn);

      await Promise.all([load1, load2]);

      / 只应该调用一次加载函数
      expect(mockLoadFn).toHaveBeenCalledTimes(1);
      expect(mockLoadFn).toHaveBeenCalledWith(1, 10);
    });
  });

  describe('Page Loading', () => {
    it('should load correct page with correct batch size', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 15,
        preloadCount: 1
      });

      const mockData = Array.from({ length: 15 }, (_, i) => ({
        id: `item-${i}`,
        title: `Item ${i}`
      }));

      const mockLoadFn = jest.fn().mockResolvedValue(mockData);

      const result = await lazyLoader.loadPage(2, mockLoadFn);

      expect(mockLoadFn).toHaveBeenCalledWith(2, 15);
      expect(result).toEqual(mockData);
    });

    it('should return empty array for already loaded page', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([
        { id: 'item-1', title: 'Item 1' }
      ]);

      / 第一次加载
      await lazyLoader.loadPage(1, mockLoadFn);
      expect(mockLoadFn).toHaveBeenCalledTimes(1);

      / 第二次加载同一页
      const result = await lazyLoader.loadPage(1, mockLoadFn);
      expect(result).toEqual([]);
      expect(mockLoadFn).toHaveBeenCalledTimes(1); / 没有再次调用
    });
  });

  describe('Preloading Strategy', () => {
    it('should preload next page asynchronously', async (done) => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([]);

      / 预加载下一页
      await lazyLoader.preloadNextPage(1, mockLoadFn);

      / 使用setTimeout验证异步调用
      setTimeout(() => {
        expect(mockLoadFn).toHaveBeenCalledWith(2, 10);
        done();
      }, 150);
    });

    it('should not preload already loaded pages', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([]);

      / 先加载第2页
      await lazyLoader.loadPage(2, mockLoadFn);

      / 重置mock
      mockLoadFn.mockClear();

      / 尝试预加载第2页
      await lazyLoader.preloadNextPage(1, mockLoadFn);

      expect(mockLoadFn).not.toHaveBeenCalled();
    });
  });
});

describe('MediaLazyLoader TDD', () => {
  describe('Image Loading', () => {
    it('should load image when intersecting viewport', async () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      mockImage.dataset.src = 'test-image.jpg';

      const mockIntersection = {
        isIntersecting: true,
        target: mockImage
      } as IntersectionObserverEntry;

      / 模拟进入视口
      mediaLoader.handleIntersection([mockIntersection]);

      / 验证图片src被设置
      expect(mockImage.src).toContain('test-image.jpg');
    });

    it('should not load image until intersecting', () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      mockImage.dataset.src = 'test-image.jpg';

      const mockIntersection = {
        isIntersecting: false,
        target: mockImage
      } as IntersectionObserverEntry;

      / 模拟不在视口内
      mediaLoader.handleIntersection([mockIntersection]);

      / 验证图片src未被设置
      expect(mockImage.src).toBe('');
      expect(mockImage.dataset.src).toBe('test-image.jpg');
    });
  });

  describe('Caching', () => {
    it('should not reload already loaded images', () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      const src = 'cached-image.jpg';

      / 先标记为已加载
      mediaLoader.markAsLoaded(src);

      / 直接设置src，不需要观察
      mediaLoader.observeImage(mockImage, src);

      expect(mockImage.src).toContain(src);
    });
  });
});
```

#### 位置缓存测试
```typescript
/ src/performance PositionCache.test.ts
describe('OptimizedPositionCache TDD', () => {
  let cache: OptimizedPositionCache;

  beforeEach(() => {
    cache = new OptimizedPositionCache(100, 1000); / 最大100条，1秒TTL用于测试
  });

  afterEach(() => {
    cache.destroy();
  });

  describe('Cache Operations', () => {
    it('should store and retrieve positions', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };
      const view = 'flow' as ViewType;

      cache.setPosition(key, position, view);
      const cached = cache.getPosition(key, view);

      expect(cached).toEqual({
        x: 100,
        y: 200,
        view: 'flow',
        timestamp: expect.any(Number),
        dirty: false
      });
    });

    it('should return null for non-existent keys', () => {
      const result = cache.getPosition('non-existent', 'flow' as ViewType);
      expect(result).toBeNull();
    });

    it('should return null for expired entries', (done) => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);

      / 等待超过TTL时间
      setTimeout(() => {
        const result = cache.getPosition(key, 'flow' as ViewType);
        expect(result).toBeNull();
        done();
      }, 1100);
    });

    it('should return null for different views', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);

      const result = cache.getPosition(key, 'daily' as ViewType);
      expect(result).toBeNull();
    });
  });

  describe('Cache Size Management', () => {
    it('should evict oldest entries when at capacity', () => {
      / 填满缓存
      for (let i = 0; i < 100; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
      }

      / 添加第101条记录，应该驱逐最旧的
      cache.setPosition('note-100', { x: 100, y: 100 }, 'flow' as ViewType);

      / 验证最旧的记录被驱逐
      const oldest = cache.getPosition('note-0', 'flow' as ViewType);
      expect(oldest).toBeNull();

      / 验证最新记录存在
      const newest = cache.getPosition('note-100', 'flow' as ViewType);
      expect(newest).toBeDefined();
    });

    it('should handle eviction correctly', () => {
      const positions = [];

      / 添加记录并记录时间戳
      for (let i = 0; i < 105; i++) {
        const position = { x: i, y: i };
        cache.setPosition(`note-${i}`, position, 'flow' as ViewType);
        positions.push({ key: `note-${i}`, position });
      }

      / 验证缓存大小不超过最大值
      const size = cache.getSize();
      expect(size).toBeLessThanOrEqual(100);

      / 验证最新记录仍然存在
      const latest = cache.getPosition('note-104', 'flow' as ViewType);
      expect(latest).toBeDefined();
    });
  });

  describe('Dirty Data Management', () => {
    it('should mark entries as dirty', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);
      cache.markDirty(key);

      const cached = cache.getPosition(key, 'flow' as ViewType);
      expect(cached?.dirty).toBe(true);
    });

    it('should flush dirty entries', async () => {
      const mockPersist = jest.fn().mockResolvedValue(undefined);
      cache.setPersistFunction(mockPersist);

      / 添加脏数据
      for (let i = 0; i < 5; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
        cache.markDirty(`note-${i}`);
      }

      await cache.flushDirty();

      expect(mockPersist).toHaveBeenCalledTimes(5);

      / 验证脏标记被清除
      for (let i = 0; i < 5; i++) {
        const cached = cache.getPosition(`note-${i}`, 'flow' as ViewType);
        expect(cached?.dirty).toBe(false);
      }
    });
  });

  describe('Batch Operations', () => {
    it('should handle batch position updates', () => {
      const updates = [
        { key: 'note-1', position: { x: 100, y: 200 }, view: 'flow' as ViewType },
        { key: 'note-2', position: { x: 150, y: 250 }, view: 'flow' as ViewType },
        { key: 'note-3', position: { x: 200, y: 300 }, view: 'daily' as ViewType }
      ];

      cache.batchUpdatePositions(updates);

      updates.forEach(({ key, position, view }) => {
        const cached = cache.getPosition(key, view);
        expect(cached).toEqual({
          x: position.x,
          y: position.y,
          view,
          timestamp: expect.any(Number),
          dirty: false
        });
      });
    });

    it('should handle batch updates efficiently', () => {
      const startTime = performance.now();

      const updates = Array.from({ length: 1000 }, (_, i) => ({
        key: `note-${i}`,
        position: { x: i * 10, y: i * 10 },
        view: (i % 2 === 0 ? 'flow' : 'daily') as ViewType
      }));

      cache.batchUpdatePositions(updates);

      const endTime = performance.now();
      expect(endTime - startTime).toBeLessThan(50); / 批量更新应该很快
    });
  });

  describe('Performance Benchmarks', () => {
    it('should handle 10,000 operations within threshold', () => {
      const startTime = performance.now();

      / 大量读写操作
      for (let i = 0; i < 10000; i++) {
        const key = `note-${i % 100}`; / 重复使用key测试缓存命中
        cache.setPosition(key, { x: i, y: i }, 'flow' as ViewType);
        cache.getPosition(key, 'flow' as ViewType);
      }

      const endTime = performance.now();
      expect(endTime - startTime).toBeLessThan(100); / 100ms内完成10k操作
    });

    it('should maintain performance under concurrent access', () => {
      const promises = Array.from({ length: 100 }, (_, i) =>
        new Promise<void>((resolve) => {
          setTimeout(() => {
            cache.setPosition(`concurrent-${i}`, { x: i, y: i }, 'flow' as ViewType);
            cache.getPosition(`concurrent-${i}`, 'flow' as ViewType);
            resolve();
          }, Math.random() * 10);
        })
      );

      const startTime = performance.now();

      return Promise.all(promises).then(() => {
        const endTime = performance.now();
        expect(endTime - startTime).toBeLessThan(50);
      });
    });
  });
});
```

#### 防抖和批量处理测试
```typescript
/ src/performance PerformanceOptimizer.test.ts
describe('PerformanceOptimizer TDD', () => {
  let optimizer: PerformanceOptimizer;

  beforeEach(() => {
    optimizer = new PerformanceOptimizer();
  });

  afterEach(() => {
    optimizer.destroy();
  });

  describe('Debouncing', () => {
    it('should delay function execution', (done) => {
      const mockFn = jest.fn();
      const debouncedFn = optimizer.debounce('test', mockFn, 100);

      debouncedFn('arg1', 'arg2');

      / 立即检查，不应该执行
      expect(mockFn).not.toHaveBeenCalled();

      / 100ms后应该执行
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
        expect(mockFn).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });

    it('should cancel previous pending execution', (done) => {
      const mockFn = jest.fn();
      const debouncedFn = optimizer.debounce('test', mockFn, 100);

      debouncedFn('first');
      debouncedFn('second');
      debouncedFn('third');

      / 150ms后应该只执行最后一次
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledWith('third');
        expect(mockFn).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });

    it('should handle multiple debounced functions independently', (done) => {
      const mockFn1 = jest.fn();
      const mockFn2 = jest.fn();

      const debounced1 = optimizer.debounce('fn1', mockFn1, 50);
      const debounced2 = optimizer.debounce('fn2', mockFn2, 50);

      debounced1('fn1-arg');
      debounced2('fn2-arg');

      setTimeout(() => {
        expect(mockFn1).toHaveBeenCalledWith('fn1-arg');
        expect(mockFn2).toHaveBeenCalledWith('fn2-arg');
        done();
      }, 100);
    });
  });

  describe('Throttling', () => {
    it('should limit function execution frequency', (done) => {
      const mockFn = jest.fn();
      const throttledFn = optimizer.throttle('test', mockFn, 100);

      / 快速调用多次
      throttledFn();
      throttledFn();
      throttledFn();
      throttledFn();

      / 立即执行第一次
      expect(mockFn).toHaveBeenCalledTimes(1);

      / 100ms内不应该再次执行
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledTimes(1);

        / 100ms后应该可以再次执行
        setTimeout(() => {
          throttledFn();
          expect(mockFn).toHaveBeenCalledTimes(2);
          done();
        }, 50);
      }, 100);
    });

    it('should handle throttling with correct interval', (done) => {
      const mockFn = jest.fn();
      const throttledFn = optimizer.throttle('test', mockFn, 200);

      const startTime = Date.now();

      throttledFn(); / 第一次执行

      setTimeout(() => throttledFn(), 150); / 不执行
      setTimeout(() => throttledFn(), 250); / 执行

      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledTimes(2);
        done();
      }, 300);
    });
  });

  describe('Batch Processing', () => {
    it('should batch function calls in single animation frame', (done) => {
      const mockFns = Array.from({ length: 5 }, (_, i) =>
        jest.fn().mockReturnValue(`result-${i}`)
      );

      / 添加多个函数到批次
      mockFns.forEach((fn, index) => {
        optimizer.batch('test', fn);
      });

      / 应该在下一个动画帧执行
      requestAnimationFrame(() => {
        mockFns.forEach(fn => {
          expect(fn).toHaveBeenCalledTimes(1);
        });
        done();
      });
    });

    it('should handle multiple batch keys independently', (done) => {
      const batch1Fns = [jest.fn(), jest.fn()];
      const batch2Fns = [jest.fn(), jest.fn(), jest.fn()];

      batch1Fns.forEach(fn => optimizer.batch('batch1', fn));
      batch2Fns.forEach(fn => optimizer.batch('batch2', fn));

      requestAnimationFrame(() => {
        batch1Fns.forEach(fn => expect(fn).toHaveBeenCalledTimes(1));
        batch2Fns.forEach(fn => expect(fn).toHaveBeenCalledTimes(1));
        done();
      });
    });

    it('should clear batch after execution', (done) => {
      const mockFn = jest.fn();

      optimizer.batch('test', mockFn);

      requestAnimationFrame(() => {
        expect(mockFn).toHaveBeenCalledTimes(1);

        / 下一个动画帧应该没有待执行的函数
        requestAnimationFrame(() => {
          expect(mockFn).toHaveBeenCalledTimes(1); / 没有增加
          done();
        });
      });
    });
  });

  describe('Performance Optimization', () => {
    it('should reduce rapid state updates', () => {
      const mockSetState = jest.fn();
      const optimizedSetState = optimizer.debounce('setState', mockSetState, 50);

      / 模拟快速状态更新
      for (let i = 0; i < 100; i++) {
        optimizedSetState({ count: i });
      }

      / 立即检查，不应该执行
      expect(mockSetState).not.toHaveBeenCalled();

      / 等待防抖完成
      jest.advanceTimersByTime(50);
      expect(mockSetState).toHaveBeenCalledTimes(1);
      expect(mockSetState).toHaveBeenCalledWith({ count: 99 }); / 只执行最后一次
    });

    it('should batch DOM updates efficiently', () => {
      const mockDOMUpdate = jest.fn();

      / 模拟多个DOM更新
      for (let i = 0; i < 10; i++) {
        optimizer.batch('domUpdate', () => mockDOMUpdate(i));
      }

      / 强制执行批次
      jest.runAllTimers();

      expect(mockDOMUpdate).toHaveBeenCalledTimes(10);
      expect(mockDOMUpdate).toHaveBeenLastCalledWith(9);
    });
  });

  describe('Memory Management', () => {
    it('should cleanup timers and animation frames', () => {
      const debouncedFn = optimizer.debounce('test', jest.fn(), 100);
      debouncedFn();

      const throttledFn = optimizer.throttle('test2', jest.fn(), 100);
      throttledFn();

      optimizer.batch('test3', jest.fn());

      / 销毁时应该清理所有资源
      optimizer.destroy();

      / 验证清理（在实际实现中需要内部跟踪）
      expect(true).toBe(true); / 这里可以添加内部状态验证
    });
  });
});
```

#### 性能基准测试
```typescript
/ src/test/performance/performance-benchmarks.test.ts
describe('Performance Benchmarks TDD', () => {
  describe('Virtualization Performance', () => {
    it('should render 10,000 virtual nodes within threshold', () => {
      const nodes = Array.from({ length: 10000 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 20) * 50,
        y: Math.floor(i  20) * 50,
        data: { title: `Node ${i}` }
      }));

      const startTime = performance.now();

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(200); / 200ms内完成
      expect(container.children.length).toBeLessThan(200); / 只渲染可见节点
    });

    it('should maintain smooth scrolling with large dataset', async () => {
      const nodes = Array.from({ length: 5000 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 10,
        y: Math.floor(i  100) * 10,
        data: { title: `Node ${i}` }
      }));

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const frameDrops: number[] = [];

      for (let scrollY = 0; scrollY < 10000; scrollY += 50) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        const frameTime = frameEnd - frameStart;

        if (frameTime > 16.67) { / 超过60fps阈值
          frameDrops.push(frameTime);
        }
      }

      / 帧丢失应该少于5%
      expect(frameDrops.length  200).toBeLessThan(0.05);
    });
  });

  describe('Memory Performance', () => {
    it('should not leak memory during virtual scrolling', async () => {
      const initialMemory = performance.memory?.usedJSHeapSize || 0;

      const { container, unmount } = render(
        <FlowVirtualizer nodes={generateLargeNodeSet(1000)} />
      );

      / 模拟大量滚动操作
      for (let i = 0; i < 100; i++) {
        fireEvent.scroll(container, {
          target: { scrollTop: Math.random() * 50000 }
        });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });
      }

      unmount();

      / 强制垃圾回收（如果可用）
      if (global.gc) {
        global.gc();
      }

      const finalMemory = performance.memory?.usedJSHeapSize || 0;
      const memoryIncrease = finalMemory - initialMemory;

      / 内存增长应该小于10MB
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
    });

    it('should cleanup cached positions properly', () => {
      const cache = new OptimizedPositionCache(1000, 1000);

      / 填充缓存
      for (let i = 0; i < 2000; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
      }

      const midSize = cache.getSize();
      expect(midSize).toBeLessThanOrEqual(1000);

      / 清理过期条目
      cache.cleanup();

      const finalSize = cache.getSize();
      expect(finalSize).toBeLessThanOrEqual(midSize);

      cache.destroy();
    });
  });

  describe('Batch Processing Performance', () => {
    it('should handle large batch updates efficiently', () => {
      const optimizer = new PerformanceOptimizer();
      const updateCount = 10000;

      const startTime = performance.now();

      / 添加大量更新到批次
      for (let i = 0; i < updateCount; i++) {
        optimizer.batch('updates', () => {
          / 模拟更新操作
          return i;
        });
      }

      / 等待批次执行
      jest.runAllTimers();

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(100); / 100ms内完成10k更新
      expect(optimizer.getBatchSize('updates')).toBe(0); / 批次应该被清空

      optimizer.destroy();
    });

    it('should reduce API calls through debouncing', () => {
      const mockAPI = jest.fn().mockResolvedValue([]);
      const optimizer = new PerformanceOptimizer();
      const debouncedAPI = optimizer.debounce('api', mockAPI, 100);

      / 模拟快速API调用
      for (let i = 0; i < 100; i++) {
        debouncedAPI({ data: i });
      }

      / 立即检查，不应该调用
      expect(mockAPI).not.toHaveBeenCalled();

      / 等待防抖完成
      jest.advanceTimersByTime(100);

      / 只应该调用一次API
      expect(mockAPI).toHaveBeenCalledTimes(1);
      expect(mockAPI).toHaveBeenCalledWith({ data: 99 });

      optimizer.destroy();
    });
  });

  describe('Lazy Loading Performance', () => {
    it('should load data without blocking UI', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 20,
        preloadCount: 2
      });

      const mockLoadFn = jest.fn().mockImplementation((page, size) => {
        / 模拟网络延迟
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(Array.from({ length: size }, (_, i) => ({
              id: `item-${page}-${i}`,
              title: `Item ${page}-${i}`
            })));
          }, 50);
        });
      });

      const startTime = performance.now();

      / 触发加载
      const loadPromise = lazyLoader.loadPage(1, mockLoadFn);

      / 检查UI是否仍然响应
      const uiResponsiveCheck = performance.now() - startTime;
      expect(uiResponsiveCheck).toBeLessThan(10); / UI应该立即保持响应

      await loadPromise;

      const totalTime = performance.now() - startTime;
      expect(totalTime).toBeGreaterThan(40); / 应该等待网络延迟

      expect(mockLoadFn).toHaveBeenCalledWith(1, 20);
    });
  });
});
```

### TDD组件架构设计

#### 核心接口
```typescript
/ src/performance/types.ts
interface VirtualizationConfig {
  containerSize: { width: number; height: number };
  itemSize: { width: number; height: number };
  overscan: number;
  bufferSize: number;
}

interface LazyLoadConfig {
  threshold: number;
  batchSize: number;
  preloadCount: number;
}

interface PerformanceMetrics {
  renderTime: number;
  memoryUsage: number;
  cacheHitRate: number;
  frameRate: number;
}

class FlowVirtualizer {
  calculateVisibleRange(scrollOffset: { x: number; y: number }): Range;
  renderVirtualizedNodes(nodes: FlowNode[]): ReactElement;
}

class NotesVirtualScroller {
  getItemHeight(index: number): number;
  getVisibleRange(itemsCount: number): Range;
  renderVirtualizedList(notes: NoteRecord[]): ReactElement;
}

class DataLazyLoader {
  shouldLoadMore(currentIndex: number, totalItems: number): boolean;
  loadPage(pageIndex: number, loader: Function): Promise<any[]>;
  preloadNextPage(currentPage: number, loader: Function): Promise<void>;
}

class OptimizedPositionCache {
  getPosition(key: string, view: ViewType): CachedPosition | null;
  setPosition(key: string, position: { x: number; y: number }, view: ViewType): void;
  batchUpdatePositions(updates: PositionUpdate[]): void;
}
```

### TDD实现要点

#### Red阶段：失败的测试
- **虚拟化准确性测试**：可见范围计算、节点定位、滚动响应
- **懒加载时机测试**：阈值触发、预加载策略、并发控制
- **缓存性能测试**：命中率、更新策略、内存管理
- **防抖批量测试**：延迟执行、频率限制、批次处理
- **性能基准测试**：大量数据渲染、内存使用、帧率稳定

#### Green阶段：最小实现
- **基础虚拟化**：实现最简的可见区域计算和节点渲染
- **简单懒加载**：基础的阈值判断和页面加载机制
- **基本缓存**：简单的Map存储和TTL过期机制
- **防抖批量**：使用setTimeout和requestAnimationFrame的基础实现

#### Refactor阶段：优化提升
- **算法优化**：更高效的虚拟化计算和缓存策略
- **性能调优**：根据基准测试结果调整参数
- **内存优化**：减少不必要的对象创建和引用
- **用户体验**：平滑动画、加载状态、错误处理

### 代码文件影响

#### TDD测试文件（优先级最高）
- `src/performance FlowVirtualizer.test.tsx` - Flow虚拟化测试
- `src/performance NotesVirtualScroller.test.tsx` - 笔记虚拟滚动测试
- `src/performance LazyLoader.test.ts` - 懒加载机制测试
- `src/performance PositionCache.test.ts` - 位置缓存测试
- `src/performance PerformanceOptimizer.test.ts` - 性能优化器测试
- `src/test/performance/performance-benchmarks.test.ts` - 性能基准测试

#### 核心实现文件
- `src/performance/virtualization/FlowVirtualizer.tsx` - Flow虚拟化组件
- `src/performance/virtualization/NotesVirtualScroller.tsx` - 笔记虚拟滚动
- `src/performance/lazyload/DataLazyLoader.ts` - 数据懒加载
- `src/performance/lazyload/MediaLazyLoader.ts` - 媒体懒加载
- `src/performance/cache/OptimizedPositionCache.ts` - 优化位置缓存
- `src/performance/optimizer/PerformanceOptimizer.ts` - 性能优化器
- `src/hooks/performance/` - 性能相关hooks
- `src/utils/performance.ts` - 性能工具函数

## Dependencies

- [ ] **任务008：TDD基础设施**完成，测试框架就位
- [ ] **任务005：视图引擎**完成，视图系统可用
- [ ] **任务006：状态管理**完成，状态管理可用
- [ ] React虚拟化库（react-window或@tanstack/react-virtual）
- [ ] Intersection Observer API
- [ ] Performance API
- [ ] Jest性能测试扩展

## Effort Estimate

- Size: L（包含大量性能测试和优化工作）
- Days: 3-4天
- Parallel: true

### 工作量分解
- **TDD测试编写**：1.5天（最重要，优先级最高）
- **功能实现**：1.5天（让测试通过）
- **重构优化**：0.5天（性能调优）
- **集成验证**：0.5天（端到端性能测试）

## Definition of Done

- [ ] **TDD流程完整**：Red-Green-Refactor循环完整执行
- [ ] **虚拟化系统**：支持1000+节点流畅渲染，性能测试通过
- [ ] **懒加载机制**：数据和媒体按需加载，时机准确
- [ ] **缓存优化**：位置缓存命中率≥90%，内存使用优化
- [ ] **防抖批量**：频繁操作场景性能提升明显
- [ ] **性能达标**：所有基准测试通过，60fps稳定
- [ ] **内存管理**：无内存泄漏，长期使用稳定
- [ ] **代码质量**：测试覆盖率≥90%，通过所有检查
- [ ] **性能监控**：集成性能监控工具，可实时查看指标