---
name: æ€§èƒ½ä¼˜åŒ–ï¼šè™šæ‹ŸåŒ–ã€æ‡’åŠ è½½å’Œç¼“å­˜ï¼ˆTDDï¼‰
status: open
created: 2025-10-07T00:00:00Z
github: [å¾…åˆ›å»ºGitHub Issue]
depends_on: [005, 006, 008]
parallel: true
conflicts_with: []
---

# Task: æ€§èƒ½ä¼˜åŒ–ï¼šè™šæ‹ŸåŒ–ã€æ‡’åŠ è½½å’Œç¼“å­˜ï¼ˆTDDï¼‰

## Description

**é‡‡ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰æ–¹æ³•**å®ç°èŠ‚ç‚¹è™šæ‹ŸåŒ–å’Œæ‡’åŠ è½½æœºåˆ¶ï¼Œä¼˜åŒ–ä½ç½®ç¼“å­˜ç³»ç»Ÿï¼Œæ·»åŠ é˜²æŠ–å¤„ç†å’Œæ‰¹é‡æ›´æ–°ï¼Œç¡®ä¿åœ¨å¤§é‡ç¬”è®°æƒ…å†µä¸‹çš„æµç•…æ€§èƒ½è¡¨ç°ï¼Œæå‡ç”¨æˆ·ä½“éªŒå’Œå“åº”é€Ÿåº¦ã€‚

**TDDå¼€å‘æµç¨‹**ï¼šä¸¥æ ¼éµå¾ªRed-Green-Refactorå¾ªç¯ï¼Œå…ˆä¸ºæ¯ä¸ªæ€§èƒ½ä¼˜åŒ–åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½ï¼Œæœ€åä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

## Acceptance Criteria

### ğŸ”´ TDDé˜¶æ®µï¼šæµ‹è¯•å…ˆè¡Œï¼ˆRedï¼‰
- [ ] **ç¼–å†™æ€§èƒ½ä¼˜åŒ–æµ‹è¯•å¥—ä»¶**ï¼šå…ˆä¸ºæ‰€æœ‰æ€§èƒ½åŠŸèƒ½ç¼–å†™å¤±è´¥çš„æµ‹è¯•
- [ ] **FlowèŠ‚ç‚¹è™šæ‹ŸåŒ–æµ‹è¯•**ï¼šå¤§é‡èŠ‚ç‚¹æ¸²æŸ“æ€§èƒ½å’Œå‡†ç¡®æ€§çš„æµ‹è¯•
- [ ] **ç¬”è®°åˆ—è¡¨è™šæ‹Ÿæ»šåŠ¨æµ‹è¯•**ï¼šé•¿åˆ—è¡¨æ»šåŠ¨æ€§èƒ½å’ŒåŠ¨æ€é«˜åº¦æµ‹è¯•
- [ ] **æ‡’åŠ è½½æœºåˆ¶æµ‹è¯•**ï¼šæ•°æ®å’Œåª’ä½“æŒ‰éœ€åŠ è½½çš„æ—¶æœºå’Œå‡†ç¡®æ€§æµ‹è¯•
- [ ] **ä½ç½®ç¼“å­˜æµ‹è¯•**ï¼šç¼“å­˜å‘½ä¸­ç‡ã€æ›´æ–°ç­–ç•¥å’Œå†…å­˜ç®¡ç†æµ‹è¯•
- [ ] **é˜²æŠ–æ‰¹é‡å¤„ç†æµ‹è¯•**ï¼šé¢‘ç¹æ“ä½œåœºæ™¯ä¸‹çš„æ€§èƒ½ä¼˜åŒ–æµ‹è¯•
- [ ] **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå„ç§åœºæ™¯ä¸‹çš„æ€§èƒ½é˜ˆå€¼æµ‹è¯•
- [ ] **å†…å­˜æ³„æ¼æµ‹è¯•**ï¼šé•¿æ—¶é—´ä½¿ç”¨çš„å†…å­˜ç¨³å®šæ€§æµ‹è¯•

### ğŸŸ¢ å®ç°é˜¶æ®µï¼šåŠŸèƒ½å®ç°ï¼ˆGreenï¼‰
- [ ] å®ç°FlowèŠ‚ç‚¹è™šæ‹ŸåŒ–æ¸²æŸ“ï¼Œè®©TDDæµ‹è¯•é€šè¿‡
- [ ] å®ç°ç¬”è®°åˆ—è¡¨çš„è™šæ‹Ÿæ»šåŠ¨ï¼Œä¼˜åŒ–é•¿åˆ—è¡¨æ€§èƒ½
- [ ] å¼€å‘æ‡’åŠ è½½æœºåˆ¶ï¼ŒæŒ‰éœ€åŠ è½½ç¬”è®°å†…å®¹å’Œæ ‡ç­¾æ•°æ®
- [ ] ä¼˜åŒ–ä½ç½®ç¼“å­˜æœºåˆ¶ï¼Œå‡å°‘é‡å¤è®¡ç®—å’Œå†…å­˜å ç”¨
- [ ] æ·»åŠ é˜²æŠ–å¤„ç†ï¼Œä¼˜åŒ–é¢‘ç¹æ›´æ–°åœºæ™¯çš„æ€§èƒ½
- [ ] å®ç°æ‰¹é‡æ›´æ–°æœºåˆ¶ï¼Œå‡å°‘çŠ¶æ€å˜æ›´æ¬¡æ•°
- [ ] ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½ï¼Œä½¿ç”¨transformå’Œwill-changeå±æ€§

### ğŸ”„ é‡æ„é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆRefactorï¼‰
- [ ] **è¿›ä¸€æ­¥ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½**ï¼šåœ¨ä¿æŒæµ‹è¯•é€šè¿‡çš„å‰æä¸‹ä¼˜åŒ–è™šæ‹ŸåŒ–ç®—æ³•
- [ ] **é‡æ„ç¼“å­˜ç­–ç•¥**ï¼šæå‡ç¼“å­˜å‘½ä¸­ç‡å’Œå†…å­˜ä½¿ç”¨æ•ˆç‡
- [ ] **ä¼˜åŒ–æ‡’åŠ è½½é˜ˆå€¼**ï¼šæ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µè°ƒæ•´åŠ è½½ç­–ç•¥
- [ ] **TDDè´¨é‡éªŒè¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œæ‰€æœ‰æ€§èƒ½æµ‹è¯•ç¨³å®šé€šè¿‡

## Technical Details

### TDDæµ‹è¯•è®¾è®¡

#### FlowèŠ‚ç‚¹è™šæ‹ŸåŒ–æµ‹è¯•
```typescript
/ src/performance FlowVirtualizer.test.tsx
describe('FlowVirtualizer TDD', () => {
  describe('Virtual Range Calculation', () => {
    it('should calculate visible range correctly', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 2
      });

      const nodes = Array.from({ length: 100 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 4) * 250,
        y: Math.floor(i  4) * 200
      }));

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 0 });

      expect(visibleRange.start).toBe(0);
      expect(visibleRange.end).toBeGreaterThan(0);
      expect(visibleRange.end).toBeLessThanOrEqual(nodes.length);
    });

    it('should handle scroll offset correctly', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 1
      });

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 400 });

      expect(visibleRange.start).toBeGreaterThan(0);
      expect(visibleRange.end).toBeGreaterThan(visibleRange.start);
    });

    it('should not render nodes outside visible range', () => {
      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 200, height: 150 },
        overscan: 0
      });

      const nodes = Array.from({ length: 50 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 250,
        y: 0
      }));

      const visibleRange = virtualizer.calculateVisibleRange({ x: 0, y: 0 });
      const visibleNodes = nodes.slice(visibleRange.start, visibleRange.end);

      expect(visibleNodes.length).toBeLessThan(nodes.length);
      expect(visibleNodes.length).toBeLessThanOrEqual(4); / 800/200 + 1
    });
  });

  describe('Performance Optimization', () => {
    it('should render 1000 nodes within performance threshold', () => {
      const nodes = Array.from({ length: 1000 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 10) * 100,
        y: Math.floor(i  10) * 100
      }));

      const startTime = performance.now();

      const virtualizer = new FlowVirtualizer({
        containerSize: { width: 800, height: 600 },
        itemSize: { width: 100, height: 100 },
        overscan: 2
      });

      const { container } = render(
        <FlowVirtualizer
          nodes={nodes}
          config={virtualizer.getConfig()}
        />
      );

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(100); / 100mså†…å®Œæˆ
      expect(container.children.length).toBeLessThan(100); / åªæ¸²æŸ“å¯è§èŠ‚ç‚¹
    });

    it('should maintain 60fps during scrolling', async () => {
      const nodes = Array.from({ length: 500 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 8) * 120,
        y: Math.floor(i  8) * 120
      }));

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const frameTimes: number[] = [];

      for (let scrollY = 0; scrollY < 2000; scrollY += 50) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        frameTimes.push(frameEnd - frameStart);
      }

      const avgFrameTime = frameTimes.reduce((sum, time) => sum + time, 0)  frameTimes.length;
      expect(avgFrameTime).toBeLessThan(16.67); / 60fps = 16.67ms per frame
    });
  });

  describe('Memory Management', () => {
    it('should cleanup unused nodes from memory', () => {
      const nodes = Array.from({ length: 100 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 100,
        y: 0
      }));

      const { container, unmount } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      / æ»šåŠ¨åˆ°æœ«å°¾
      fireEvent.scroll(container, { target: { scrollTop: 5000 } });

      / æ»šåŠ¨å›å¼€å¤´
      fireEvent.scroll(container, { target: { scrollTop: 0 } });

      unmount();

      / éªŒè¯å†…å­˜æ¸…ç†ï¼ˆåœ¨å®é™…ç¯å¢ƒä¸­éœ€è¦ä½¿ç”¨å†…å­˜åˆ†æå·¥å…·ï¼‰
      expect(true).toBe(true); / è¿™é‡Œå¯ä»¥æ·»åŠ å†…å­˜æ¸…ç†æ–­è¨€
    });
  });
});
```

#### ç¬”è®°åˆ—è¡¨è™šæ‹Ÿæ»šåŠ¨æµ‹è¯•
```typescript
/ src/performance NotesVirtualScroller.test.tsx
describe('NotesVirtualScroller TDD', () => {
  describe('Dynamic Height Calculation', () => {
    it('should calculate variable item heights correctly', () => {
      const notes = Array.from({ length: 50 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `A`.repeat(i % 10 * 50), / å˜åŒ–å†…å®¹é•¿åº¦
        height: 80 + (i % 5) * 20 / å˜åŒ–é«˜åº¦
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: (index) => notes[index].height,
        overscan: 3,
        estimatedItemHeight: 100
      });

      const heights = Array.from({ length: notes.length }, (_, i) =>
        scroller.getItemHeight(i)
      );

      heights.forEach((height, index) => {
        expect(height).toBe(notes[index].height);
      });

      const totalHeight = scroller.getTotalHeight(notes.length);
      const expectedTotal = notes.reduce((sum, note) => sum + note.height, 0);
      expect(totalHeight).toBe(expectedTotal);
    });

    it('should cache calculated heights', () => {
      const scroller = new NotesVirtualScroller({
        itemHeight: 100,
        overscan: 2,
        estimatedItemHeight: 100
      });

      const height1 = scroller.getItemHeight(5);
      const height2 = scroller.getItemHeight(5);

      expect(height1).toBe(height2);
      expect(height1).toBe(100);
    });
  });

  describe('Visible Range Calculation', () => {
    it('should calculate visible items for scroll position', () => {
      const notes = Array.from({ length: 100 }, () => ({
        id: 'note',
        title: 'Test',
        content: 'Content'
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: 80,
        overscan: 2,
        estimatedItemHeight: 80
      });

      scroller.setScrollTop(400);
      scroller.setContainerHeight(600);

      const visibleRange = scroller.getVisibleRange(notes.length);

      expect(visibleRange.start).toBeGreaterThan(0);
      expect(visibleRange.end).toBeGreaterThan(visibleRange.start);
      expect(visibleRange.end - visibleRange.start).toBeLessThanOrEqual(10); / 600/80 + overscan
    });

    it('should handle scroll to bottom correctly', () => {
      const notes = Array.from({ length: 50 }, () => ({
        id: 'note',
        title: 'Test',
        content: 'Content'
      }));

      const scroller = new NotesVirtualScroller({
        itemHeight: 100,
        overscan: 2,
        estimatedItemHeight: 100
      });

      scroller.setScrollTop(4000); / æ¥è¿‘åº•éƒ¨
      scroller.setContainerHeight(600);

      const visibleRange = scroller.getVisibleRange(notes.length);

      expect(visibleRange.end).toBe(notes.length - 1);
    });
  });

  describe('Scroll Performance', () => {
    it('should handle rapid scrolling without performance degradation', async () => {
      const notes = Array.from({ length: 1000 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: `Content for note ${i}`.repeat(10)
      }));

      const { container } = render(
        <NotesVirtualScroller notes={notes} />
      );

      const scrollTimes: number[] = [];

      for (let i = 0; i < 100; i++) {
        const scrollStart = performance.now();

        fireEvent.scroll(container, {
          target: { scrollTop: Math.random() * 50000 }
        });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const scrollEnd = performance.now();
        scrollTimes.push(scrollEnd - scrollStart);
      }

      const avgScrollTime = scrollTimes.reduce((sum, time) => sum + time, 0)  scrollTimes.length;
      expect(avgScrollTime).toBeLessThan(20); / æ»šåŠ¨å“åº”æ—¶é—´ < 20ms
    });

    it('should maintain smooth rendering with variable heights', async () => {
      const notes = Array.from({ length: 500 }, (_, i) => ({
        id: `note-${i}`,
        title: `Note ${i}`,
        content: 'A'.repeat(i % 20 * 100),
        height: 60 + Math.random() * 120
      }));

      const frameRates: number[] = [];

      const { container } = render(
        <NotesVirtualScroller notes={notes} />
      );

      for (let scrollY = 0; scrollY < 10000; scrollY += 100) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        frameRates.push(1000  (frameEnd - frameStart));
      }

      const avgFrameRate = frameRates.reduce((sum, fps) => sum + fps, 0)  frameRates.length;
      expect(avgFrameRate).toBeGreaterThan(30); / è‡³å°‘30fps
    });
  });
});
```

#### æ‡’åŠ è½½æœºåˆ¶æµ‹è¯•
```typescript
/ src/performance LazyLoader.test.ts
describe('DataLazyLoader TDD', () => {
  describe('Load Triggering', () => {
    it('should trigger load when approaching threshold', () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 20,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn();

      / å½“å‰ç´¢å¼•æ¥è¿‘æ€»æ•°ï¼Œä¸”åœ¨é˜ˆå€¼èŒƒå›´å†…
      const shouldLoad = lazyLoader.shouldLoadMore(95, 100);
      expect(shouldLoad).toBe(true);

      / è¿œç¦»é˜ˆå€¼ï¼Œä¸åº”è¯¥è§¦å‘åŠ è½½
      const shouldNotLoad = lazyLoader.shouldLoadMore(80, 100);
      expect(shouldNotLoad).toBe(false);
    });

    it('should not load multiple times simultaneously', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue(
        Array.from({ length: 10 }, (_, i) => ({ id: `item-${i}` }))
      );

      / åŒæ—¶è§¦å‘ä¸¤æ¬¡åŠ è½½
      const load1 = lazyLoader.loadPage(1, mockLoadFn);
      const load2 = lazyLoader.loadPage(1, mockLoadFn);

      await Promise.all([load1, load2]);

      / åªåº”è¯¥è°ƒç”¨ä¸€æ¬¡åŠ è½½å‡½æ•°
      expect(mockLoadFn).toHaveBeenCalledTimes(1);
      expect(mockLoadFn).toHaveBeenCalledWith(1, 10);
    });
  });

  describe('Page Loading', () => {
    it('should load correct page with correct batch size', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 15,
        preloadCount: 1
      });

      const mockData = Array.from({ length: 15 }, (_, i) => ({
        id: `item-${i}`,
        title: `Item ${i}`
      }));

      const mockLoadFn = jest.fn().mockResolvedValue(mockData);

      const result = await lazyLoader.loadPage(2, mockLoadFn);

      expect(mockLoadFn).toHaveBeenCalledWith(2, 15);
      expect(result).toEqual(mockData);
    });

    it('should return empty array for already loaded page', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([
        { id: 'item-1', title: 'Item 1' }
      ]);

      / ç¬¬ä¸€æ¬¡åŠ è½½
      await lazyLoader.loadPage(1, mockLoadFn);
      expect(mockLoadFn).toHaveBeenCalledTimes(1);

      / ç¬¬äºŒæ¬¡åŠ è½½åŒä¸€é¡µ
      const result = await lazyLoader.loadPage(1, mockLoadFn);
      expect(result).toEqual([]);
      expect(mockLoadFn).toHaveBeenCalledTimes(1); / æ²¡æœ‰å†æ¬¡è°ƒç”¨
    });
  });

  describe('Preloading Strategy', () => {
    it('should preload next page asynchronously', async (done) => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([]);

      / é¢„åŠ è½½ä¸‹ä¸€é¡µ
      await lazyLoader.preloadNextPage(1, mockLoadFn);

      / ä½¿ç”¨setTimeoutéªŒè¯å¼‚æ­¥è°ƒç”¨
      setTimeout(() => {
        expect(mockLoadFn).toHaveBeenCalledWith(2, 10);
        done();
      }, 150);
    });

    it('should not preload already loaded pages', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 10,
        preloadCount: 1
      });

      const mockLoadFn = jest.fn().mockResolvedValue([]);

      / å…ˆåŠ è½½ç¬¬2é¡µ
      await lazyLoader.loadPage(2, mockLoadFn);

      / é‡ç½®mock
      mockLoadFn.mockClear();

      / å°è¯•é¢„åŠ è½½ç¬¬2é¡µ
      await lazyLoader.preloadNextPage(1, mockLoadFn);

      expect(mockLoadFn).not.toHaveBeenCalled();
    });
  });
});

describe('MediaLazyLoader TDD', () => {
  describe('Image Loading', () => {
    it('should load image when intersecting viewport', async () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      mockImage.dataset.src = 'test-image.jpg';

      const mockIntersection = {
        isIntersecting: true,
        target: mockImage
      } as IntersectionObserverEntry;

      / æ¨¡æ‹Ÿè¿›å…¥è§†å£
      mediaLoader.handleIntersection([mockIntersection]);

      / éªŒè¯å›¾ç‰‡srcè¢«è®¾ç½®
      expect(mockImage.src).toContain('test-image.jpg');
    });

    it('should not load image until intersecting', () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      mockImage.dataset.src = 'test-image.jpg';

      const mockIntersection = {
        isIntersecting: false,
        target: mockImage
      } as IntersectionObserverEntry;

      / æ¨¡æ‹Ÿä¸åœ¨è§†å£å†…
      mediaLoader.handleIntersection([mockIntersection]);

      / éªŒè¯å›¾ç‰‡srcæœªè¢«è®¾ç½®
      expect(mockImage.src).toBe('');
      expect(mockImage.dataset.src).toBe('test-image.jpg');
    });
  });

  describe('Caching', () => {
    it('should not reload already loaded images', () => {
      const mediaLoader = new MediaLazyLoader();

      const mockImage = document.createElement('img');
      const src = 'cached-image.jpg';

      / å…ˆæ ‡è®°ä¸ºå·²åŠ è½½
      mediaLoader.markAsLoaded(src);

      / ç›´æ¥è®¾ç½®srcï¼Œä¸éœ€è¦è§‚å¯Ÿ
      mediaLoader.observeImage(mockImage, src);

      expect(mockImage.src).toContain(src);
    });
  });
});
```

#### ä½ç½®ç¼“å­˜æµ‹è¯•
```typescript
/ src/performance PositionCache.test.ts
describe('OptimizedPositionCache TDD', () => {
  let cache: OptimizedPositionCache;

  beforeEach(() => {
    cache = new OptimizedPositionCache(100, 1000); / æœ€å¤§100æ¡ï¼Œ1ç§’TTLç”¨äºæµ‹è¯•
  });

  afterEach(() => {
    cache.destroy();
  });

  describe('Cache Operations', () => {
    it('should store and retrieve positions', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };
      const view = 'flow' as ViewType;

      cache.setPosition(key, position, view);
      const cached = cache.getPosition(key, view);

      expect(cached).toEqual({
        x: 100,
        y: 200,
        view: 'flow',
        timestamp: expect.any(Number),
        dirty: false
      });
    });

    it('should return null for non-existent keys', () => {
      const result = cache.getPosition('non-existent', 'flow' as ViewType);
      expect(result).toBeNull();
    });

    it('should return null for expired entries', (done) => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);

      / ç­‰å¾…è¶…è¿‡TTLæ—¶é—´
      setTimeout(() => {
        const result = cache.getPosition(key, 'flow' as ViewType);
        expect(result).toBeNull();
        done();
      }, 1100);
    });

    it('should return null for different views', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);

      const result = cache.getPosition(key, 'daily' as ViewType);
      expect(result).toBeNull();
    });
  });

  describe('Cache Size Management', () => {
    it('should evict oldest entries when at capacity', () => {
      / å¡«æ»¡ç¼“å­˜
      for (let i = 0; i < 100; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
      }

      / æ·»åŠ ç¬¬101æ¡è®°å½•ï¼Œåº”è¯¥é©±é€æœ€æ—§çš„
      cache.setPosition('note-100', { x: 100, y: 100 }, 'flow' as ViewType);

      / éªŒè¯æœ€æ—§çš„è®°å½•è¢«é©±é€
      const oldest = cache.getPosition('note-0', 'flow' as ViewType);
      expect(oldest).toBeNull();

      / éªŒè¯æœ€æ–°è®°å½•å­˜åœ¨
      const newest = cache.getPosition('note-100', 'flow' as ViewType);
      expect(newest).toBeDefined();
    });

    it('should handle eviction correctly', () => {
      const positions = [];

      / æ·»åŠ è®°å½•å¹¶è®°å½•æ—¶é—´æˆ³
      for (let i = 0; i < 105; i++) {
        const position = { x: i, y: i };
        cache.setPosition(`note-${i}`, position, 'flow' as ViewType);
        positions.push({ key: `note-${i}`, position });
      }

      / éªŒè¯ç¼“å­˜å¤§å°ä¸è¶…è¿‡æœ€å¤§å€¼
      const size = cache.getSize();
      expect(size).toBeLessThanOrEqual(100);

      / éªŒè¯æœ€æ–°è®°å½•ä»ç„¶å­˜åœ¨
      const latest = cache.getPosition('note-104', 'flow' as ViewType);
      expect(latest).toBeDefined();
    });
  });

  describe('Dirty Data Management', () => {
    it('should mark entries as dirty', () => {
      const key = 'note-1';
      const position = { x: 100, y: 200 };

      cache.setPosition(key, position, 'flow' as ViewType);
      cache.markDirty(key);

      const cached = cache.getPosition(key, 'flow' as ViewType);
      expect(cached?.dirty).toBe(true);
    });

    it('should flush dirty entries', async () => {
      const mockPersist = jest.fn().mockResolvedValue(undefined);
      cache.setPersistFunction(mockPersist);

      / æ·»åŠ è„æ•°æ®
      for (let i = 0; i < 5; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
        cache.markDirty(`note-${i}`);
      }

      await cache.flushDirty();

      expect(mockPersist).toHaveBeenCalledTimes(5);

      / éªŒè¯è„æ ‡è®°è¢«æ¸…é™¤
      for (let i = 0; i < 5; i++) {
        const cached = cache.getPosition(`note-${i}`, 'flow' as ViewType);
        expect(cached?.dirty).toBe(false);
      }
    });
  });

  describe('Batch Operations', () => {
    it('should handle batch position updates', () => {
      const updates = [
        { key: 'note-1', position: { x: 100, y: 200 }, view: 'flow' as ViewType },
        { key: 'note-2', position: { x: 150, y: 250 }, view: 'flow' as ViewType },
        { key: 'note-3', position: { x: 200, y: 300 }, view: 'daily' as ViewType }
      ];

      cache.batchUpdatePositions(updates);

      updates.forEach(({ key, position, view }) => {
        const cached = cache.getPosition(key, view);
        expect(cached).toEqual({
          x: position.x,
          y: position.y,
          view,
          timestamp: expect.any(Number),
          dirty: false
        });
      });
    });

    it('should handle batch updates efficiently', () => {
      const startTime = performance.now();

      const updates = Array.from({ length: 1000 }, (_, i) => ({
        key: `note-${i}`,
        position: { x: i * 10, y: i * 10 },
        view: (i % 2 === 0 ? 'flow' : 'daily') as ViewType
      }));

      cache.batchUpdatePositions(updates);

      const endTime = performance.now();
      expect(endTime - startTime).toBeLessThan(50); / æ‰¹é‡æ›´æ–°åº”è¯¥å¾ˆå¿«
    });
  });

  describe('Performance Benchmarks', () => {
    it('should handle 10,000 operations within threshold', () => {
      const startTime = performance.now();

      / å¤§é‡è¯»å†™æ“ä½œ
      for (let i = 0; i < 10000; i++) {
        const key = `note-${i % 100}`; / é‡å¤ä½¿ç”¨keyæµ‹è¯•ç¼“å­˜å‘½ä¸­
        cache.setPosition(key, { x: i, y: i }, 'flow' as ViewType);
        cache.getPosition(key, 'flow' as ViewType);
      }

      const endTime = performance.now();
      expect(endTime - startTime).toBeLessThan(100); / 100mså†…å®Œæˆ10kæ“ä½œ
    });

    it('should maintain performance under concurrent access', () => {
      const promises = Array.from({ length: 100 }, (_, i) =>
        new Promise<void>((resolve) => {
          setTimeout(() => {
            cache.setPosition(`concurrent-${i}`, { x: i, y: i }, 'flow' as ViewType);
            cache.getPosition(`concurrent-${i}`, 'flow' as ViewType);
            resolve();
          }, Math.random() * 10);
        })
      );

      const startTime = performance.now();

      return Promise.all(promises).then(() => {
        const endTime = performance.now();
        expect(endTime - startTime).toBeLessThan(50);
      });
    });
  });
});
```

#### é˜²æŠ–å’Œæ‰¹é‡å¤„ç†æµ‹è¯•
```typescript
/ src/performance PerformanceOptimizer.test.ts
describe('PerformanceOptimizer TDD', () => {
  let optimizer: PerformanceOptimizer;

  beforeEach(() => {
    optimizer = new PerformanceOptimizer();
  });

  afterEach(() => {
    optimizer.destroy();
  });

  describe('Debouncing', () => {
    it('should delay function execution', (done) => {
      const mockFn = jest.fn();
      const debouncedFn = optimizer.debounce('test', mockFn, 100);

      debouncedFn('arg1', 'arg2');

      / ç«‹å³æ£€æŸ¥ï¼Œä¸åº”è¯¥æ‰§è¡Œ
      expect(mockFn).not.toHaveBeenCalled();

      / 100msååº”è¯¥æ‰§è¡Œ
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
        expect(mockFn).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });

    it('should cancel previous pending execution', (done) => {
      const mockFn = jest.fn();
      const debouncedFn = optimizer.debounce('test', mockFn, 100);

      debouncedFn('first');
      debouncedFn('second');
      debouncedFn('third');

      / 150msååº”è¯¥åªæ‰§è¡Œæœ€åä¸€æ¬¡
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledWith('third');
        expect(mockFn).toHaveBeenCalledTimes(1);
        done();
      }, 150);
    });

    it('should handle multiple debounced functions independently', (done) => {
      const mockFn1 = jest.fn();
      const mockFn2 = jest.fn();

      const debounced1 = optimizer.debounce('fn1', mockFn1, 50);
      const debounced2 = optimizer.debounce('fn2', mockFn2, 50);

      debounced1('fn1-arg');
      debounced2('fn2-arg');

      setTimeout(() => {
        expect(mockFn1).toHaveBeenCalledWith('fn1-arg');
        expect(mockFn2).toHaveBeenCalledWith('fn2-arg');
        done();
      }, 100);
    });
  });

  describe('Throttling', () => {
    it('should limit function execution frequency', (done) => {
      const mockFn = jest.fn();
      const throttledFn = optimizer.throttle('test', mockFn, 100);

      / å¿«é€Ÿè°ƒç”¨å¤šæ¬¡
      throttledFn();
      throttledFn();
      throttledFn();
      throttledFn();

      / ç«‹å³æ‰§è¡Œç¬¬ä¸€æ¬¡
      expect(mockFn).toHaveBeenCalledTimes(1);

      / 100mså†…ä¸åº”è¯¥å†æ¬¡æ‰§è¡Œ
      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledTimes(1);

        / 100msååº”è¯¥å¯ä»¥å†æ¬¡æ‰§è¡Œ
        setTimeout(() => {
          throttledFn();
          expect(mockFn).toHaveBeenCalledTimes(2);
          done();
        }, 50);
      }, 100);
    });

    it('should handle throttling with correct interval', (done) => {
      const mockFn = jest.fn();
      const throttledFn = optimizer.throttle('test', mockFn, 200);

      const startTime = Date.now();

      throttledFn(); / ç¬¬ä¸€æ¬¡æ‰§è¡Œ

      setTimeout(() => throttledFn(), 150); / ä¸æ‰§è¡Œ
      setTimeout(() => throttledFn(), 250); / æ‰§è¡Œ

      setTimeout(() => {
        expect(mockFn).toHaveBeenCalledTimes(2);
        done();
      }, 300);
    });
  });

  describe('Batch Processing', () => {
    it('should batch function calls in single animation frame', (done) => {
      const mockFns = Array.from({ length: 5 }, (_, i) =>
        jest.fn().mockReturnValue(`result-${i}`)
      );

      / æ·»åŠ å¤šä¸ªå‡½æ•°åˆ°æ‰¹æ¬¡
      mockFns.forEach((fn, index) => {
        optimizer.batch('test', fn);
      });

      / åº”è¯¥åœ¨ä¸‹ä¸€ä¸ªåŠ¨ç”»å¸§æ‰§è¡Œ
      requestAnimationFrame(() => {
        mockFns.forEach(fn => {
          expect(fn).toHaveBeenCalledTimes(1);
        });
        done();
      });
    });

    it('should handle multiple batch keys independently', (done) => {
      const batch1Fns = [jest.fn(), jest.fn()];
      const batch2Fns = [jest.fn(), jest.fn(), jest.fn()];

      batch1Fns.forEach(fn => optimizer.batch('batch1', fn));
      batch2Fns.forEach(fn => optimizer.batch('batch2', fn));

      requestAnimationFrame(() => {
        batch1Fns.forEach(fn => expect(fn).toHaveBeenCalledTimes(1));
        batch2Fns.forEach(fn => expect(fn).toHaveBeenCalledTimes(1));
        done();
      });
    });

    it('should clear batch after execution', (done) => {
      const mockFn = jest.fn();

      optimizer.batch('test', mockFn);

      requestAnimationFrame(() => {
        expect(mockFn).toHaveBeenCalledTimes(1);

        / ä¸‹ä¸€ä¸ªåŠ¨ç”»å¸§åº”è¯¥æ²¡æœ‰å¾…æ‰§è¡Œçš„å‡½æ•°
        requestAnimationFrame(() => {
          expect(mockFn).toHaveBeenCalledTimes(1); / æ²¡æœ‰å¢åŠ 
          done();
        });
      });
    });
  });

  describe('Performance Optimization', () => {
    it('should reduce rapid state updates', () => {
      const mockSetState = jest.fn();
      const optimizedSetState = optimizer.debounce('setState', mockSetState, 50);

      / æ¨¡æ‹Ÿå¿«é€ŸçŠ¶æ€æ›´æ–°
      for (let i = 0; i < 100; i++) {
        optimizedSetState({ count: i });
      }

      / ç«‹å³æ£€æŸ¥ï¼Œä¸åº”è¯¥æ‰§è¡Œ
      expect(mockSetState).not.toHaveBeenCalled();

      / ç­‰å¾…é˜²æŠ–å®Œæˆ
      jest.advanceTimersByTime(50);
      expect(mockSetState).toHaveBeenCalledTimes(1);
      expect(mockSetState).toHaveBeenCalledWith({ count: 99 }); / åªæ‰§è¡Œæœ€åä¸€æ¬¡
    });

    it('should batch DOM updates efficiently', () => {
      const mockDOMUpdate = jest.fn();

      / æ¨¡æ‹Ÿå¤šä¸ªDOMæ›´æ–°
      for (let i = 0; i < 10; i++) {
        optimizer.batch('domUpdate', () => mockDOMUpdate(i));
      }

      / å¼ºåˆ¶æ‰§è¡Œæ‰¹æ¬¡
      jest.runAllTimers();

      expect(mockDOMUpdate).toHaveBeenCalledTimes(10);
      expect(mockDOMUpdate).toHaveBeenLastCalledWith(9);
    });
  });

  describe('Memory Management', () => {
    it('should cleanup timers and animation frames', () => {
      const debouncedFn = optimizer.debounce('test', jest.fn(), 100);
      debouncedFn();

      const throttledFn = optimizer.throttle('test2', jest.fn(), 100);
      throttledFn();

      optimizer.batch('test3', jest.fn());

      / é”€æ¯æ—¶åº”è¯¥æ¸…ç†æ‰€æœ‰èµ„æº
      optimizer.destroy();

      / éªŒè¯æ¸…ç†ï¼ˆåœ¨å®é™…å®ç°ä¸­éœ€è¦å†…éƒ¨è·Ÿè¸ªï¼‰
      expect(true).toBe(true); / è¿™é‡Œå¯ä»¥æ·»åŠ å†…éƒ¨çŠ¶æ€éªŒè¯
    });
  });
});
```

#### æ€§èƒ½åŸºå‡†æµ‹è¯•
```typescript
/ src/test/performance/performance-benchmarks.test.ts
describe('Performance Benchmarks TDD', () => {
  describe('Virtualization Performance', () => {
    it('should render 10,000 virtual nodes within threshold', () => {
      const nodes = Array.from({ length: 10000 }, (_, i) => ({
        id: `node-${i}`,
        x: (i % 20) * 50,
        y: Math.floor(i  20) * 50,
        data: { title: `Node ${i}` }
      }));

      const startTime = performance.now();

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(200); / 200mså†…å®Œæˆ
      expect(container.children.length).toBeLessThan(200); / åªæ¸²æŸ“å¯è§èŠ‚ç‚¹
    });

    it('should maintain smooth scrolling with large dataset', async () => {
      const nodes = Array.from({ length: 5000 }, (_, i) => ({
        id: `node-${i}`,
        x: i * 10,
        y: Math.floor(i  100) * 10,
        data: { title: `Node ${i}` }
      }));

      const { container } = render(
        <FlowVirtualizer nodes={nodes} />
      );

      const frameDrops: number[] = [];

      for (let scrollY = 0; scrollY < 10000; scrollY += 50) {
        const frameStart = performance.now();

        fireEvent.scroll(container, { target: { scrollTop: scrollY } });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });

        const frameEnd = performance.now();
        const frameTime = frameEnd - frameStart;

        if (frameTime > 16.67) { / è¶…è¿‡60fpsé˜ˆå€¼
          frameDrops.push(frameTime);
        }
      }

      / å¸§ä¸¢å¤±åº”è¯¥å°‘äº5%
      expect(frameDrops.length  200).toBeLessThan(0.05);
    });
  });

  describe('Memory Performance', () => {
    it('should not leak memory during virtual scrolling', async () => {
      const initialMemory = performance.memory?.usedJSHeapSize || 0;

      const { container, unmount } = render(
        <FlowVirtualizer nodes={generateLargeNodeSet(1000)} />
      );

      / æ¨¡æ‹Ÿå¤§é‡æ»šåŠ¨æ“ä½œ
      for (let i = 0; i < 100; i++) {
        fireEvent.scroll(container, {
          target: { scrollTop: Math.random() * 50000 }
        });

        await waitFor(() => {
          expect(container).toBeInTheDocument();
        });
      }

      unmount();

      / å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (global.gc) {
        global.gc();
      }

      const finalMemory = performance.memory?.usedJSHeapSize || 0;
      const memoryIncrease = finalMemory - initialMemory;

      / å†…å­˜å¢é•¿åº”è¯¥å°äº10MB
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
    });

    it('should cleanup cached positions properly', () => {
      const cache = new OptimizedPositionCache(1000, 1000);

      / å¡«å……ç¼“å­˜
      for (let i = 0; i < 2000; i++) {
        cache.setPosition(`note-${i}`, { x: i, y: i }, 'flow' as ViewType);
      }

      const midSize = cache.getSize();
      expect(midSize).toBeLessThanOrEqual(1000);

      / æ¸…ç†è¿‡æœŸæ¡ç›®
      cache.cleanup();

      const finalSize = cache.getSize();
      expect(finalSize).toBeLessThanOrEqual(midSize);

      cache.destroy();
    });
  });

  describe('Batch Processing Performance', () => {
    it('should handle large batch updates efficiently', () => {
      const optimizer = new PerformanceOptimizer();
      const updateCount = 10000;

      const startTime = performance.now();

      / æ·»åŠ å¤§é‡æ›´æ–°åˆ°æ‰¹æ¬¡
      for (let i = 0; i < updateCount; i++) {
        optimizer.batch('updates', () => {
          / æ¨¡æ‹Ÿæ›´æ–°æ“ä½œ
          return i;
        });
      }

      / ç­‰å¾…æ‰¹æ¬¡æ‰§è¡Œ
      jest.runAllTimers();

      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(100); / 100mså†…å®Œæˆ10kæ›´æ–°
      expect(optimizer.getBatchSize('updates')).toBe(0); / æ‰¹æ¬¡åº”è¯¥è¢«æ¸…ç©º

      optimizer.destroy();
    });

    it('should reduce API calls through debouncing', () => {
      const mockAPI = jest.fn().mockResolvedValue([]);
      const optimizer = new PerformanceOptimizer();
      const debouncedAPI = optimizer.debounce('api', mockAPI, 100);

      / æ¨¡æ‹Ÿå¿«é€ŸAPIè°ƒç”¨
      for (let i = 0; i < 100; i++) {
        debouncedAPI({ data: i });
      }

      / ç«‹å³æ£€æŸ¥ï¼Œä¸åº”è¯¥è°ƒç”¨
      expect(mockAPI).not.toHaveBeenCalled();

      / ç­‰å¾…é˜²æŠ–å®Œæˆ
      jest.advanceTimersByTime(100);

      / åªåº”è¯¥è°ƒç”¨ä¸€æ¬¡API
      expect(mockAPI).toHaveBeenCalledTimes(1);
      expect(mockAPI).toHaveBeenCalledWith({ data: 99 });

      optimizer.destroy();
    });
  });

  describe('Lazy Loading Performance', () => {
    it('should load data without blocking UI', async () => {
      const lazyLoader = new DataLazyLoader({
        threshold: 5,
        batchSize: 20,
        preloadCount: 2
      });

      const mockLoadFn = jest.fn().mockImplementation((page, size) => {
        / æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(Array.from({ length: size }, (_, i) => ({
              id: `item-${page}-${i}`,
              title: `Item ${page}-${i}`
            })));
          }, 50);
        });
      });

      const startTime = performance.now();

      / è§¦å‘åŠ è½½
      const loadPromise = lazyLoader.loadPage(1, mockLoadFn);

      / æ£€æŸ¥UIæ˜¯å¦ä»ç„¶å“åº”
      const uiResponsiveCheck = performance.now() - startTime;
      expect(uiResponsiveCheck).toBeLessThan(10); / UIåº”è¯¥ç«‹å³ä¿æŒå“åº”

      await loadPromise;

      const totalTime = performance.now() - startTime;
      expect(totalTime).toBeGreaterThan(40); / åº”è¯¥ç­‰å¾…ç½‘ç»œå»¶è¿Ÿ

      expect(mockLoadFn).toHaveBeenCalledWith(1, 20);
    });
  });
});
```

### TDDç»„ä»¶æ¶æ„è®¾è®¡

#### æ ¸å¿ƒæ¥å£
```typescript
/ src/performance/types.ts
interface VirtualizationConfig {
  containerSize: { width: number; height: number };
  itemSize: { width: number; height: number };
  overscan: number;
  bufferSize: number;
}

interface LazyLoadConfig {
  threshold: number;
  batchSize: number;
  preloadCount: number;
}

interface PerformanceMetrics {
  renderTime: number;
  memoryUsage: number;
  cacheHitRate: number;
  frameRate: number;
}

class FlowVirtualizer {
  calculateVisibleRange(scrollOffset: { x: number; y: number }): Range;
  renderVirtualizedNodes(nodes: FlowNode[]): ReactElement;
}

class NotesVirtualScroller {
  getItemHeight(index: number): number;
  getVisibleRange(itemsCount: number): Range;
  renderVirtualizedList(notes: NoteRecord[]): ReactElement;
}

class DataLazyLoader {
  shouldLoadMore(currentIndex: number, totalItems: number): boolean;
  loadPage(pageIndex: number, loader: Function): Promise<any[]>;
  preloadNextPage(currentPage: number, loader: Function): Promise<void>;
}

class OptimizedPositionCache {
  getPosition(key: string, view: ViewType): CachedPosition | null;
  setPosition(key: string, position: { x: number; y: number }, view: ViewType): void;
  batchUpdatePositions(updates: PositionUpdate[]): void;
}
```

### TDDå®ç°è¦ç‚¹

#### Redé˜¶æ®µï¼šå¤±è´¥çš„æµ‹è¯•
- **è™šæ‹ŸåŒ–å‡†ç¡®æ€§æµ‹è¯•**ï¼šå¯è§èŒƒå›´è®¡ç®—ã€èŠ‚ç‚¹å®šä½ã€æ»šåŠ¨å“åº”
- **æ‡’åŠ è½½æ—¶æœºæµ‹è¯•**ï¼šé˜ˆå€¼è§¦å‘ã€é¢„åŠ è½½ç­–ç•¥ã€å¹¶å‘æ§åˆ¶
- **ç¼“å­˜æ€§èƒ½æµ‹è¯•**ï¼šå‘½ä¸­ç‡ã€æ›´æ–°ç­–ç•¥ã€å†…å­˜ç®¡ç†
- **é˜²æŠ–æ‰¹é‡æµ‹è¯•**ï¼šå»¶è¿Ÿæ‰§è¡Œã€é¢‘ç‡é™åˆ¶ã€æ‰¹æ¬¡å¤„ç†
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¤§é‡æ•°æ®æ¸²æŸ“ã€å†…å­˜ä½¿ç”¨ã€å¸§ç‡ç¨³å®š

#### Greené˜¶æ®µï¼šæœ€å°å®ç°
- **åŸºç¡€è™šæ‹ŸåŒ–**ï¼šå®ç°æœ€ç®€çš„å¯è§åŒºåŸŸè®¡ç®—å’ŒèŠ‚ç‚¹æ¸²æŸ“
- **ç®€å•æ‡’åŠ è½½**ï¼šåŸºç¡€çš„é˜ˆå€¼åˆ¤æ–­å’Œé¡µé¢åŠ è½½æœºåˆ¶
- **åŸºæœ¬ç¼“å­˜**ï¼šç®€å•çš„Mapå­˜å‚¨å’ŒTTLè¿‡æœŸæœºåˆ¶
- **é˜²æŠ–æ‰¹é‡**ï¼šä½¿ç”¨setTimeoutå’ŒrequestAnimationFrameçš„åŸºç¡€å®ç°

#### Refactoré˜¶æ®µï¼šä¼˜åŒ–æå‡
- **ç®—æ³•ä¼˜åŒ–**ï¼šæ›´é«˜æ•ˆçš„è™šæ‹ŸåŒ–è®¡ç®—å’Œç¼“å­˜ç­–ç•¥
- **æ€§èƒ½è°ƒä¼˜**ï¼šæ ¹æ®åŸºå‡†æµ‹è¯•ç»“æœè°ƒæ•´å‚æ•°
- **å†…å­˜ä¼˜åŒ–**ï¼šå‡å°‘ä¸å¿…è¦çš„å¯¹è±¡åˆ›å»ºå’Œå¼•ç”¨
- **ç”¨æˆ·ä½“éªŒ**ï¼šå¹³æ»‘åŠ¨ç”»ã€åŠ è½½çŠ¶æ€ã€é”™è¯¯å¤„ç†

### ä»£ç æ–‡ä»¶å½±å“

#### TDDæµ‹è¯•æ–‡ä»¶ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
- `src/performance FlowVirtualizer.test.tsx` - Flowè™šæ‹ŸåŒ–æµ‹è¯•
- `src/performance NotesVirtualScroller.test.tsx` - ç¬”è®°è™šæ‹Ÿæ»šåŠ¨æµ‹è¯•
- `src/performance LazyLoader.test.ts` - æ‡’åŠ è½½æœºåˆ¶æµ‹è¯•
- `src/performance PositionCache.test.ts` - ä½ç½®ç¼“å­˜æµ‹è¯•
- `src/performance PerformanceOptimizer.test.ts` - æ€§èƒ½ä¼˜åŒ–å™¨æµ‹è¯•
- `src/test/performance/performance-benchmarks.test.ts` - æ€§èƒ½åŸºå‡†æµ‹è¯•

#### æ ¸å¿ƒå®ç°æ–‡ä»¶
- `src/performance/virtualization/FlowVirtualizer.tsx` - Flowè™šæ‹ŸåŒ–ç»„ä»¶
- `src/performance/virtualization/NotesVirtualScroller.tsx` - ç¬”è®°è™šæ‹Ÿæ»šåŠ¨
- `src/performance/lazyload/DataLazyLoader.ts` - æ•°æ®æ‡’åŠ è½½
- `src/performance/lazyload/MediaLazyLoader.ts` - åª’ä½“æ‡’åŠ è½½
- `src/performance/cache/OptimizedPositionCache.ts` - ä¼˜åŒ–ä½ç½®ç¼“å­˜
- `src/performance/optimizer/PerformanceOptimizer.ts` - æ€§èƒ½ä¼˜åŒ–å™¨
- `src/hooks/performance/` - æ€§èƒ½ç›¸å…³hooks
- `src/utils/performance.ts` - æ€§èƒ½å·¥å…·å‡½æ•°

## Dependencies

- [ ] **ä»»åŠ¡008ï¼šTDDåŸºç¡€è®¾æ–½**å®Œæˆï¼Œæµ‹è¯•æ¡†æ¶å°±ä½
- [ ] **ä»»åŠ¡005ï¼šè§†å›¾å¼•æ“**å®Œæˆï¼Œè§†å›¾ç³»ç»Ÿå¯ç”¨
- [ ] **ä»»åŠ¡006ï¼šçŠ¶æ€ç®¡ç†**å®Œæˆï¼ŒçŠ¶æ€ç®¡ç†å¯ç”¨
- [ ] Reactè™šæ‹ŸåŒ–åº“ï¼ˆreact-windowæˆ–@tanstack/react-virtualï¼‰
- [ ] Intersection Observer API
- [ ] Performance API
- [ ] Jestæ€§èƒ½æµ‹è¯•æ‰©å±•

## Effort Estimate

- Size: Lï¼ˆåŒ…å«å¤§é‡æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–å·¥ä½œï¼‰
- Days: 3-4å¤©
- Parallel: true

### å·¥ä½œé‡åˆ†è§£
- **TDDæµ‹è¯•ç¼–å†™**ï¼š1.5å¤©ï¼ˆæœ€é‡è¦ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼‰
- **åŠŸèƒ½å®ç°**ï¼š1.5å¤©ï¼ˆè®©æµ‹è¯•é€šè¿‡ï¼‰
- **é‡æ„ä¼˜åŒ–**ï¼š0.5å¤©ï¼ˆæ€§èƒ½è°ƒä¼˜ï¼‰
- **é›†æˆéªŒè¯**ï¼š0.5å¤©ï¼ˆç«¯åˆ°ç«¯æ€§èƒ½æµ‹è¯•ï¼‰

## Definition of Done

- [ ] **TDDæµç¨‹å®Œæ•´**ï¼šRed-Green-Refactorå¾ªç¯å®Œæ•´æ‰§è¡Œ
- [ ] **è™šæ‹ŸåŒ–ç³»ç»Ÿ**ï¼šæ”¯æŒ1000+èŠ‚ç‚¹æµç•…æ¸²æŸ“ï¼Œæ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] **æ‡’åŠ è½½æœºåˆ¶**ï¼šæ•°æ®å’Œåª’ä½“æŒ‰éœ€åŠ è½½ï¼Œæ—¶æœºå‡†ç¡®
- [ ] **ç¼“å­˜ä¼˜åŒ–**ï¼šä½ç½®ç¼“å­˜å‘½ä¸­ç‡â‰¥90%ï¼Œå†…å­˜ä½¿ç”¨ä¼˜åŒ–
- [ ] **é˜²æŠ–æ‰¹é‡**ï¼šé¢‘ç¹æ“ä½œåœºæ™¯æ€§èƒ½æå‡æ˜æ˜¾
- [ ] **æ€§èƒ½è¾¾æ ‡**ï¼šæ‰€æœ‰åŸºå‡†æµ‹è¯•é€šè¿‡ï¼Œ60fpsç¨³å®š
- [ ] **å†…å­˜ç®¡ç†**ï¼šæ— å†…å­˜æ³„æ¼ï¼Œé•¿æœŸä½¿ç”¨ç¨³å®š
- [ ] **ä»£ç è´¨é‡**ï¼šæµ‹è¯•è¦†ç›–ç‡â‰¥90%ï¼Œé€šè¿‡æ‰€æœ‰æ£€æŸ¥
- [ ] **æ€§èƒ½ç›‘æ§**ï¼šé›†æˆæ€§èƒ½ç›‘æ§å·¥å…·ï¼Œå¯å®æ—¶æŸ¥çœ‹æŒ‡æ ‡