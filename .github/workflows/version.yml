name: Version and Release

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  release:
    if: github.event.pull_request.merged == true
    name: Auto Version and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          lfs: true
          submodules: recursive
          
      - name: Setup Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 'latest'

      - name: Setup Bun cache
        uses: actions/cache@v3
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-
            
      - name: Install dependencies
        run: bun install --frozen
        
      # 基于提交信息自动更新版本
      - name: Auto-detect changes and update versions
        run: |
          # 获取上次发布后的提交
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            # 如果没有标签，获取所有提交
            COMMITS=$(git log --pretty=format:"%s")
          else
            # 获取自上次标签以来的提交
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
          fi
          
          # 创建临时目录
          mkdir -p .changeset
          
          # 分析提交信息并创建 changeset
          echo "Analyzing commits for version updates..."
          
          # 为每个包创建变更类型映射
          declare -A PKG_CHANGES
          
          # 初始化所有包为空更新类型
          for pkg_dir in packages/*; do
            if [ -f "$pkg_dir/package.json" ]; then
              PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
              PKG_CHANGES[$PKG_NAME]=""
            fi
          done
          
          # 分析提交信息
          echo "$COMMITS" | while read -r commit; do
            # 提取包名和更新类型
            if [[ $commit =~ ^(feat|fix|chore|refactor|docs|test|style|perf|build|ci|revert)(\([a-zA-Z0-9_-]+\))?!?:.*$ ]]; then
              TYPE=${BASH_REMATCH[1]}
              PKG=${BASH_REMATCH[2]}
              
              # 移除括号
              PKG=${PKG//[()]/}
              
              # 检查是否有破坏性更改标记
              if [[ $commit == *"!"* ]]; then
                CHANGE_TYPE="major"
              elif [[ $TYPE == "feat" ]]; then
                CHANGE_TYPE="minor"
              else
                CHANGE_TYPE="patch"
              fi
              
              # 如果指定了包
              if [ ! -z "$PKG" ]; then
                # 查找匹配的包
                for pkg_dir in packages/*; do
                  if [ -f "$pkg_dir/package.json" ]; then
                    PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
                    PKG_DIR=$(basename $pkg_dir)
                    # 从包名中提取短名称（不含@noteum/前缀）
                    PKG_SHORT_NAME=${PKG_NAME#@noteum/}
                    if [[ $PKG_SHORT_NAME == "$PKG" ]] || [[ $PKG_DIR == "$PKG" ]]; then
                      # 更新包的变更类型（使用最高级别）
                      CURRENT=${PKG_CHANGES[$PKG_NAME]}
                      if [ -z "$CURRENT" ] || 
                         [ "$CURRENT" == "patch" -a "$CHANGE_TYPE" != "patch" ] || 
                         [ "$CURRENT" == "minor" -a "$CHANGE_TYPE" == "major" ]; then
                        PKG_CHANGES[$PKG_NAME]=$CHANGE_TYPE
                      fi
                    fi
                  fi
                done
              else
                # 如果没有指定包，应用到所有包
                for pkg_dir in packages/*; do
                  if [ -f "$pkg_dir/package.json" ]; then
                    PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
                    CURRENT=${PKG_CHANGES[$PKG_NAME]}
                    if [ -z "$CURRENT" ] || 
                       [ "$CURRENT" == "patch" -a "$CHANGE_TYPE" != "patch" ] || 
                       [ "$CURRENT" == "minor" -a "$CHANGE_TYPE" == "major" ]; then
                      PKG_CHANGES[$PKG_NAME]=$CHANGE_TYPE
                    fi
                  fi
                done
              fi
            fi
          done
          
          # 输出调试信息
          echo "\n\n===== 检测到的包变更 ====="
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              echo "$pkg_name: $CHANGE_TYPE"
            fi
          done
          echo "===========================\n\n"
          
          # 检查是否有变更
          CHANGES_DETECTED=false
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              CHANGES_DETECTED=true
              break
            fi
          done
          
          if [ "$CHANGES_DETECTED" = true ]; then
            # 创建 changeset 文件
            CHANGESET_ID=$(date +%s)
            
            echo '{
            "changes": [' > .changeset/${CHANGESET_ID}.json
            
          # 添加每个包的变更
          CHANGES_COUNT=0
          TOTAL_CHANGES=$(for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              echo $pkg_name
            fi
          done | wc -l)
          
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              CHANGES_COUNT=$((CHANGES_COUNT+1))
              # 检查是否是最后一个元素
              if [ $CHANGES_COUNT -eq $TOTAL_CHANGES ]; then
                echo '{
                "name": "'$pkg_name'",
                "type": "'$CHANGE_TYPE'"
              }' >> .changeset/${CHANGESET_ID}.json
              else
                echo '{
                "name": "'$pkg_name'",
                "type": "'$CHANGE_TYPE'"
              },' >> .changeset/${CHANGESET_ID}.json
              fi
            fi
          done
          
          # 完成 changeset 文件
          echo '],
            "summary": "Auto-generated update based on commit messages"
          }' >> .changeset/${CHANGESET_ID}.json
          
            # 应用版本更新
            bun changeset version
            
            # 提交变更
            git add .
            git commit -m "chore: auto-update versions [skip ci]"
            git push
          else
            echo "\n\n===== 没有检测到包变更，跳过版本更新 ====="
          fi
        
      # 如果有版本更新，创建 GitHub Release
      - name: Create GitHub Release
        run: |
          # 检查是否有版本更新
          if git diff --name-only HEAD^ HEAD | grep -q "package.json"; then
            # 获取最新标签
            git fetch --tags
            
            # 为每个包创建标签和发布
            for pkg_dir in packages/*; do
              if [ -f "$pkg_dir/package.json" ]; then
                PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
                PKG_VERSION=$(jq -r ".version" $pkg_dir/package.json)
                
                TAG_NAME="${PKG_NAME}@${PKG_VERSION}"
                
                # 创建标签
                git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
                
                # 创建 GitHub Release
                gh release create "$TAG_NAME" \
                  --title "Release $TAG_NAME" \
                  --notes "Automated release of $PKG_NAME version $PKG_VERSION"
              fi
            done
            
            # 推送所有标签
            git push --follow-tags
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build packages
        run: |
          # 创建每个包的构建目录
          mkdir -p packages/utils/dist
          mkdir -p packages/core/dist
          mkdir -p packages/ui/dist
          mkdir -p packages/server/dist
          mkdir -p packages/web/dist
          
          # 运行构建脚本
          bun run build

      - name: Clean build artifacts
        run: |
          find . -name "*.tsbuildinfo" -delete
          git checkout -- "*.tsbuildinfo" || true
