name: Version and Release

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  release:
    if: github.event.pull_request.merged == true
    name: Auto Version and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          lfs: true
          submodules: recursive
          
      - name: Setup Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 'latest'

      - name: Setup Bun cache
        uses: actions/cache@v3
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-
            
      - name: Install dependencies
        run: bun install --frozen
        
      # 基于提交信息自动更新版本
      - name: Auto-detect changes and update versions
        run: |
          # 增强调试信息
          echo "===== 版本更新调试信息 ====="
          
          # 获取上次发布后的提交
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "上次发布标签: $LAST_TAG"
          
          if [ -z "$LAST_TAG" ]; then
            # 如果没有标签，获取所有提交
            COMMITS=$(git log --no-merges --pretty=format:"%s")
          else
            # 获取自上次标签以来的提交
            COMMITS=$(git log ${LAST_TAG}..HEAD --no-merges --pretty=format:"%s")
          fi
          
          # 输出找到的提交信息
          echo "找到的提交信息:"
          echo "$COMMITS" | while read -r commit; do
            echo "  - $commit"
          done
          
          # 创建临时目录
          mkdir -p .changeset
          
          # 分析提交信息并创建 changeset
          echo "Analyzing commits for version updates..."
          
          # 为每个包创建变更类型映射
          declare -A PKG_CHANGES
          
          # 初始化所有包为空更新类型
          for pkg_dir in packages/*; do
            if [ -f "$pkg_dir/package.json" ]; then
              PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
              PKG_CHANGES[$PKG_NAME]=""
            fi
          done
          
          # 分析提交信息
          echo "分析提交信息中..."
          # 将提交信息保存到临时文件，避免使用管道导致变量修改丢失
          echo "$COMMITS" > /tmp/commits.txt
          while read -r commit; do
            echo "处理提交: $commit"
            # 提取包名和更新类型 - 改进的正则表达式
            if [[ $commit =~ ^(feat|fix|chore|refactor|docs|test|style|perf|build|ci|revert)\(([a-zA-Z0-9_-]+)\)(!?):.*$ ]]; then
              TYPE=${BASH_REMATCH[1]}
              PKG=${BASH_REMATCH[2]}
              BREAKING=${BASH_REMATCH[3]}
              
              echo "  检测到类型: $TYPE, 包: $PKG, 破坏性更改: $BREAKING"
              
              # 检查是否有破坏性更改标记（必须是"!"）
              if [[ "$BREAKING" == "!" ]]; then
                CHANGE_TYPE="major"
              elif [[ $TYPE == "feat" ]]; then
                CHANGE_TYPE="minor"
              else
                CHANGE_TYPE="patch"
              fi
              
              echo "  变更类型: $CHANGE_TYPE"
              
              # 如果指定了包
              if [ ! -z "$PKG" ]; then
                # 查找匹配的包
                for pkg_dir in packages/*; do
                  if [ -f "$pkg_dir/package.json" ]; then
                    PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
                    PKG_DIR=$(basename $pkg_dir)
                    # 从包名中提取短名称（不含@noteum/前缀）
                    PKG_SHORT_NAME=${PKG_NAME#@noteum/}
                    echo "  比较: commit中的包='$PKG', 实际包名='$PKG_NAME', 短包名='$PKG_SHORT_NAME', 目录名='$PKG_DIR'"
                    if [[ "$PKG" == "$PKG_NAME" ]] || [[ "$PKG" == "$PKG_SHORT_NAME" ]] || [[ "$PKG" == "$PKG_DIR" ]]; then
                      echo "  匹配成功: $PKG_NAME"
                      # 更新包的变更类型（使用最高级别）
                      CURRENT=${PKG_CHANGES[$PKG_NAME]}
                      if [ -z "$CURRENT" ] || 
                         [ "$CURRENT" == "patch" -a "$CHANGE_TYPE" != "patch" ] || 
                         [ "$CURRENT" == "minor" -a "$CHANGE_TYPE" == "major" ]; then
                        PKG_CHANGES[$PKG_NAME]=$CHANGE_TYPE
                        echo "  更新变更类型为: $CHANGE_TYPE"
                      fi
                    fi
                  fi
                done
              else
                echo "  未指定包，变更将应用到所有包"
                # 如果没有指定包，应用到所有包
                for pkg_dir in packages/*; do
                  if [ -f "$pkg_dir/package.json" ]; then
                    PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
                    CURRENT=${PKG_CHANGES[$PKG_NAME]}
                    if [ -z "$CURRENT" ] || 
                       [ "$CURRENT" == "patch" -a "$CHANGE_TYPE" != "patch" ] || 
                       [ "$CURRENT" == "minor" -a "$CHANGE_TYPE" == "major" ]; then
                      PKG_CHANGES[$PKG_NAME]=$CHANGE_TYPE
                      echo "  应用到包: $PKG_NAME, 变更类型: $CHANGE_TYPE"
                    fi
                  fi
                done
              fi
            else
              echo "  不匹配提交格式，跳过: $commit"
            fi
          done < /tmp/commits.txt
          # 清理临时文件
          rm -f /tmp/commits.txt
          
          # 输出包变更信息
          echo "\n\n===== 检测到的包变更 ====="
          CHANGES_FOUND=false
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              echo "$pkg_name: $CHANGE_TYPE"
              CHANGES_FOUND=true
            fi
          done
          
          if [ "$CHANGES_FOUND" = false ]; then
            echo "没有检测到任何包变更"
          fi
          echo "===========================\n\n"
          
          # 检查是否有变更
          CHANGES_DETECTED=false
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              CHANGES_DETECTED=true
              break
            fi
          done
          
          if [ "$CHANGES_DETECTED" = true ]; then
            # 创建 changeset 文件
            CHANGESET_ID=$(date +%s)
            
            echo '{
            "changes": [' > .changeset/${CHANGESET_ID}.json
            
          # 添加每个包的变更
          CHANGES_COUNT=0
          TOTAL_CHANGES=$(for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              echo $pkg_name
            fi
          done | wc -l)
          
          for pkg_name in "${!PKG_CHANGES[@]}"; do
            CHANGE_TYPE=${PKG_CHANGES[$pkg_name]}
            if [ ! -z "$CHANGE_TYPE" ]; then
              CHANGES_COUNT=$((CHANGES_COUNT+1))
              # 检查是否是最后一个元素
              if [ $CHANGES_COUNT -eq $TOTAL_CHANGES ]; then
                echo '{
                "name": "'$pkg_name'",
                "type": "'$CHANGE_TYPE'"
              }' >> .changeset/${CHANGESET_ID}.json
              else
                echo '{
                "name": "'$pkg_name'",
                "type": "'$CHANGE_TYPE'"
              },' >> .changeset/${CHANGESET_ID}.json
              fi
            fi
          done
          
          # 完成 changeset 文件
          echo '],
            "summary": "Auto-generated update based on commit messages"
          }' >> .changeset/${CHANGESET_ID}.json
          
            # 应用版本更新
            bun changeset version
            
            # 提交变更
            git add .
            git commit -m "chore: auto-update versions [skip ci]"
            git push
          else
            echo "\n\n===== 没有检测到包变更，跳过版本更新 ====="
          fi
        
      # 创建并推送标签
      - name: Create and push tags
        run: |
          # 配置 Git 用户信息
          git config user.name github-actions
          git config user.email github-actions@github.com
          
          # 获取所有远程标签
          git fetch --tags
          
          # 遍历所有包并创建标签
          for pkg_dir in packages/*; do
            if [ -f "$pkg_dir/package.json" ]; then
              PKG_NAME=$(jq -r ".name" $pkg_dir/package.json)
              PKG_VERSION=$(jq -r ".version" $pkg_dir/package.json)
              
              TAG_NAME="${PKG_NAME}@${PKG_VERSION}"
              
              # 检查标签是否已存在
              if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
                echo "标签 $TAG_NAME 已存在，跳过"
                continue
              fi
              
              # 创建标签
              git tag "$TAG_NAME"
              
              # 推送标签
              git push origin "$TAG_NAME" || {
                echo "Failed to push tag $TAG_NAME"
                exit 1
              }
              
              echo "Created and pushed tag: $TAG_NAME"
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build packages
        run: |
          # 创建每个包的构建目录
          mkdir -p packages/utils/dist
          mkdir -p packages/core/dist
          mkdir -p packages/ui/dist
          mkdir -p packages/server/dist
          mkdir -p packages/web/dist
          
          # 运行构建脚本
          bun run build

      - name: Clean build artifacts
        run: |
          find . -name "*.tsbuildinfo" -delete
          git checkout -- "*.tsbuildinfo" || true
